# overview/intro-value-group/what-is-whodb.mdx
## What is WhoDB?

WhoDB is a lightweight, high-performance database management tool that empowers users to interact with a wide range of databases—SQL, NoSQL, and cloud—through an intuitive UI and conversational AI. With integration for ChatGPT, Ollama, and Anthropic, users can manage and query data naturally, gaining both speed and insight. WhoDB addresses the needs of developers, DBAs, data scientists, and enterprises requiring efficient, low-overhead tools for their databases.

# What is WhoDB?

## Introducing WhoDB: Your Next-Generation Database Management Tool

Managing databases can often feel like wrestling with complexity—between diverse database types, cumbersome UIs, and time-consuming queries. WhoDB changes the game by offering a lightweight, lightning-fast, and intuitive interface to seamlessly connect, manage, and query your data across SQL, NoSQL, and cloud databases—all from one elegant place.

Imagine querying your databases naturally, even using conversational AI, to get answers faster without wrestling with syntax. WhoDB empowers developers, database administrators, data scientists, and enterprises to unlock more value from their data with less overhead.

### Why WhoDB? Key Value Propositions

- **Conversational Database Interaction**: Utilize integrated AI models like ChatGPT, Ollama, and Anthropic to query and manage your data using natural language—no complex SQL required.
- **Broad Compatibility**: Connect effortlessly to popular databases including PostgreSQL, MySQL, SQLite3, MongoDB, Redis, MariaDB, ElasticSearch, and more.
- **High Performance & Lightweight**: Built with GoLang for blazing speed and a minimal footprint, enabling fast browsing even on resource-constrained environments.
- **Intuitive User Interface**: Clean, modern UI with schema visualization, inline editing, and a scratchpad interface for exploratory queries.
- **Flexible Editions**: Choose from Community Edition for open source benefits or Enterprise Edition for expanded database support and advanced feature sets.

### Designed For
WhoDB is crafted for anyone who works directly with databases — developers seeking speed and simplicity, DBAs wanting streamlined management, data scientists who need quick insight, and enterprise teams requiring scalable, low-overhead tooling.

---

## What Exactly is WhoDB?

At its core, WhoDB is a database management system designed to simplify how you interact with your data across numerous databases. It exposes an elegant, unified interface that abstracts away the technical clutter, so you focus on outcomes rather than setup or syntax.

### The Problem It Solves

Across projects and organizations, teams struggle juggling multiple database tools—each with different UIs, query languages, and performance bottlenecks. For instance, a developer might switch between a MongoDB UI and a relational database panel regularly, losing context and efficiency.

WhoDB solves this by unifying those interactions under a single, coherent platform that supports diverse database types and lets you talk to your data conversationally. This eliminates context switching, reduces setup time, and accelerates exploration and management.

### Unique Advantages

- **Conversational AI Integration**: Embedded AI lets you write queries and commands in plain English and receive instant data responses or suggestions.
- **Broad Plugin Architecture**: Supports a vast range of databases from SQL to NoSQL and cloud-hosted databases, ensuring your existing stack just works.
- **Lightweight and Fast**: The entire application is under 50MB, making it quick to install and operate without heavy system resource consumption.
- **Interactive Data Exploration**: Visual schema graphs, inline editing, and scratchpad queries give you multiple angles of working with your data.

### How WhoDB Works at a High Level

WhoDB runs as a server on your local machine or deployment environment, embedding a powerful GoLang backend engine with plugins for each supported database type. Its frontend interfaces through your browser, providing a single-pane UI.

Integrated AI models can be locally deployed (e.g., Ollama) or connected via API keys (e.g., OpenAI, Anthropic), enabling natural language interactions seamlessly coupled with traditional query editing.

---

## Core Features & Capabilities

- **Multi-Database Plugin Support**: Native plugins for PostgreSQL, MySQL, SQLite3, MongoDB, Redis, MariaDB, ElasticSearch, ClickHouse, and more, ensuring comprehensive compatibility.

- **Conversational AI Querying**: Use ChatGPT, Ollama, or Anthropic-powered models directly within the UI to generate queries, receive explanations, or perform complex data interactions in plain language.

- **Schema Visualization**: Interactive graphs reveal tables, collections, indexes, and relationships, making it easier to understand and navigate complex databases.

- **Scratchpad and Raw Query Executor**: A notebook-like environment for experimenting with queries, saving drafts, and mixing AI assistance with manual SQL or NoSQL commands.

- **Inline Editing and Data Preview**: Edit records or documents directly in tables or forms with immediate visual feedback.

- **Multi-Edition Support**:
  - Community Edition (CE): Open-source, supports core databases with essential features.
  - Enterprise Edition (EE): Adds support for specialized databases and advanced capabilities.

- **Fast and Responsive UI**: Virtualized tables and efficient data fetching keep the interface responsive even with large datasets.

### Example Use Case

Consider a developer managing a PostgreSQL and MongoDB instance. Instead of juggling separate tools, they open WhoDB, connect both databases via plugins, explore schemas graphically, and execute natural language queries like "Show me the top 10 customers by revenue last quarter". The AI translates this into SQL and MongoDB queries seamlessly, returning results instantly without manual query crafting.

---

## Why Should You Care?

By adopting WhoDB, you unlock:

- **Greater Productivity**: Spend less time switching tools and writing queries; more time analyzing and acting on data.
- **Lower Learning Curve**: Harness AI to ease query writing, which benefits both experts and newcomers.
- **Cost Savings**: Lightweight footprint means lower infrastructure costs and faster startup times.
- **Consistency Across Databases**: Uniform UI and feature set removes friction when working with heterogeneous data stores.
- **Enhanced Insights**: Integrated AI accelerates understanding of your data and generates complex queries without deep technical knowledge.

### Typical Scenarios Where WhoDB Excels

- Startups and small teams needing a powerful yet lightweight DB management tool.
- Enterprises managing diverse database environments requiring unified tooling.
- Data scientists exploring new datasets with conversational querying.
- Developers conducting quick schema reviews or debugging with inline inspections.

### Before and After WhoDB

| Without WhoDB                                  | With WhoDB                                                     |
|-----------------------------------------------|----------------------------------------------------------------|
| Multiple, disconnected database tools          | Single platform with plugin-based multi-database support      |
| Manual and error-prone SQL query writing       | Natural language AI-assisted querying lowers errors and load   |
| Slow, resource-heavy tools with complex installs | Fast, lightweight, easy to set up and run on minimal resources |
| Fragmented schema understanding through text   | Interactive visualization instantly clarifies relationships    |

---

## Getting Started Preview

Skip the guesswork—and dive right in. Getting started with WhoDB involves:

1. **Ensure basic requirements**: GoLang and Node.js installed for development, or Docker for quick production runs.
2. **Install and run WhoDB**: Use Docker commands or manual builds outlined in the [BUILD_AND_RUN.md](https://github.com/clidey/whodb/blob/main/BUILD_AND_RUN.md).
3. **Connect your databases**: Access the intuitive UI via your browser at `http://localhost:8080`, and add connections to your SQL or NoSQL databases.
4. **Explore AI features**: Configure conversational AI by setting API keys or installing local models like Ollama.

Ready to unlock the power of smart data management? Head next to [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database) for step-by-step instructions.

---

## Tips & Best Practices

- Start with Community Edition to familiarize yourself, then upgrade to Enterprise Edition as your needs grow.
- Use conversational AI for complex query generation and data exploration to save time and reduce errors.
- Regularly explore the schema graphs to maintain a clear mental model of your data structures.
- Leverage the scratchpad for iterative query development—especially useful during data analysis and report building.
- Keep your API keys secure and configured correctly to ensure smooth AI integration.

## Troubleshooting Common Issues

- If WhoDB does not start, verify that port `8080` is available or change it via environment variables.
- For AI chat features, confirm API keys or local AI models are correctly installed and accessible.
- Clear build artifacts if frontend resources fail to load, and re-run the build steps detailed in documentation.

---

## Additional Resources

- [Community vs. Enterprise Editions](https://whodb.com/docs/deployment/prod_deployment/edition_selection) - Understand which edition suits your needs.
- [Quick Start Guide](https://whodb.com/docs/getting-started/setup-requirements/prerequisites-system-requirements) - Step-by-step setup instructions.
- [AI Conversational Queries](https://whodb.com/docs/guides/ai-and-natural-language/conversational-queries-and-ai-models) - Deep dive into AI integrations.

---

WhoDB transforms database interaction into a seamless, insightful experience. Let it redefine how you work with data—effortlessly, intelligently, and efficiently.

---


# overview/intro-value-group/key-features-overview.mdx
## Key Features at a Glance

Explore the core features of WhoDB: AI-augmented data conversations, database schema visualization, inline data editing, scratchpad notebook interface, lightning-fast performance, and support for wide-ranging databases. Understand the difference between Community and Enterprise Editions and how features map to different needs and environments.

# Key Features at a Glance

Welcome to the snapshot of WhoDB's core capabilities — where intuitive design meets powerful data management. This page guides you through the standout features that set WhoDB apart in the database tools arena, helping you quickly understand its value for your workflows and environments.

---

## Discover What WhoDB Does Best

WhoDB combines the power of AI-augmented data conversations with hands-on data management and visualization tools, all tailored to support diverse databases and user needs. Whether you're exploring data relationships visually, editing on the fly, or running complex queries in a scratchpad-like notebook, WhoDB accelerates how you interact with your data.

### Core Benefits of WhoDB's Key Features

- **Natural-Language AI Chat:** Query and explore your data using conversational language, no deep SQL knowledge needed.
- **Schema Visualization:** Instantly map out the relationships within your databases for clear understanding and documentation.
- **Inline Data Editing:** Make quick updates directly in the interface — no jumping between tools.
- **Scratchpad Notebook:** Experiment with raw SQL in a dedicated, flexible environment designed for advanced queries and analysis.
- **Performance at Scale:** Experience lightning-fast responses and smooth handling of large datasets.
- **Broad Database Support:** Connect effortlessly with SQL, NoSQL, and cloud-based databases.
- **Edition Awareness:** Understand the difference between Community and Enterprise Editions to select features that best fit your scale and security needs.

### Who Should Pay Attention?

- Database administrators seeking a unified management console.
- Data analysts and engineers enhancing productivity with AI assistance.
- Teams requiring fast insights and schema documentation.
- Enterprises needing advanced database integrations and customizability.

---

## Breaking Down the Features

### 1. AI-Augmented Data Conversations

Transform your data interaction with WhoDB’s AI assistant, powered by natural language processing. Simply ask questions or request analyses in plain English, and receive immediate, actionable responses.

**Example:**
> "Show me total sales by region for the last quarter"

Without writing complex SQL code, you get the insights you need fast.

### 2. Database Schema Visualization

Visualize your entire database schema as an interactive graph, making it easy to comprehend table relationships, keys, and dependencies.

**Value:** Helps new team members get up to speed quickly and aids in impact analysis before changes.

### 3. Inline Data Editing

Directly update your data rows right in WhoDB's UI. Quickly fix errors or update records without switching apps or writing update statements.

**Best Practice Tip:** Always review live data changes carefully, and consider user permissions before editing production data.

### 4. Scratchpad Notebook Interface

Experiment freely with raw SQL queries, save snippets, and combine AI suggestions seamlessly in one space designed for power users and complex analytic workflows.

**Scenario:** Use the scratchpad to prototype new queries before deploying in your application or reporting tools.

### 5. Lightning-Fast Performance

WhoDB’s underlying architecture ensures rapid query execution and fluid UI responsiveness, even with large datasets and complex schemas.

### 6. Wide Database Compatibility

Support for multiple database types means you can manage heterogeneous environments effortlessly — from traditional relational databases to modern NoSQL and cloud-based stores.

---

## Community vs. Enterprise Editions: Feature Highlights

| Feature                      | Community Edition  | Enterprise Edition  |
|------------------------------|--------------------|---------------------|
| AI Chat & Natural Language   | ✅ Available       | ✅ Enhanced          |
| Schema Visualization         | ✅ Available       | ✅ Advanced          |
| Inline Data Editing          | ✅ Available       | ✅ Available        |
| Scratchpad Notebook          | ✅ Basic Support   | ✅ Full Support      |
| Performance Optimizations    | ✅ Standard       | ✅ Enhanced at Scale |
| Database Types Supported     | Core Set           | Extended Range       |
| Custom Themes & Branding     | ❌                | ✅                   |
| Multi-Profile Management     | ❌                | ✅                   |

Enterprise Edition introduces advanced features tailored for larger teams and complex environments, including comprehensive analytics views, extra database integrations, and enhanced UI customizations.

---

## How These Features Serve You

Imagine needing to quickly understand a legacy database schema while answering non-technical stakeholders’ questions. WhoDB lets you instantly visualize schema, chat with your data naturally, and adjust data inline — all in one place.

Before WhoDB, you might have toggled between spreadsheets, SQL clients, and documentation, spending hours on simple tasks. Now, streamline your workflow with WhoDB’s integrated capabilities, saving meaningful time and reducing errors.

**Return on Investment:**
- Accelerated decision making with conversational AI
- Reduced context switching with integrated tools
- Lower training overhead through intuitive UI and visualization

---

## Getting a Head Start

Ready to dive deeper? Your next steps involve connecting your databases and exploring AI query capabilities.

Follow our [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database) guide to link your data sources.

Learn to leverage AI for queries and raw SQL experimentation in the [Querying Your Data with AI Chat](/guides/ai-and-natural-language/conversational-queries-and-ai-models) and [Using the Scratchpad and Raw Query Executor](/guides/ai-and-natural-language/scratchpad-and-raw-sql) pages.

Ensure you understand your edition capabilities by reviewing the [Choosing Community vs. Enterprise Edition](/deployment/prod_deployment/edition_selection) page.

---

For more on WhoDB’s purpose and target users, see [What is WhoDB?](/overview/intro-value-group/what-is-whodb).

---


# overview/intro-value-group/intended-audience-and-use-cases.mdx
## Who Uses WhoDB?

WhoDB is designed for database administrators, backend and full-stack developers, data analysts, and enterprises that require quick, intuitive, and scalable database management. Common use cases include routine database exploration, schema inspection, rapid prototyping, and enhanced productivity via natural-language queries.

# Who Uses WhoDB?

## Overview
WhoDB is designed with a diverse set of users and organizations in mind, aiming to streamline the way people interact with databases. Whether you are a database administrator performing routine maintenance, a backend developer rapidly prototyping a new application, or a data analyst exploring complex datasets, WhoDB provides the tools and user experience to make database management faster, more intuitive, and highly scalable.

## Target User Roles

### Database Administrators (DBAs)
DBAs manage database infrastructure, ensure optimal performance, and maintain security and backups. WhoDB empowers DBAs with:
- **Quick schema visualization:** Understand database structures at a glance.
- **Efficient data exploration:** Perform routine checks and spot anomalies without writing extensive queries.
- **Unified interface:** Manage various types of databases (SQL, NoSQL, cloud-hosted) from a single application.

### Backend Developers
Backend developers integrate databases into applications and require reliable tools for schema inspection, query debugging, and rapid prototyping. WhoDB helps developers by:
- **Providing type-safe GraphQL API interactions** (through unified frontend GraphQL integration).
- **Simplifying data queries:** Use conversational AI to generate SQL without deep expertise.
- **Supporting incremental development:** Quickly test database changes or feature ideas.

### Full-Stack Developers
Full-stack engineers benefit from WhoDB’s comprehensive approach, which blends frontend user experience with backend data interaction:
- **Seamless tooling:** Work across frontend and backend with a consistent interface.
- **Theming and extensibility:** Adapt UI appearance and feature set to specific projects.
- **Enterprise modes:** Utilize EE features when applicable without disrupting CE workflows.

### Data Analysts
Data professionals who analyze datasets to generate reports and insights gain from:
- **Natural-language query support:** Quickly extract complex data patterns with AI-assisted queries.
- **Visual schema tools:** Better understand relationships and dependencies.
- **Scratchpad and raw SQL interface:** Flexibility for advanced data manipulations.

### Enterprises
Organizations with more demanding database environments appreciate:
- **Enterprise Edition enhancements:** Advanced data visualization, multiple profiles, AI chat, and customizable themes augment productivity.
- **Security and feature flags:** Controlled rollout of features and scalable deployment.
- **Integration capabilities:** WhoDB fits into existing ecosystems with Docker-based deployment, environment variable configurability, and multi-architecture builds.

## Common Use Cases

### 1. Routine Database Exploration and Inspection
Users frequently need to inspect database schemas, review table content, or understand data relationships. WhoDB's intuitive UI and schema visualizations reduce time spent navigating complex databases.

### 2. Rapid Query Prototyping and Testing
Developers frequently craft and test queries. The integrated conversational AI accelerates SQL generation, saving hours otherwise spent writing and troubleshooting.

### 3. Data Analysis with Conversational AI
Analysts gain access to natural language interfaces that translate business questions into SQL. This bridges the gap between domain experts and database querying.

### 4. Multi-Database Management
Enterprises often utilize heterogeneous data stores (PostgreSQL, MySQL, MongoDB, etc.). WhoDB provides a unified platform minimizing context switching and training overhead.

### 5. UI Customization and Theming
Organizations with strict branding or UX requirements adopt WhoDB’s theming capabilities, ensuring consistent look-and-feel aligned with corporate standards.

## Before and After WhoDB Adoption

| Scenario              | Before WhoDB                               | After WhoDB                              |
|-----------------------|-------------------------------------------|-----------------------------------------|
| Schema Understanding  | Manual inspection with CLI or various tools | Graphical, easy-to-navigate schema maps |
| Query Development     | Writing SQL manually                        | Conversational AI-assisted query builder |
| Data Exploration      | Multiple tools per database                 | One platform for all databases           |
| Collaboration         | Sharing SQL scripts via email or chat      | Exportable queries and shared dashboards |
| Setup Effort          | Managing disparate tools and DevOps processes | Streamlined builds and deployment with clear CE and EE separation |

## Why Choose WhoDB?
- **Saves Time:** Simplify complex database tasks with AI and UI-driven workflows.
- **Increases Accuracy:** Minimize SQL errors with AI suggestions and type-safe code generation.
- **Boosts Productivity:** Developers and analysts focus on insights, not database mechanics.
- **Scales with Your Needs:** From solo developers to large enterprises, WhoDB adapts.

## Next Steps
- Explore our [Getting Started guides](https://whodb.com/docs/getting-started/setup-requirements/prerequisites-system-requirements).
- Learn how to connect your databases: [Connecting to Your Database](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database).
- Dive into AI and natural language querying features: [Querying Your Data with AI Chat](https://whodb.com/docs/guides/ai-and-natural-language/conversational-queries-and-ai-models).

---

For setup and development details, refer to the [Build and Run Guide](https://whodb.com/docs/BUILD_AND_RUN.md).

To understand how Community and Enterprise Editions cater differently to users, see the [Key Features at a Glance](https://whodb.com/docs/overview/intro-value-group/key-features-overview).

---

### Callouts

If you are new to WhoDB or database management tools, focus initially on the Getting Started section to set up your environment and connect your data sources.

Enterprise users should evaluate advanced features available in the EE edition, including extended theming and AI capabilities, which enhance multi-profile and complex organizational workflows.

---


# overview/architecture-concepts-group/system-architecture-overview.mdx
## System Architecture Overview

Explore a visual breakdown of WhoDB's architecture, highlighting the separation of frontend and backend, plugin-based database support, AI integration points, and data flow. Understand how user requests travel from the UI to the database and how AI conversations are processed. Includes a Mermaid diagram for clarity.

# System Architecture Overview

## Unlocking the Power of WhoDB’s Architecture

Welcome to the foundational layer of WhoDB. This page offers you a clear, visual understanding of how the system is designed to seamlessly connect your data, empower interactive exploration, and integrate intelligent AI capabilities. Whether you're a database administrator, data analyst, or developer, grasping the architecture helps you leverage WhoDB’s full potential.

---

## What You Will Learn Here

- How WhoDB's frontend and backend components collaborate.
- The plugin-based approach to supporting multiple database types.
- Where AI integrations fit within the system.
- The flow of data and requests from user interface to database and back.

---

## System Architecture at a Glance

At its core, WhoDB separates concerns clearly between **Frontend**, **Backend**, and **Database plugins**, enhanced by AI processing components. This modular design fuels flexibility, extensibility, and high performance.

### Key Components
- **Frontend:** User interface powered by a modern web framework supporting hot-reloading and vibrant UX.
- **Backend:** Written in Go, handling business logic, API serving, and plugin orchestration.
- **Database Plugins:** Dynamic modules that allow WhoDB to support a broad spectrum of SQL, NoSQL, and cloud databases in a unified way.
- **AI Modules:** Interfaces that enable conversational AI queries and chat, integrating external AI models seamlessly.

```
flowchart TD
  %% User Interaction
  UI["Frontend UI\n(React, Vite)"] -->|HTTP/GraphQL Requests| Backend["Backend Server\n(Go + Chi Router)"]

  %% Backend Plugin Architecture
  Backend -->|Plugin Calls| DBPlugins["Database Plugin Engine"]
  subgraph "Database Plugins"
    SQLPlugin["SQL Database Plugins"]
    NoSQLPlugin["NoSQL Database Plugins"]
    CloudPlugin["Cloud Database Plugins"]
  end
  DBPlugins --> SQLPlugin
  DBPlugins --> NoSQLPlugin
  DBPlugins --> CloudPlugin

  %% Backend to Actual Databases
  SQLPlugin -->|SQL Queries| SQLDBs["SQL Databases\n(Postgres, MySQL, etc.)"]
  NoSQLPlugin -->|NoSQL Queries| NoSQLDBs["NoSQL Databases\n(MongoDB, Redis, etc.)"]
  CloudPlugin -->|Cloud APIs| CloudDBs["Cloud Databases/Aggregators"]

  %% AI Integration
  UI -->|AI Chat Requests| AIModule["Conversational AI Module"]
  Backend --> AIModule
  AIModule -->|AI Model API Calls| ExternalAI["External AI Models\n(OpenAI, Anthropic, Ollama)"]

  %% Data and Response
  SQLDBs -->|Query Results| SQLPlugin
  NoSQLDBs -->|Query Results| NoSQLPlugin
  CloudDBs -->|Query Results| CloudPlugin
  DBPlugins -->|Processed Results| Backend
  AIModule -->|Chat Responses| UI
  Backend -->|API Responses| UI

  %% Legend
  classDef component fill:#f9f9f9,stroke:#333,stroke-width:1px;
  class UI,Backend,DBPlugins,AIModule,ExternalAI,SQLPlugin,NoSQLPlugin,CloudPlugin,SQLDBs,NoSQLDBs,CloudDBs component;
```

---

## How It Works: User Request Flow

1. **User Interaction:** You start by interacting with the frontend — whether querying data, editing schema, or chatting with the AI assistant.

2. **API Handling:** The frontend sends structured GraphQL or REST requests to the backend server running on Go (via HTTP). The backend routes requests through a powerful router setup with robust middleware for security, throttling, and logging.

3. **Plugin Invocation:** The backend delegates database operations to the appropriate plugin based on the connected database type. This plugin abstracts the communication details so you experience a consistent interface, regardless of whether your data is in PostgreSQL, MongoDB, or cloud storage.

4. **Data Access:** Plugins translate queries and commands into native database calls. Responses are collected and normalized.

5. **AI Processing:** For conversational AI queries, the backend coordinates with AI modules, which send requests to external models, process responses, and integrate insights back into the interface.

6. **Response Delivery:** Processed results or chat messages flow back through the backend to the frontend, where you see live updates, data visualizations, or chat replies instantly.

---

## Benefits of This Architecture

- **Separation of Concerns:** Frontend and backend evolve independently but communicate seamlessly.
- **Extensibility:** Easily add support for new databases via plugins — no core changes needed.
- **AI Integration:** AI features are modular and encapsulated, enabling flexible upgrades.
- **Robustness:** Middleware and structured routing secure and throttle requests effectively.
- **Developer-Friendly:** Hot-reload frontend and clear backend logs support productive development workflows.

---

## Real-World Scenario

Imagine you want to analyze user behavior from a PostgreSQL database while chatting with an AI assistant to get insights.

- You launch WhoDB's UI and connect your PostgreSQL database.
- Through the UI, you run an SQL query that triggers a backend request.
- The backend passes this request to the SQL plugin, which executes the query and returns results.
- Simultaneously, you ask the AI assistant questions about trends.
- The backend routes the chat input to AI modules that communicate with OpenAI’s API.
- Responses from both the database and AI are displayed promptly in your UI.

This seamless interaction across diverse systems empowers faster, smarter data-driven decisions.

---

## Getting Deeper: Related Documentation

- [Core Concepts and Terminology](/overview/architecture-concepts-group/core-concepts-and-terminology) — Understand the fundamental building blocks.
- [Plugin Engine & Database Integration](/concepts/architecture-overview/plugin-engine) — Learn how plugins work in detail.
- [Conversational AI Integration](/concepts/integration-patterns/ai-integration) — Explore AI workflows and integrations.
- [Request Lifecycle & Data Flow](/concepts/architecture-overview/data-flow) — Dive into the end-to-end data processing.

---

## Practical Tips

- When developing or debugging, leverage the backend logs and frontend hot-reload features for rapid feedback.
- Customize plugin behavior by extending or configuring database drivers if you operate complex environments.
- Monitor AI API usage and tokens carefully to manage costs and performance.

---

## Troubleshooting Common Issues

- **Frontend not loading:** Verify that the backend embeds the built frontend under `/build` and that static file serving is enabled.
- **API requests failing:** Confirm the backend server is running and accessible at the expected port.
- **Plugin errors connecting to databases:** Check plugin configurations and credentials.
- **AI chat responses delayed or failing:** Ensure API keys are set correctly and external AI services are reachable.

---

## Next Steps: Explore How to Connect Your Database

Move forward by exploring how to [connect your database](/guides/essential-workflows/connecting-to-your-database) to get up and running, or dive into how to [query your data with AI chat](/guides/ai-and-natural-language/conversational-queries-and-ai-models) to unlock conversational insights.

---

## Summary

This page lays out the modular, plugin-driven architecture of WhoDB, emphasizing the clear division between frontend, backend, plugins, and AI components. It helps you visualize how data flows from UI to databases and back, enabling rich interaction and extensibility.

---

© 2025 Clidey, Inc. All rights reserved.

---

For detailed build, run, and deployment instructions, refer to the [Build and Run Guide](../../BUILD_AND_RUN.md).

---


# overview/architecture-concepts-group/core-concepts-and-terminology.mdx
## Core Concepts and Terminology

Defines and explains foundational terms used in WhoDB, including Storage Units, Plugins, AI Models, Scratchpad, Community/Enterprise Editions, and Database Profiles. This conceptual map is critical for understanding documentation and product workflows.

# Core Concepts and Terminology

Understanding WhoDB’s architecture and workflows starts with a clear grasp of its foundational terms and components. This page defines and explains critical concepts such as Storage Units, Plugins, AI Models, Scratchpad, Editions, and Database Profiles — essential building blocks for effective use and interpretation of WhoDB’s capabilities.

---

## Storage Units

Storage Units are the fundamental logical containers within WhoDB that represent your databases. They abstract the underlying database connections, allowing WhoDB to manage multiple and diverse database types uniformly.

- **What They Are:** A Storage Unit is essentially a connected database instance or schema that you can explore and query.
- **Why They Matter:** They enable users to view, manage, and query heterogeneous databases without needing to switch tools or configurations.

**Example:** A PostgreSQL cluster and a SQLite file can each be a separate Storage Unit, accessible via WhoDB’s interface simultaneously.

## Plugins

Plugins are modular components that provide WhoDB the ability to interact with different database technologies.

- **Definition:** Each Plugin encapsulates the logic needed to connect, query, and manage a particular database type.
- **Key Role:** They power WhoDB’s extensive database support by translating generic commands into database-specific operations.
- **Core Plugins Include:**
  - PostgreSQL
  - MySQL / MariaDB
  - SQLite3
  - MongoDB
  - Redis
  - Elasticsearch
  - ClickHouse

- **Enterprise Edition:** May include additional or enhanced plugins for advanced features.

## AI Models

WhoDB integrates conversational AI to augment database exploration and querying.

- **AI Models Represent:** The language and reasoning engines that parse natural language inputs into executable queries or provide intelligent insights.
- **Examples of Supported Models:**
  - Ollama (local/private LLM)
  - ChatGPT (OpenAI-powered conversational AI)
  - Anthropic
  - OpenAI-Compatible models

- **Purpose:** Allow users to interact naturally with their data using plain English instead of complex SQL or commands.

## Scratchpad

The Scratchpad is an interactive workspace within WhoDB for composing, experimenting with, and executing queries or notes.

- **What It Is:** A flexible interface component where users write raw SQL, test AI-generated queries, or keep query snippets.
- **How It Helps:** It speeds up analytical workflows by enabling quick iteration and combination of manual and AI-assisted querying.

## Community Edition (CE) vs Enterprise Edition (EE)

WhoDB is available in two primary editions, each targeting different user needs.

| Feature                | Community Edition (CE)                      | Enterprise Edition (EE)                        |
|------------------------|--------------------------------------------|-----------------------------------------------|
| Plugins                | Full open-source plugin set                 | Includes additional enterprise-grade plugins  |
| AI Integrations        | Supported but without advanced enterprise features | Enhanced AI, security, and scalability features |
| License                | Apache 2.0 Open Source                      | Commercial license with premium support       |
| Intended Users         | Individuals, small teams, open-source advocates | Enterprises needing advanced control and support |

**Note:** EE plugins are automatically initialized during engine setup if building with the `ee` tag.

## Database Profiles

Database Profiles are saved authentication and connection configurations that WhoDB uses to simplify access.

- **What They Include:** Hostname, username, database name, port, passwords, and advanced custom settings.
- **Profiles vs Ad-hoc Connections:** Profiles enable users to quickly switch between frequently used databases without re-entering credentials.
- **IsProfile Flag:** Indicates if a set of credentials is a predefined profile or a one-time connection.

**Profiles Management:**
Profiles can be loaded from environment variables or configuration files and appear in login flows for easy selection.

---

## How These Concepts Interrelate

1. **Plugins provide the mechanism to connect to Storage Units** representing actual databases.
2. **Database Profiles configure those connections** with the necessary credentials.
3. **Users interact with data stored in Storage Units** via WhoDB’s UI, enhanced by AI Models for conversational query capabilities.
4. **The Scratchpad serves as the personal workspace** combining manual queries and AI-guided explorations.
5. **Edition determines the available features and plugins,** influencing what databases and AI capabilities users can access.

---

## Practical Tips

- When connecting to new databases, consider creating and saving a Database Profile for efficient management.
- Use the Scratchpad to test AI-generated queries before running them on live datasets.
- Familiarize yourself with which Plugins correspond to your database types to understand possible feature limitations or advantages.
- Evaluate whether the Community or Enterprise Edition best suits your needs, especially if you require enhanced plugins or support.

---

## Troubleshooting Common Conceptual Issues

Check that the correct Plugin supports your database type and that the corresponding Storage Unit is properly configured with valid Credentials or Profiles.

AI Models interpret your natural language inputs and translate them into SQL or database commands, enhancing your query efficiency and reducing the need for deep SQL knowledge.

A Scratchpad query is a temporary or working query you can execute or modify anytime, whereas a Profile saves connection details for repeated database access.

---

For a deeper understanding of the system architecture, data flow, and plugin integrations, please explore the [System Architecture Overview](/overview/architecture-concepts-group/system-architecture-overview) and [Plugin Engine & Database Integration](/concepts/architecture-overview/plugin-engine) documentation. To get hands-on quickly, use the [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database) guide.

---

*Ready to explore more?* Check out the next conceptual deep dive on [Security Model & Authentication](/concepts/security-scalability/security-auth) to understand how credentials and authorization protect your data in WhoDB.

---

---


# overview/architecture-concepts-group/integration-overview.mdx
## Integrations and Extensibility

Overview of how WhoDB connects with databases, LLM providers (ChatGPT, Ollama, Anthropic), and external systems. Provides a summary of supported databases, authentication mechanisms, and plugin extensibility in both CE and EE editions. Includes pointers for future integrations.

# Integrations and Extensibility

Welcome to the Integrations and Extensibility overview for WhoDB — your gateway to connecting your databases, AI providers, and external systems seamlessly. This page demystifies how WhoDB interfaces with various components behind the scenes, empowering you to extend its functionality or integrate new data sources confidently.

---

## Unlocking Unified Connections

WhoDB isn’t just another database tool. It acts as a centralized hub, linking your SQL, NoSQL, and cloud data stores with powerful AI models and extensible plugins. This page guides you through the integration landscape designed for both Community Edition (CE) and Enterprise Edition (EE) users, outlining key mechanisms, supported platforms, and future extensibility paths.

### What You Will Discover Here
- How WhoDB connects with industry-standard databases like PostgreSQL, MySQL, and MongoDB.
- The identity and authentication methods WhoDB supports for secure database access.
- Integration with leading large language model (LLM) providers such as ChatGPT, Ollama, and Anthropic.
- The plugin architecture that enables extension of the core platform, especially in EE.
- How dynamic GraphQL imports manage CE and EE codebases for integration consistency.

---

## Database Connectivity: Broad, Secure, Seamless

### Supported Databases
WhoDB offers first-class support for a wide array of database types, including but not limited to:
- Relational Databases: PostgreSQL, MySQL, MariaDB, SQLite3, ClickHouse
- NoSQL Databases: MongoDB, Redis, ElasticSearch

This ensures that no matter your technology stack, WhoDB can be your unified interface to explore, query, and manage data.

### Authentication Mechanisms
WhoDB supports flexible authentication to meet enterprise security requirements:
- Login profiles with saved credentials allow quick switching between environments.
- Environment-defined credentials enable CI/CD and cloud deployments without exposing secrets.
- Advanced settings allow custom authentication parameters.

### Plugin Engine Extensibility
Both CE and EE editions use a plugin system that wraps database drivers to provide consistent functionality across databases. In EE, the plugin engine extends to enable:
- Enterprise-grade database support
- Advanced connection options
- Custom schema handling

This modular architecture future-proofs your WhoDB deployment for integrating new database systems.

---

## Conversational AI and LLM Integration

WhoDB integrates deeply with conversational AI models to enable natural language querying and data exploration.

### Supported AI Providers and Models
- **ChatGPT**: OpenAI’s widely used large language model.
- **Ollama**: Locally hosted model support, allowing on-prem AI.
- **Anthropic**: Cutting-edge assistant focused on safety and reliability.

With the ability to add external AI models dynamically through tokens and provider selection, you can tailor the AI assistance to your organizational needs.

### Token and Model Management
Users authenticate and select models via WhoDB’s interface where:
- Providers are discovered dynamically via a GraphQL query.
- Model types and tokens are configured securely.
- Model lists are refreshed on-demand to reflect availability.

### AI Chat in Practice
The AI chat interface lets you:
- Ask questions in natural language.
- Receive SQL queries and results inline.
- Visualize data with charts when supported (EE specific).

This integration generates real-time insights, making data access intuitive and conversational.

---

## Plugin Extensibility and Enterprise Features

### Dynamic Component Loading
To support advanced features and EE-only components, WhoDB employs dynamic imports:
- EE components like advanced charts and analytics load only when enabled.
- This keeps the CE lightweight while giving EE customers enhanced visualizations and analytics.

### Extensible Themes and UI Components
The system’s design supports new themes and UI components that can be plugged in:
- EE themes can be loaded at runtime, offering brand customization.
- Components like enhanced data tables are extensible through well-defined extension points.

### Future Integration Paths
WhoDB is architected to integrate future databases and AI providers seamlessly through:
- The GraphQL schema which abstracts backend features.
- The plugin engine which encapsulates database-specific behavior.
- Feature flags controlling availability without code changes.

---

## How WhoDB Manages Integration Consistency: GraphQL Setup

### Unified GraphQL Types
WhoDB’s frontend uses GraphQL code generation to tightly couple with backend APIs:
- CE and EE editions have separate GraphQL schemas, each generating their own TypeScript types.
- The `@graphql` import alias dynamically resolves to CE or EE types based on build environment.

### Build and Development Workflow
- Developers generate GraphQL types from the running backend.
- The Vite config dynamically aliases imports to the correct generated code.
- This ensures that both editions stay consistent with their respective backend capabilities.

### Benefits to You
- Avoids conflicts between CE and EE types.
- Maintains API stability and type safety.
- Enables advanced features in EE without impacting CE builds.

---

## Integration Workflow Example: Adding an External AI Model

1. Navigate to the AI provider dropdown in the Chat interface.
2. Select 'Add External Model' to open the token input modal.
3. Choose your AI model type (e.g., Ollama, Anthropic).
4. Enter the API token securely.
5. Submit to load and register the external AI model dynamically.
6. Begin querying with the new AI provider seamlessly.

This flow empowers users to flexibly extend WhoDB’s AI capabilities without redeployment.

---

## Best Practices and Tips

- **Secure Tokens:** Always manage your AI or database tokens through environment variables or secure vaults.
- **Refresh Models:** If AI models don't appear, try refreshing the provider list.
- **Use Plugins:** Leverage plugins to add support for custom databases or enterprise features.
- **Monitor Feature Flags:** EE feature availability is controlled via flags; consult your admin if something seems missing.

---

## Troubleshooting Common Integration Issues

Ensure your token is valid and properly set. Verify network connectivity and check for API limits or permissions from the provider.

Check that your credentials are correct. Confirm that environment-defined profiles are properly configured if used. Review network firewall or access control settings.

Run `npm run generate` or `pnpm generate` after backend schema changes. Confirm your local backend is running and accessible on port 8080.

---

## Next Steps

- Explore detailed guides on [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database).
- Learn about [Conversational AI Integration](/concepts/integration-patterns/ai-integration) to deepen your AI usage.
- For Enterprise customers, investigate [Plugin Engine & Database Integration](/concepts/architecture-overview/plugin-engine) for custom extensibility.

---

By understanding WhoDB’s integrations and extensibility mechanism, you can fully harness its power as a unified platform for your diverse data ecosystems and the latest conversational AI capabilities.

---

## Diagram: Integration Overview Flow

```
flowchart TD
  %% User interaction
  User["User Interface"] -->|Select Database| Connection["Database Connection Layer"]
  Connection --> Database[("Supported Databases")]
  Database -->|Query results| Connection
  Connection -->|Return Data| User

  %% AI Provider Interaction
  User -->|Enter Query| AIChat["AI Chat Module"]
  AIChat -->|Fetch Models, Tokens| AIProvider["AI Providers (ChatGPT, Ollama, Anthropic)"]
  AIProvider -->|Return Models| AIChat
  AIChat -->|Send Query & Context| AIModel["AI Models"]
  AIModel -->|Respond| AIChat
  AIChat -->|Result| User

  %% Plugin Engine
  Connection --> PluginEngine["Plugin Engine"]
  PluginEngine --> Database

  %% Dynamic Component Loading
  User -->|Load EE Components| EEComponents["Enterprise Edition Components"]
  EEComponents --> User

  %% GraphQL Layer
  User -->|GraphQL Queries| GraphQLFrontend["Frontend GraphQL Layer"]
  GraphQLFrontend --> GraphQLBackend["Backend GraphQL API"]
  GraphQLBackend --> Database
  GraphQLBackend --> AIProvider

  %% Legend
  classDef external fill:#f9f,stroke:#333,stroke-width:1px;
  class Database,AIProvider external;
```

---

---


# getting-started/setup-requirements/prerequisites-system-requirements.mdx
## Prerequisites & System Requirements

Details the supported platforms, minimum hardware/software requirements, and necessary external dependencies (such as Go, PNPM, and Docker). Sets expectations for both local developers and production deployments, including special notes for enabling natural language integrations with Ollama, Anthropic, and OpenAI.

# Prerequisites & System Requirements

This page outlines the essential platforms, hardware, software dependencies, and environment settings required to prepare your system for installing and running WhoDB. Whether you're a local developer building from source or deploying WhoDB in production, these guidelines ensure a smooth setup and optimal performance.

---

## 1. Supported Platforms

WhoDB is designed to be platform-agnostic with official support for the following operating systems:

- **Linux** (x86_64 and ARM64 architectures)
- **macOS** (Intel and Apple Silicon processors)
- **Windows 10/11** (via WSL 2 recommended for full compatibility)

> For the best experience, especially in production, Linux servers are recommended.

## 2. Minimum Hardware Requirements

| Component     | Minimum Specification           | Recommended Specification     |
|---------------|--------------------------------|-------------------------------|
| CPU           | 2 cores                        | 4+ cores                      |
| Memory (RAM)  | 4 GB                          | 8 GB or more                  |
| Disk Space    | 2 GB free                    | 10 GB+ (to accommodate logs, data caching, and frontend assets) |
| Network       | Stable internet connection (for AI integrations and dependency fetching) | Gigabit connectivity for multi-user setups |

> Note: Hardware requirements will increase depending on the size of your databases and usage patterns.

## 3. Software Dependencies

Before installing or building WhoDB, ensure the following software is installed and accessible from your command line:

- **Go (golang)**
  - Version: 1.24 or higher
  - Purpose: Compiling the Go backend and Enterprise Edition modules
  - Official download: [https://golang.org/dl/](https://golang.org/dl/)

- **Node.js**
  - Version: 18.x LTS or newer
  - Purpose: Building the React frontend
  - Official download: [https://nodejs.org/](https://nodejs.org/)

- **pnpm (Performant package manager)**
  - Version: Latest stable
  - Purpose: Efficiently managing frontend dependencies
  - Install via npm: `npm install -g pnpm`

- **Docker (optional but recommended for production)**
  - Version: 20.10 or higher
  - Purpose: Containerized deployment and environment consistency
  - Official download: [https://www.docker.com/get-started/](https://www.docker.com/get-started/)

> 
> Without these dependencies installed, building or running WhoDB will fail.
> Use the installation instructions in the [Installation Methods](../setup-requirements/installation-methods) guide for detailed steps.
> 

## 4. Runtime Environment Requirements

- **Ports**
  - Ensure the following ports are open and not blocked by firewalls:
    - Default Web UI port: `8080`
    - API and backend communication as configured

- **Permissions**
  - User running WhoDB should have read/write access to the installation directories and config files.
  - For Enterprise Edition deployments, verify additional permissions for plugin execution.

- **Environment Variables**
  - Basic environment variables such as `PATH` must include Go, Node.js, and pnpm binaries.
  - See [Environment Variables & Third-Party Integrations](../../deployment/prod_deployment/env_config) for production tuning.

## 5. Special Notes for Enterprise Edition (EE)

The Enterprise Edition includes extended features and requires additional setup:

- Access to Enterprise Edition modules (`ee/` directory) is mandatory before building or running EE.
- EE validation script (`scripts/validate-ee.sh`) must succeed to confirm module presence and correct tooling.
- Build tooling (Go, pnpm, Node.js) versions must align with those needed for CE.

Ensure you have appropriate access permissions to obtain the EE modules. See the Enterprise Edition README for more details: https://github.com/clidey/whodb/blob/main/ee/README.md

## 6. Natural Language Integration Dependencies

WhoDB supports conversational AI capabilities that rely on external LLM providers.

- **Supported AI providers:**
  - Ollama
  - Anthropic
  - OpenAI

- **Connectivity**
  - Outbound HTTPS access on ports 443 for API calls to AI providers

- **API credentials**
  - Required for Anthropic and OpenAI; configure these securely in your environment.

- **Container and Deployment notes**
  - When deploying in containers, ensure environment variables for API keys are set and network outbound rules permit AI API calls.

- **Version notes**
  - Keep your WhoDB version and AI integration libraries up-to-date for compatibility.

## 7. Summary Checklist Before Installation

 - Confirm your OS matches supported platforms
 - Verify hardware meets minimum specs
 - Install Go 1.24+, Node.js 18+, and pnpm
 - (Optional) Install Docker for containerized setup
 - Open port 8080 and other relevant ports
 - Ensure EE modules are available for Enterprise Edition
 - Prepare API keys and network access for AI integrations

---

For detailed installation and build instructions, refer to the [Installation Methods](../setup-requirements/installation-methods) page. Once prerequisites are fulfilled, you can proceed to configure and launch your first WhoDB instance.

---

## Troubleshooting Common Prerequisite Issues

If the `go` command is not found or the version is below 1.24:

- Verify Go is installed with `go version`
- Download and install the latest version from https://golang.org/dl/
- Ensure Go’s bin directory is added to your PATH environment variable

To check if pnpm is available, run `pnpm --version`.

If not installed:

```
npm install -g pnpm
```

Confirm installation by running `pnpm --version`.

WhoDB requires Node.js 18 or later.

- Check your version: `node --version`
- Update Node.js from https://nodejs.org/
- Use version managers like nvm for easier upgrades if needed

During EE build or validation, you may see errors about missing `ee/` directory.

- Confirm you have access to the Enterprise Edition source
- Place the `ee` directory under the project root
- Run `$ ./scripts/validate-ee.sh` to verify
- For missing or empty directories, re-check your EE source

If AI features are not working:

- Verify firewall allows outbound HTTPS (port 443)
- Check API keys are correctly set
- Confirm your container or cloud environment allows external API calls

---

## Additional Resources

- [Installation Methods](../setup-requirements/installation-methods): Step-by-step instructions to install WhoDB
- [Deployment with Docker](../../deployment/prod_deployment/docker_quickstart): Guides for production environments
- [Security and Authentication Essentials](../../guides/best-practices-and-optimization/security-and-authentication): Best practices for securing your instance
- [Enterprise Edition README](https://github.com/clidey/whodb/blob/main/ee/README.md): Detailed EE setup and licensing
- [System Architecture Overview](../../overview/architecture-concepts-group/system-architecture-overview): Understand the software components and their interaction

---

---


# getting-started/setup-requirements/installation-methods.mdx
## Installation Methods

Step-by-step installation instructions tailored for different environments. Walks users through fast Docker/Docker Compose setup as well as manual installation and build from source for both frontend and backend components. Highlights key environment variables and edition selection.

# Installation Methods

This guide provides detailed, step-by-step instructions to install and run WhoDB using different setups tailored to your environment. Whether you prefer a fast Docker-based deployment or a manual installation and build from source for the frontend and backend components, this page will guide you through each method. You will also learn about critical environment variables and how to select the appropriate edition.

---

## 1. Preparation and Requirements

Before starting installation, ensure your system meets the following:

- **Supported Operating Systems:** Linux, macOS, and Windows (with WSL 2 recommended for Windows).
- **Essential Software:** 
  - [Docker](https://docs.docker.com/get-docker/) (if using Docker setup)
  - [Docker Compose](https://docs.docker.com/compose/install/) (for multi-container setups)
  - [Go](https://golang.org/dl/) (version 1.19 or later) for backend manual builds
  - [Node.js](https://nodejs.org/en/download/) (version 18+), [pnpm](https://pnpm.io/installation) for frontend builds
- **System Resources:** Minimum 2 CPU cores, 4GB RAM, 2GB free disk space

If you plan to run WhoDB in production, consider reviewing "Choosing Community vs. Enterprise Edition" to pick the edition that matches your needs.

---

## 2. Quick Setup Using Docker and Docker Compose

Docker setup provides the fastest path to get WhoDB running locally or in a containerized environment. This method launches both frontend and backend components with recommended defaults.

### Step 1: Clone the Repository

```
git clone https://github.com/clidey/whodb.git
cd whodb
```

### Step 2: Choose Your Edition

By default, the Docker Compose will run the Community Edition.
To use Enterprise Edition, set the environment variable `WHODB_EDITION=enterprise` in the compose override or `.env` file.

### Step 3: Start WhoDB with Docker Compose

```
docker-compose up -d
```

You should see both backend and frontend containers starting.

### Step 4: Verify Running Containers

```
docker ps
```

Look for containers named `whodb-backend` and `whodb-frontend` in the list.

### Step 5: Access the Application

Open your browser at [http://localhost:3000](http://localhost:3000) to access the WhoDB web UI.

If the UI does not load, check container logs:

```
docker-compose logs whodb-backend
```

Look for errors related to port conflicts or missing environment variables.

---

## 3. Manual Installation and Build From Source

For developers or those wanting full control, building from source allows customization and debugging.

### Backend Installation

#### Step 1: Install Go

Ensure Go 1.19+ is installed and your `GOPATH` and `PATH` are correctly set.

Verify by:

```
go version
```

#### Step 2: Build Backend

From the root directory:

```
cd backend
go build -o whodb-server ./cmd/server
```

This generates a binary `whodb-server` in the current folder.

#### Step 3: Set Environment Variables

Create a `.env` file or export variables directly.

Key environment variables:

- `WHODB_EDITION`: `community` or `enterprise` (default: `community`)
- `WHODB_BACKEND_PORT`: Port for backend server (default: `8080`)
- `WHODB_DATABASE_URL`: Your database connection string

Example `.env` file:

```
WHODB_EDITION=community
WHODB_BACKEND_PORT=8080
WHODB_DATABASE_URL=postgres://user:pass@localhost:5432/whodb
```

#### Step 4: Run Backend Server

Start the backend:

```
./whodb-server
```

The service listens on the configured port.

---

### Frontend Installation

#### Step 1: Install Node.js and pnpm

Verify Node.js 18+ and install pnpm globally:

```
npm install -g pnpm
```

#### Step 2: Install Frontend Dependencies

Navigate to the frontend source directory:

```
cd frontend
pnpm install
```

#### Step 3: Configure Frontend

Edit or create a `.env` file to set API endpoint for backend, e.g.: 

```
VITE_API_BASE_URL=http://localhost:8080/api
```

#### Step 4: Start Frontend Development Server

Run:

```
pnpm dev
```

This will launch the frontend on [http://localhost:3000](http://localhost:3000).

Use this mode for active development with hot reload.

---

## 4. Setting Up Your Database

WhoDB supports various databases including Postgres, MySQL, MariaDB, SQLite3, MongoDB, and ClickHouse.

### Step 1: Prepare Your Database

Create and configure your database instance. Use the provided sample data scripts (e.g., under `dev/sample-data`) to initialize schemas and sample records.
- For SQL databases, run the corresponding SQL script.
- For MongoDB, run the provided `.js` initialization script.

### Step 2: Configure Connection

Set `WHODB_DATABASE_URL` with the correct connection string format matching your DB:

- Postgres: `postgres://user:pass@host:port/dbname`
- MySQL/MariaDB: `mysql://user:pass@host:port/dbname`
- SQLite3: `file:path/to/database.sqlite` (local file path)
- MongoDB: `mongodb://user:pass@host:port/dbname`
- ClickHouse: `clickhouse://user:pass@host:port/dbname`

---

## 5. Key Configuration Environment Variables

| Variable           | Description                                    | Default         |
|--------------------|------------------------------------------------|-----------------|
| `WHODB_EDITION`     | Edition selection: `community` or `enterprise` | `community`     |
| `WHODB_BACKEND_PORT`| Port for backend listening                      | `8080`          |
| `WHODB_DATABASE_URL`| Database connection string                       | *Required*      |
| `WHODB_LOG_LEVEL`   | Log verbosity: `info`, `debug`, `error`         | `info`          |

Always secure your database credentials and avoid committing `.env` files containing secrets.

---

## 6. Verification and First Run

After installation and configuration:

1. Start backend server or Docker containers.
2. Launch frontend UI.
3. Navigate to the UI in your browser.
4. Connect to your database using the UI following the next guide, "Connecting to Your Database." 

If the UI loads and allows database connection setup, your installation succeeded.

---

## 7. Troubleshooting Common Installation Issues

- Check conflicting ports (3000, 8080) are free.
- Inspect logs with `docker-compose logs`.
- Ensure Docker daemon is running.
- Verify environment variables in `.env`.

- Confirm the correct Go version.
- Verify dependencies installed and Go modules initialized.
- Clean cache: `go clean -modcache`.

- Confirm Node.js and pnpm versions.
- Run `pnpm install` again.
- Check `VITE_API_BASE_URL` in `.env`.

- Confirm DB server accessibility, credentials, and network.
- Use database client tools to test connection.
- Ensure sample data scripts are correctly applied.

---

## 8. Next Steps

- Proceed to [Initial Configuration](../initial-config-launch/initial-configurations) to set up your first connection profiles and preferences.
- Explore [Connecting to Your Database](../../guides/essential-workflows/connecting-to-your-database) for detailed workflows after installation.
- For Docker users, see "Environment Variables & Third-Party Integrations" to customize deployments.

---

## Summary
This page equipped you with practical, stepwise methods to install WhoDB using Docker Compose or manual builds for frontend and backend. You learned essential environment variables, database setup hints, and basic troubleshooting tips to ensure a robust start. With WhoDB installed, you are ready to configure connections and explore your data seamlessly.

---

## References
- [Prerequisites & System Requirements](../setup-requirements/prerequisites-system-requirements)
- [Choosing Community vs. Enterprise Edition](../../../deployment/prod_deployment/edition_selection)
- [First Run & Quick Validation](../initial-config-launch/first-run-and-validation)
- [Connecting to Your Database](../../guides/essential-workflows/connecting-to-your-database)
- [Docker Documentation](https://docs.docker.com/)
- [Go Programming Language](https://golang.org/)
- [Node.js](https://nodejs.org/)

---

## Support
For further assistance, visit our support page or community forums linked from the main documentation portal.

---

---


# getting-started/initial-config-launch/initial-configurations.mdx
## Initial Configuration

Explains how to set up essential environment variables and database credentials, choose between Community and Enterprise editions, and prepare the system for first use. Includes configuration examples for AI chat integrations and database connectors.

# Initial Configuration Guide

Setting up WhoDB for the first time involves configuring essential environment variables, providing database credentials, selecting the appropriate edition, and preparing AI chat integrations and database connectors. This guide walks you through these critical steps to get your system ready for immediate use.

---

## 1. Essential Environment Variables

WhoDB uses environment variables to control key behaviors such as edition selection, backend ports, and feature toggles. Properly setting these variables ensures your instance behaves as expected.

### 1.1 Edition Selection

- **`VITE_BUILD_EDITION`** determines the running edition of WhoDB:
  - Set as **`community`** for the Community Edition (CE).
  - Set as **`enterprise`** for the Enterprise Edition (EE).

This choice impacts UI components, features available, and included integrations.

```
# Example for Community Edition
export VITE_BUILD_EDITION=community

# Example for Enterprise Edition
export VITE_BUILD_EDITION=enterprise
```

### 1.2 Back-End Port Configuration

By default, the backend service listens on port 8080. If you need to change this:

```
export BACKEND_PORT=8080
```

Adjust any frontend or proxy configurations accordingly.

### 1.3 AI Chat Integration Variables

WhoDB supports AI chat-powered queries through providers such as Ollama, Anthropic, and OpenAI. To enable these integrations, set: 

- `AI_PROVIDER` — name of your chosen AI provider.
- `AI_API_KEY` — your API token or key.
- Additional tokens or URLs may be needed depending on the provider.

Example:

```
export AI_PROVIDER=openai
export AI_API_KEY="your-openai-api-key"
```

Refer to your AI provider's documentation for valid environment variables.

## 2. Database Credentials Setup

To connect WhoDB to your databases, supply connection credentials securely.

### 2.1 Supported Database Connections

WhoDB supports a variety of SQL, NoSQL, and cloud databases. Connection details typically include:

- Hostname or IP address
- Port
- Database name
- Username and password
- SSL configuration (if required)

### 2.2 Providing Credentials

When initializing WhoDB for the first time, the setup UI or configuration files will prompt you to enter these credentials. Alternatively, you can configure them via environment variables or configuration files depending on your deployment.

Example `.env` snippet:

```
DB_HOST=127.0.0.1
DB_PORT=5432
DB_NAME=whodb
DB_USER=admin
DB_PASS=secure_password
DB_SSLMODE=disable
```

Ensure credentials are stored securely and avoid committing them to source control repositories.

## 3. Choosing Between Community and Enterprise Editions

Choose the edition that fits your needs:

| Edition     | Description                                     | When to Choose                            |
|-------------|------------------------------------------------|------------------------------------------|
| Community   | Open-source, fully featured for most use cases | Ideal for individual developers and small teams |
| Enterprise  | Adds advanced features and extensibility        | Required for large organizations needing plugins, AI extensions, and enhanced integrations |

Set the edition through the `VITE_BUILD_EDITION` environment variable as shown earlier.

### 3.1 Edition-Specific Configurations

- The frontend code resolves GraphQL imports differently based on the edition.
- Enterprise Edition sets additional `paths` for extending UI and AI modules.

Use the Enterprise Edition only if your license permits and if you require advanced plugin or AI integration support.

## 4. Preparing AI Chat Integrations

To harness conversational AI features, complete the following:

### 4.1 AI Provider Configuration

- Obtain API credentials from your AI service.
- Set the related environment variables securely.

### 4.2 Configuration File Snippets

Below is an example of environment variables for different AI providers:

```
# OpenAI
AI_PROVIDER=openai
AI_API_KEY=sk-xxxxxx

# Anthropic
AI_PROVIDER=anthropic
AI_API_KEY=anthropic-key

# Ollama
AI_PROVIDER=ollama
OLLAMA_HOST=http://localhost:11434
```

### 4.3 Verifying AI Integration

After setup, test the AI chat functionality from within WhoDB's conversational UI to confirm connectivity and response quality.

## 5. Configuring Database Connectors

WhoDB uses connectors/plugins to interact with specific database engines.

### 5.1 Connector Configuration Files

Adjust configurations such as connection strings, timeouts, and SSL settings according to your database requirements.

Example JSON snippet (`database-config.json`):

```
{
  "type": "postgresql",
  "host": "127.0.0.1",
  "port": 5432,
  "database": "whodb",
  "user": "admin",
  "password": "secure_password",
  "ssl": false
}
```

### 5.2 Best Practices

- Use environment variables to avoid embedding credentials in config files.
- Test connections before starting WhoDB.

## 6. Practical Configuration Examples

### 6.1 Minimal `.env` for Community Edition with PostgreSQL and OpenAI

```
VITE_BUILD_EDITION=community
BACKEND_PORT=8080
DB_HOST=localhost
DB_PORT=5432
DB_NAME=whodb
DB_USER=admin
DB_PASS=admin123
AI_PROVIDER=openai
AI_API_KEY=sk-xxxxxx
```

### 6.2 Enterprise Edition with Ollama AI and MySQL

```
VITE_BUILD_EDITION=enterprise
BACKEND_PORT=8080
DB_HOST=mysql-host
DB_PORT=3306
DB_NAME=appdb
DB_USER=mysqluser
DB_PASS=mysqlpass
AI_PROVIDER=ollama
OLLAMA_HOST=http://localhost:11434
```

## 7. Verification and First Use Preparation

Once configured:

- Confirm environment variables are set and accessible.
- Ensure database credentials allow successful connections.
- Launch WhoDB and verify edition-specific visuals.
- Test AI chat integration by initiating queries.

See the [First Run & Quick Validation](./first-run-and-validation) guide for step-by-step launch and test procedures.

## 8. Troubleshooting Common Configuration Issues

Ensure environment variables are correctly exported or defined. Restart your shell or session if necessary. Verify with:

```
printenv | grep VITE_BUILD_EDITION
```

- Confirm credentials are accurate.
- Check network accessibility and firewall rules.
- Verify database is running.
- Look for SSL mismatches.

- Verify API keys are valid and not expired.
- Check internet connectivity for cloud providers.
- Confirm local AI services (like Ollama) are running and reachable.

---

For additional setup assistance, consult our [Installation Methods](../setup-requirements/installation-methods) and [Prerequisites & System Requirements](../setup-requirements/prerequisites-system-requirements).

---

## References
- [Choosing Community vs. Enterprise Edition](../../deployment/prod_deployment/edition_selection)
- [Environment Variables & Third-Party Integrations](../../deployment/prod_deployment/env_config)
- [Connecting to Your Database](../../guides/essential-workflows/connecting-to-your-database)
- [Conversational AI Integration Patterns](../../concepts/integration-patterns/ai-integration)

---

## Summary Diagram: Initial Setup Flow

```
flowchart TD
  EnvVar["Set Environment Variables"] --> EditionChoice["Select Edition: Community or Enterprise"]
  EditionChoice -->|Community| FrontendCE["Load Community Frontend Config"]
  EditionChoice -->|Enterprise| FrontendEE["Load Enterprise Frontend Config"]
  EnvVar --> DBConfig["Configure Database Credentials"]
  DBConfig --> TestDB["Test Database Connection"]
  EnvVar --> AIConfig["Set AI Provider Variables"]
  AIConfig --> TestAI["Test AI Chat Integration"]
  FrontendCE --> LaunchApp["Start WhoDB Service"]
  FrontendEE --> LaunchApp
  TestDB --> LaunchApp
  TestAI --> LaunchApp
  LaunchApp --> Ready["Ready for First Use"]
```

---


# getting-started/initial-config-launch/first-run-and-validation.mdx
## First Run & Quick Validation

Provides a sequential guide from launching WhoDB for the first time to verifying access via a web browser. Demonstrates quick checks to confirm basic functionality—logging in, accessing sample databases, and engaging the conversational AI (if available).

# First Run & Quick Validation

Welcome to the first run experience of WhoDB. This guide leads you step-by-step from launching the application to verifying your ability to log in, browse sample data, and interact with the conversational AI features where applicable. By following these steps, you'll confirm that WhoDB is properly installed, running, and ready for deeper exploration.

---

## 1. Launching WhoDB for the First Time

Before you begin, ensure you have completed installation and initial configuration as described in the previous guides [Installation Methods](../setup-requirements/installation-methods) and [Initial Configuration](./initial-configurations).

### Steps to Start the Application

Open your terminal and enter the `core` directory where WhoDB's backend resides.

Run the appropriate command based on your edition:

```
# For Community Edition
./whodb

# For Enterprise Edition
./whodb-ee
```

Or if you prefer running from source:

```
# Community Edition
cd core && go run .

# Enterprise Edition
cd core && go run -tags ee .
```

Watch your terminal output. You should see confirmation messages indicating the server has started and the port it is listening on (default is typically `http://localhost:7070`).

If the server fails to start, verify your environment variables and configurations per [Initial Configuration](./initial-configurations). Common issues include missing database credentials or port conflicts.

## 2. Accessing the WhoDB Web Interface

Once the backend is running, open your preferred web browser and go to:

```
http://localhost:7070
```

This URL loads the WhoDB UI where you can log in and interact with your connected data sources.

### Verify Successful Connection

- The login page should appear without errors.
- Use credentials configured in your database or as per your authentication setup.

If the login page does not load or you see connection errors, check that your backend service is running and the port is correctly open.

## 3. Logging In and Navigating the Interface

### User Login

- Enter your username and password.
- Upon successful authentication, you will see the main dashboard.

### Dashboard Overview

- The sidebar lets you select connected databases.
- The main pane displays schema visualizations, tables, and query interfaces.

If you have not connected a database yet, sample databases may be preloaded (e.g., `test_db`) for quick exploration.

## 4. Exploring Sample Databases

To validate WhoDB's basic functionality, explore one of the included sample databases populated with example data (e.g., MySQL `test_db` with typical e-commerce schema).

### How to Explore

1. From the sidebar, select the sample database.
2. Browse tables like `users`, `products`, `orders`, and `payments`.
3. Click a table to view its columns and sample rows.

### Important Tables Included in Sample Data

- **users:** User accounts with usernames and emails.
- **products:** Sample product listings with pricing.
- **orders:** Customer orders linked to users.
- **order_items:** Items within each order.
- **payments:** Payment records associated with orders.

### Running Simple Queries

- Use the query editor or the scratchpad to run basic SQL queries:

```
SELECT * FROM users LIMIT 5;
```

- Verify results display as expected.

## 5. Engaging the Conversational AI (If Available)

If your edition and setup include AI conversational integration, test it as follows:

1. Open the AI Chat panel or conversational interface.
2. Enter natural language queries, for example:

```
Show me all orders placed by john_doe last month.
```

3. Review the AI-generated SQL and results.

If AI chat is not responding or unavailable, verify your AI provider configuration as outlined in [AI Integration Guide](../guides/ai-and-natural-language/conversational-queries-and-ai-models).

## 6. Verifying Successful Operation

After completing the above steps, confirm:

- Backend server runs without error.
- UI loads in your browser and allows login.
- Sample databases are accessible and tables can be viewed.
- SQL queries execute and return results.
- Conversational AI responds correctly (if enabled).

You have successfully launched WhoDB, confirmed connectivity, and verified data browsing and query functions.

## 7. Troubleshooting Common First-Run Issues

- Ensure the backend is running and listening on port 7070.
- Confirm no firewall or antivirus is blocking the port.
- Check your machine’s localhost mapping.

- Verify database credentials and user accounts are properly configured.
- Confirm environment variables match your setup.
- Review authorization mechanisms (local or external).

- Check the database connection details.
- Verify sample data was loaded into your database.
- Reload or reset the sample data scripts from the `/dev/sample-data` directory.

- Confirm AI provider credentials are configured.
- Verify network connectivity to external AI services.
- Check relevant logs for error messages.

## 8. Next Steps

Now that you've confirmed WhoDB is up and running:

- Proceed to [Connecting to Your Database](../../guides/essential-workflows/connecting-to-your-database) to integrate your production databases.
- Explore [Querying Your Data with AI Chat](../../guides/ai-and-natural-language/conversational-queries-and-ai-models) for advanced conversational querying.
- Review [Initial Configuration](./initial-configurations) if you need to adjust any system settings.

---

By completing this guide, you have established a reliable foundation to leverage WhoDB’s unified data management capabilities and conversational AI interface.

Happy exploring!

---


# getting-started/troubleshooting/troubleshooting-common-issues.mdx
## Troubleshooting Common Issues

Lists and explains common problems encountered during installation and initial configuration—such as missing dependencies, port conflicts, database connection failures, or issues with embedding the frontend build. Offers clear remedies and directs users to log files or community support channels for further help.

# Troubleshooting Common Issues

This guide addresses frequent problems encountered during WhoDB installation and initial configuration. It helps you quickly identify and resolve issues related to missing dependencies, port conflicts, database connection failures, and frontend embedding errors, ensuring a smooth start with WhoDB.

---

## 1. Missing Dependencies or Environment Setup

### Issue
WhoDB fails to start or throws errors due to absent or misconfigured dependencies such as Go, Node.js, pnpm, or Docker.

### How to Detect
- Errors during installation or build mentioning missing commands or tools.
- Failure messages related to environment variable access.

### Resolution Steps
1. Verify the installation of required software:
   - **Go**: Run `go version` to confirm.
   - **Node.js**: Run `node -v`.
   - **pnpm**: Run `pnpm -v`.
   - **Docker**: Run `docker --version`.

2. Set up environment variables properly:
   - Check your shell or system configuration to ensure variables like `WHODB_POSTGRES_1` or `ENVIRONMENT` (for development mode) are defined correctly.

3. Follow the [Prerequisites & System Requirements](https://yourdocs.example.com/getting-started/setup-requirements/prerequisites-system-requirements) page for detailed versions and installation instructions.

Always restart your terminal session or IDE after installing new dependencies to load environment variables.

---

## 2. Port Conflicts or Service Not Starting

### Issue
WhoDB backend fails to start because the configured port (default 8080) is already in use.

### How to Detect
- Errors like "address already in use" in startup logs.
- The service looks healthy but is unreachable at expected address.

### Resolution Steps
1. Identify the port conflict:

   - On Linux/macOS:
   ```
   lsof -i :8080
   ```
   - On Windows:
   ```
   netstat -aon | findstr :8080
   ```

2. Free the port:
   - Kill the process using the port (confirm carefully before termination).

3. Change WhoDB's port:

   - Set environment variable `WHODB_BACKEND_PORT` to a free port number before start.
   - Example with Docker:
     ```
     docker run -it -p 9090:9090 -e WHODB_BACKEND_PORT=9090 clidey/whodb
     ```

4. Confirm service accessibility at the new port via browser.

Ensure no firewall or network policy blocks the chosen port.

---

## 3. Database Connection Failures

### Common Causes
- Incorrect credentials (host, username, password, database name, port).
- Database server unreachable or not running.
- Unsupported database version or plugin misconfiguration.
- Missing advanced parameters if required (e.g., SSL modes).

### How to Detect
- Errors during login or connection attempts like "authentication failed", "connection timeout", or "plugin unavailable".

### Resolution Steps
1. **Double-check your database credentials:**
   - Review the login profile or environment variable format, e.g.,
     ```
     WHODB_POSTGRES_1='{"host":"localhost","user":"user","password":"password","database":"dbname"}'
     ```
   - Confirm your DB server is accessible on that host and port.

2. **Test connectivity independent of WhoDB:**
   - Use native database clients or command-line tools (e.g., `psql`, `mysql`, `mongo`) to confirm credentials and reachability.

3. **Verify advanced options:**
   - Some database connections require parameters like SSL, connection timeouts, or special flags.
   - Add these as JSON key-value pairs in the `config` map of your environment variable JSON.

4. **Refer to the [Connecting to Your Database](https://yourdocs.example.com/guides/essential-workflows/connecting-to-your-database) guide for specific database connection examples and nuances.**

For SQLite, ensure the database file is correctly mounted into the Docker container at `/db/` when using Docker.

---

## 4. Frontend Build Embedding Issues

### Issue
Failures or display problems stemming from an improperly embedded or missing frontend build.

### How to Detect
- Blank or error pages when accessing the UI.
- Log errors mentioning missing static assets or HTTP 404s on frontend resources.

### Resolution Steps
1. If running from source, ensure you have built the frontend:

   ```
   pnpm install
   pnpm build
   ```

2. When using Docker, confirm you are using a tagged image with the frontend correctly included (such as `clidey/whodb:latest`).

3. Check any volume mounts or file paths if overriding static assets.

4. Review the [Installation Methods](https://yourdocs.example.com/getting-started/setup-requirements/installation-methods) and [Initial Configurations](https://yourdocs.example.com/getting-started/initial-config-launch/initial-configurations) pages for recommended practices.

---

## 5. AI Integration and Chat Issues

### Issue
Problems with conversational AI features enabled but not responding or authenticating.

### How to Detect
- Errors about missing API keys.
- AI chat failing to load or returning errors.

### Resolution Steps
1. Validate your AI environment variables for providers such as OpenAI, Anthropic, or Ollama (e.g., `WHODB_OPENAI_API_KEY`).

2. Confirm network access to endpoints configured.

3. Check the [Integrations Overview](https://yourdocs.example.com/overview/architecture-concepts-group/integration-overview) for precise environment variable setup and key usage.

4. Test disabling AI chat integrations if not needed by setting relevant env vars empty or omitting them.

---

## 6. Reviewing Logs for Diagnosis

Access WhoDB server logs for detailed error information:
- When running with Docker, use:

  ```
  docker logs 
  ```

- For local runs, check console output or log files if configured.

Review logs carefully for stack traces or warnings indicating root causes.

---

## 7. Getting Further Help

- **Community Support:** Engage with the WhoDB user community and forums.
- **Documentation:** Visit [Getting Started](https://yourdocs.example.com/getting-started/setup-requirements/prerequisites-system-requirements) and linked guides.
- **GitHub Issues:** Report reproducible bugs or feature requests at the [WhoDB GitHub Repository](https://github.com/clidey/whodb).

Always include relevant logs, system info, and steps to reproduce when seeking help.

---

# Summary
This page helps you swiftly overcome common issues during WhoDB setup and initial use: ensuring dependencies and environment variables are correct, resolving port conflicts, fixing database connection errors, and handling frontend loading or AI integration challenges. Detailed steps and diagnostic tips empower you to regain a working system efficiently.

---

# Quick Reference Links

- [Prerequisites & System Requirements](https://yourdocs.example.com/getting-started/setup-requirements/prerequisites-system-requirements)
- [Installation Methods](https://yourdocs.example.com/getting-started/setup-requirements/installation-methods)
- [Initial Configurations](https://yourdocs.example.com/getting-started/initial-config-launch/initial-configurations)
- [Connecting to Your Database](https://yourdocs.example.com/guides/essential-workflows/connecting-to-your-database)
- [Integrations Overview](https://yourdocs.example.com/overview/architecture-concepts-group/integration-overview)
- [Getting Help & Support](https://yourdocs.example.com/faq/help-community-support/getting-help-contacting-support)

---


# guides/essential-workflows/connecting-to-your-database.mdx
## Connecting to Your Database

Learn how to connect to popular databases including PostgreSQL, MySQL, SQLite3, MongoDB, Redis, and ElasticSearch (as well as EE-only sources). This guide walks through connection options, credentials, profiles, and troubleshooting tips for fast onboarding.

# Connecting to Your Database

Welcome to the guide that gets you connected and up running with your databases in WhoDB. Whether your data lives in PostgreSQL, MySQL, SQLite3, MongoDB, Redis, or ElasticSearch, this page walks you through each connection type's requirements, credential setup, profiles, and how to troubleshoot connection obstacles to streamline your onboarding.

---

## 1. Workflow Overview

### What this guide helps you accomplish
This guide leads you through establishing successful connections from WhoDB to popular databases, ensuring your credentials and connection options are set properly for smooth integration. You will learn how to specify connection parameters, use profiles, and troubleshoot issues to quickly interact with your data.

### Prerequisites
- Have your database running and accessible via network.
- Obtain correct credentials: hostname, port, username, password, and database name.
- Confirm network connectivity and access rights.
- For SQLite3, have your database file prepared.

### Expected outcome
You will have WhoDB configured to connect securely and efficiently to your chosen database system, verified through successful connection tests and ready for exploration.

### Estimated time
10-20 minutes per database connection

### Difficulty level
Beginner to Intermediate depending on familiarity with database connection concepts

---

## 2. Step-by-Step: Connecting to Common Databases

### 2.1 General Connection Settings

Every database connection requires key values:
- **Hostname**: The address of your database server.
- **Port**: Network port (default varies per database).
- **Username and Password**: Credentials with access privileges.
- **Database name**: The specific database or schema to connect to.
- **Advanced options**: Settings like SSL mode, connection timeouts, or protocol tweaks.

Use these consistently in the database credential forms or configuration profiles.

---

### 2.2 PostgreSQL Connection

1. **Default port:** `5432`
2. **Credential parameters:**
   - Hostname
   - Port
   - Username
   - Password
   - Database
   - Extra options as needed (e.g., runtime parameters)

3. **How WhoDB connects:**
   - Uses pgx with GORM for ORM support
   - Supports runtime parameter overrides

4. **Tips:**
   - Use URL encoding for special characters in credentials
   - Add custom runtime parameters via the "Advanced" section

5. **Verify:** Successful connection leads to schema discovery and access to tables.

---

### 2.3 MySQL Connection

1. **Default port:** `3306`
2. **Credential parameters:**
   - Hostname
   - Port
   - Username
   - Password
   - Database
   - Parse Time (bool)
   - Allow Cleartext Passwords (bool)
   - Additional query parameters

3. **How WhoDB connects:** Uses GORM with the Go MySQL Driver

4. **Best practices:**
   - Enable `ParseTime` to correctly handle date/time types.
   - Set `AllowClearTextPasswords` if your server requires.

5. **Verify:** Check connection by enumerating databases and tables.

---

### 2.4 SQLite3 Connection

1. **Database file**: Use the full path to your SQLite database file. For development, default folder is `tmp/`; for production, `/db/`.
2. **Permissions:** Ensure WhoDB has read and write access.
3. **How WhoDB connects:** Uses GORM SQLite driver opening the file.
4. **Pitfalls:**
   - Symlinks are resolved; database file must be inside allowed directory.
   - Missing file or no permission leads to an error.

5. **Verify:** Connection means you can browse tables within your SQLite file.

---

### 2.5 MongoDB Connection

1. **Default port:** `27017`
2. **Credential parameters:**
   - Hostname
   - Port
   - Username
   - Password
   - Database
   - DNS Enabled (bool) - whether to use MongoDB's DNS seed list connection string (mongodb+srv)
   - URL Params (optional query parameters)

3. **How WhoDB connects:** Uses official MongoDB Go driver
4. **Tips:**
   - Set `DNS Enabled` to true if connecting to MongoDB Atlas or SRV-based clusters.
   - Include any additional connection parameters via `URL Params` string.

5. **Verify:** Connection success allows listing collections and querying documents.

---

### 2.6 ClickHouse Connection (Enterprise Edition)

1. **Default port:** `9000`
2. **Credential parameters:**
   - Hostname
   - Port
   - Username
   - Password
   - Database
   - SSL Mode (disable|none|relaxed)
   - HTTP Protocol (enable|disable)
   - Debug (enable|disable)
   - Readonly (enable|disable)

3. **Tips:**
   - Enable TLS if your ClickHouse instance supports it.
   - Adjust debug mode for troubleshooting.

4. **Verify:** Connection test and ability to query ClickHouse tables.

---

## 3. Using Profiles for Connection Management

WhoDB supports configuration profiles that allow you to save and reuse credential sets. Profiles can include additional advanced parameters beyond typical connection fields, improving security and convenience.

- To use a profile, mark the credential set as a profile when adding.
- Profiles allow parameterized overrides like SSL options and custom connection timeout.
- Profiles help manage multiple database connections efficiently.

Use profiles to separate development, staging, and production databases to avoid confusion or accidental cross-connection.

---

## 4. Practical Examples

```
Hostname: "db.example.com"
Port: "5432"
Username: "admin"
Password: "s3cret"
Database: "myapp"
Advanced:
  sslmode: "require"
  timezone: "UTC"
```

```
Hostname: "cluster0.mongodb.net"
Port: "27017"
Username: "mongouser"
Password: "pass123"
Database: "test_db"
Advanced:
  DNS Enabled: "true"
  URL Params: "?retryWrites=true&w=majority"
```

---

## 5. Troubleshooting Common Connection Issues

- Verify hostname and port are correct and accessible from the WhoDB host.
- Check firewall or network restrictions.
- Confirm credentials are valid and have the required permissions.
- For cloud or managed DBs, confirm IP whitelist includes your server.
- Review SSL requirements—enable or disable SSL as needed.

- Double-check username and password spelling.
- Use proper URL encoding for special characters.
- Use cleartext password options if needed (MySQL).
- Confirm that the user has permission to access the specified database.

- Ensure the SQLite database file exists and is in the expected path.
- Make sure WhoDB process has read/write permissions.
- Symlinked files outside the allowed folder will cause connection failure.

- If using MongoDB Atlas or SRV, ensure DNS Enabled option is true.
- Verify `URL Params` are properly formatted.
- Ensure the MongoDB driver version used by WhoDB matches cluster requirements.

---

## 6. Next Steps & Related Documentation

- After successful connection, proceed to [Exploring and Managing Data](/guides/essential-workflows/exploring-and-managing-data) to learn schema navigation and data browsing.
- For security best practices, see [Security and Authentication Essentials](/guides/best-practices-and-optimization/security-and-authentication).
- Need help resolving connection issues? Visit [Troubleshooting Common Issues](/getting-started/troubleshooting/troubleshooting-common-issues).

Keep your credentials secure. Avoid sharing passwords and consider integrating encrypted secrets managers if available.

---

## 7. Visual Summary Diagram of Typical Connection Flow

```
flowchart TD
  Start["Start: User Inputs Credentials"] --> Configure["Configure Connection Details"]
  Configure --> ValidateParams{Are Parameters Valid?}
  ValidateParams -- No --> Error1["Show parameter error message"]
  ValidateParams -- Yes --> EstablishConnection["Establish Connection to Database"]
  EstablishConnection --> VerifyConnection{Connection Successful?}
  VerifyConnection -- No --> Error2["Show connection failure message"]
  VerifyConnection -- Yes --> Success["Connection Established - Access Schema"]
```

---

---


# guides/essential-workflows/exploring-and-managing-data.mdx
## Exploring and Managing Data

Step through browsing storage units (tables, collections, keys), filtering and searching records, performing inline edits, creating new entries, and safely deleting data. Includes how to use table virtualization for seamless navigation over large datasets.

# Exploring and Managing Data

Explore the powerful capabilities of the WhoDB data management interface that lets you browse storage units, search and filter records, edit data inline, add new entries, and delete with confidence. This guide will walk you through the essential workflows and features available on the storage unit exploration and data management page.

---

## 1. Overview and Workflow

### What You Can Accomplish Here

- Browse storage units such as tables, collections, or keys from your connected database schema.
- Search and filter through records using flexible where conditions.
- Navigate seamlessly through large datasets with automatic table virtualization.
- Inline edit existing records and save updates safely.
- Add new data entries with guided input forms.
- Select and delete records securely with batch support.

### Prerequisites

- You must be connected to a database and have a schema selected in WhoDB.
- Appropriate permissions to read and modify data in the chosen storage unit.
- Familiarity with your database's schema structure for effective filtering and understanding data.

### Expected Outcome

By following this guide, you will confidently navigate through your database storage units, efficiently search and filter records, modify data inline, add new entries, and delete records without disruption, making data management smooth and productive.

### Time Estimate

Approximately 10-20 minutes to complete initial familiarization and basic data management tasks.

### Difficulty Level

Intermediate — requires basic understanding of your database schema and data editing concepts.

---

## 2. Navigating and Exploring Storage Units

### Accessing Storage Units

When you enter the storage unit exploration page, you will see a list of storage units (tables, collections, or key sets) corresponding to the currently selected database schema.

- Use the *search box* to filter storage units by name.
- Each storage unit card provides summary attributes (e.g., row count, indexes) for quick insight.
- Click **Explore** on a storage unit card to inspect its data records in detail.

### Data Table Overview

Upon exploring a storage unit, the main view presents a pageable table showing rows of data:
- Column headers show the field names and their types.
- Rows display data records.
- Pagination controls allow navigating through pages.
- You can customize the page size by entering a value in the **Page Size** input for more or fewer rows per page.

### Table Virtualization

For large datasets, virtual scrolling ensures smooth performance by rendering only visible rows:
- Scroll smoothly even in datasets with tens of thousands of rows.
- Paging still works to align with standard data management expectations.

---

## 3. Searching and Filtering Records

### Applying Where Conditions

You can filter data using flexible logical where conditions:
- Click the **Where condition** builder to add, edit, or remove filter criteria.
- Filters use field names (columns), operators (like =, \<\>, LIKE), and values.
- Supports multiple conditions combined with AND logic.

### How To Apply Filters

1. Click the filter **+** button to add a new condition.
2. Select a column (field) from the dropdown.
3. Choose an operator suitable for your data type.
4. Enter the filter value.
5. Click **Add** to append the filter.
6. Click **Query** to execute and refresh results.

### Editing Existing Filters

- Click a filter's text to open the edit popup.
- Modify the column, operator, or value.
- Save or cancel changes.
- Remove unwanted filters with the delete icon.

### Best Practices

- Use string operators like LIKE for partial matches.
- Use numeric operators (>, \<, =) for number fields.
- Reset filters regularly to avoid stale queries.

---

## 4. Inline Editing Existing Records

### Entering Edit Mode

- Hover over a cell and click the pencil icon to start editing.
- Alternatively, long press (or right-click) on the cell to preview data safely.

### Editing and Updating Values

- Modify the cell content.
- Supported content types include text, JSON (validated), and markdown previews.
- Use the **Save** button to commit changes.
- Cancel edits with the **Cancel** button to revert.

### Editing Tips

- Use the preview mode for safely viewing large JSON or markdown content before editing.
- Beware of unsaved changes — attempting to exit with edits prompts a warning.

### After Update

- Successful updates trigger a confirmation notification.
- In case of failures (validation errors, network issues), you receive immediate feedback.

---

## 5. Adding New Entries

### Opening the Add Row Form

- Click the **Add Row** button to reveal a dynamic form.
- Form fields correspond to the columns of the current storage unit.

### Filling Out the Form

- Default values are provided for common types (UUID, timestamps, numerics).
- For NoSQL types, document fields are flattened or dynamic.
- Use the dropdown to select field types (text or SQL snippet).

### Submitting New Data

- Fill out desired values.
- Click **Submit** to add the row.
- Newly added rows will appear after a query refresh.
- Cancel the addition by toggling off the form if you entered no data.

### Best Practices

- Provide valid data matching your database schema types.
- Use SQL expressions for computed columns where applicable.

---

## 6. Selecting and Deleting Records

### Selecting Records

- Use checkboxes in the leftmost column to select individual rows.
- Use the header checkbox to select or deselect all visible rows.

### Deleting Selected Records

- After selection, click the **Delete Row(s)** button.
- Confirm deletion actions if prompted.
- Batch deletions stop on first failure to prevent inconsistent states.

### After Deletion

- Deleted rows are removed from the current view immediately.
- You receive feedback on success or errors.

### Caution

- Deleted data cannot be recovered through the UI.
- Always double-check your selections before confirmation.

---

## 7. Practical Tips and Troubleshooting

### Tips for Success

- Use filters to narrow down data for editing to increase safety.
- Regularly refresh queries after modifications to sync your view.
- Utilize table virtualization for smooth scrolling on large data.

### Common Issues and Solutions

If the table fails to load or updates do not reflect:
- Confirm your connection and current database schema.
- Verify permissions allow reading and modifying data.
- Try reducing page size or clearing filters.

Editing cells does not save changes:
- Check for validation errors or unsupported data types.
- Ensure your session is active (not logged out).
- Review any error messages provided.

Add row form does not appear or fields are missing:
- Confirm you’re in a data-compatible storage unit.
- For Redis or unsupported types, adding rows may be disabled.

Selecting rows for deletion does not work:
- Use the column checkbox for selection.
- Certain NoSQL databases may restrict deletions through the UI.

### Support

If you encounter unresolved issues, consult the [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) guide or contact support.

---

## 8. Next Steps and Related Documentation

- After mastering data exploration, proceed to [Visualizing Your Database Schema](https://whodb.com/docs/guides/essential-workflows/visualizing-your-database-schema) to better understand relationships.
- Learn to use the [Scratchpad Interface](https://whodb.com/docs/guides/ai-and-natural-language/scratchpad-and-raw-sql) for advanced querying and combining data operations.
- Enhance productivity by exploring [Working Efficiently with Large Datasets](https://whodb.com/docs/guides/best-practices-and-optimization/working-efficiently-with-large-datasets).

---

## 9. Additional Resources

- [WhoDB Overview and Key Features](https://whodb.com/docs/overview/intro-value-group/key-features-overview)
- [Connecting to Your Database](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database)
- [System Architecture Overview](https://whodb.com/docs/overview/architecture-concepts-group/system-architecture-overview)

---

---


# guides/essential-workflows/visualizing-your-database-schema.mdx
## Visualizing Your Database Schema

Discover how to use WhoDB’s interactive schema graph to understand relationships between tables, collections, and keys. This tutorial covers graph navigation, filtering, and interpreting entity relationships to gain insight into your data structure.

# Visualizing Your Database Schema

Welcome to the schema visualization guide for WhoDB! This tutorial empowers you to leverage WhoDB’s interactive database schema graph. By following it, you will gain clear insights into how your tables or collections are connected, understand entity relationships, and navigate your schema graph effortlessly.

---

## 1. What You Will Achieve

This guide will help you:

- Understand the structure and relationships of your database schema through an intuitive visual graph.
- Navigate and explore storage units (tables, collections) and their interconnections.
- Use graph layout and filtering tools for a clearer schema perspective.
- Interpret relationship types such as one-to-many or many-to-many within your schema graph.

By the end, you’ll confidently use the Graph Page feature to gain meaningful perspectives on your data’s architecture.

---

## 2. Prerequisites

Before you start:

- Ensure a database connection is properly configured and active in WhoDB ([See Connecting to Your Database Guide](https://whodb.com/guides/essential-workflows/connecting-to-your-database)).
- Your database schema metadata must be available and populated.
- Have access to WhoDB’s web interface and permissions to visualize schema data.

---

## 3. Accessing the Schema Graph

1. **Open the Graph Page:**
   - In WhoDB’s navigation menu, select the `Graph` option to open the interactive schema graph view.

2. **Loading Data:**
   - Upon loading, the system fetches storage units and their relationships from your database schema.
   - If no schema or nodes are found, the interface will indicate "No tables or collections found".

3. **Initial Layout:**
   - The graph auto-applies a Directed Acyclic Graph (DAG) layout, arranging nodes left-to-right for natural relationship flow.

---

## 4. Navigating and Interpreting the Graph

### Graph Nodes

- Each node represents a **storage unit** — e.g., a table or collection.
- Node labels display the storage unit name.
- Nodes provide interactive UI elements allowing you to explore detailed attributes and navigate to related data views.

### Graph Edges

- Edges illustrate relationships between storage units:
  - **One-to-many**: Shows direction from parent to child.
  - **Many-to-many**: Displayed as bidirectional edges connecting related units.

- Hovering over an edge or node reveals relationship details and connection metadata.

### Interactivity

- **Panning and Zooming:** Use mouse drag and scroll wheel or touch gestures to explore different parts of the graph.
- **Selecting a Node:** Click nodes to highlight and reveal more info or to navigate to its data page.
- **Layout Refresh:** Click the layout button (graph icon) to reapply automatic positioning for clarity.

---

## 5. Practical Workflow: Visualizing and Exploring Your Schema

Navigate to the `Graph` page via the main menu to load the schema graph.

Observe the nodes representing your tables or collections, and examine edges that depict their relationships.

Pan or zoom the view to focus on areas of interest in your schema.

If nodes seem cluttered, click the "Graph Layout" button (bottom right) to reorganize the graph automatically.

Click a node to view summary details. Use the navigation button to jump to its detailed data page for further exploration.

---

## 6. Tips and Best Practices

- **Refreshing the Graph:** If your database schema changes, reload the Graph Page to see updated schema structure.
- **Handling Large Schemas:** For very large datasets, zoom in on logical subgraphs or filter storage units using search or pre-filtered views (when available).
- **Understanding Relationship Types:** Pay attention to edge directions and multiplicities as they convey foreign key and association constraints.
- **Exporting the Graph:** Use the download icon to export your schema graph as a PNG image for documentation or presentations.

---

## 7. Common Issues and Troubleshooting

- Ensure your database connection is active.
- Confirm the selected schema contains tables or collections.
- Check backend logs for GraphQL query errors.
- Refresh the page or try reconnecting your database.

- Some graph arrangements may have challenging layouts depending on complexity.
- Try zooming and manual panning to enhance visibility.
- Consider simplifying your schema views or filtering units.

- Large schemas with hundreds of nodes may slow rendering.
- Try segmenting schema into smaller sections.
- Use efficient hardware/browser if possible.

- Confirm your database schema relationships are properly defined.
- Validate foreign key constraints exist where applicable.
- Check for any caching issues in WhoDB UI.

---

## 8. Related Workflows and Next Steps

- **Connecting to Your Database:** If schema data is missing, verify your database connection setup.
- **Exploring and Managing Data:** Navigate from schema nodes to detailed data views for records and inline editing.
- **Using the Scratchpad and Raw Query Executor:** Run raw queries to inspect data behind schema components.
- **Querying Your Data with AI Chat:** Engage conversational AI to understand schema relationships and data queries more intuitively.

For detailed guides, visit the [Essential Workflows Guides](https://whodb.com/guides/essential-workflows/).

---

## 9. Technical Notes (Optional)

- The graph uses React Flow with a DAG layout algorithm powered by Dagre for node positioning.
- Nodes correspond to storage units fetched via GraphQL queries against the current schema.
- Edges reflect relationship data captured from the database metadata.

---

For additional help, visit the [Troubleshooting Common Issues](https://whodb.com/getting-started/troubleshooting/troubleshooting-common-issues) guide or contact support.

---

Happy exploring your data architecture!

---

# Diagram: Schema Graph Overview

```
flowchart LR
    subgraph StorageUnits ["Storage Units"]
        A["Table A"]
        B["Table B"]
        C["Table C"]
    end

    A -->|"One-to-Many"| B
    B --|"Many-to-Many"| C
    C --> A
```

The example diagram shows directional relationships where Table A has a one-to-many relationship with Table B, and B and C share a many-to-many relationship.

---


# guides/ai-and-natural-language/conversational-queries-and-ai-models.mdx
## Querying Your Data with AI Chat

Learn how to use AI-driven chat (powered by Ollama, ChatGPT, Anthropic) to ask natural questions about your data and receive actionable results. Covers model selection, configuring providers, and understanding generated results.

# Querying Your Data with AI Chat

Unlock the power of natural language to interact with your database effortlessly. This guide walks you through using the AI-driven chat interface in WhoDB, letting you ask questions about your data and receive actionable, context-aware results. You'll learn to select AI models, configure providers, submit queries, and interpret responses—turning complex SQL operations into simple conversations.

---

## 1. Understanding the AI Chat Interface

### What This Page Does
The AI Chat page equips you to interact with your data using natural language prompts processed by advanced AI models such as Ollama, ChatGPT, and Anthropic. You can:  
- Select an AI provider and model  
- Input conversational queries  
- View dynamically generated answers, SQL results, and visual charts  

### Prerequisites
- You must have a connected database with an active schema.  
- At least one supported AI provider (Ollama, ChatGPT, Anthropic) configured and available.  
- Valid model tokens if required for external providers.  

### Expected Outcome
- Submit natural language questions about your data.  
- Receive textual responses describing results or generated SQL queries.  
- View the executed query results as tables or charts inline.  
- Manage conversations with history and context-aware responses.

### Time Estimate
- Initial setup and familiarization: 5-10 minutes  
- Submitting and reviewing queries: seconds per interaction

### Difficulty Level
Intermediate — basic knowledge of your data and conversational AI concepts is helpful.

---

## 2. Step-by-Step Guide to Using AI Chat

### Step 1: Select Your AI Provider and Model

1. **Locate the Provider Dropdown:** At the top left of the AI Chat page, choose your AI provider (e.g., Ollama, ChatGPT, Anthropic).  
2. **Choose an AI Model:** Select the desired AI model available for the chosen provider. Models vary in capability and token requirements.
3. **Add External Models (if needed):** Use the "Add External Model" option to configure new providers by specifying model type and authentication token.

**Tip:** Models with tokens should be configured accurately to avoid connection issues.

### Step 2: Understand the Chat UI

- **Chat History Panel:** Displays previous interactions, including user queries and AI responses.
- **Input Box:** Type your natural language query here.
- **Submit Button (Arrow):** Click or press Enter to send your query.
- **New Chat:** Starts a fresh conversation, clearing context.
- **Example Prompts:** Click on sample questions if you're unsure where to start.

### Step 3: Compose Your Natural Language Query

- Formulate your question about the data, such as "Show me all orders from last month" or "What are the top 5 customers by sales?"
- The AI engine interprets your input and generates SQL or textual answers.

### Step 4: Submit Your Query and Review Results

1. Type your query in the input box.
2. Submit it using the arrow button or pressing Enter.
3. Wait briefly as the AI processes your request (a loading indicator with playful phrases will appear).
4. Review the AI’s textual answer.
5. View the query results presented as:
   - **Tables:** Displayed with sortable columns and rows.
   - **SQL Code:** Toggle between result and the generated SQL query.
   - **Charts (EE Only):** Some responses include visualizations like pie or line charts.

### Step 5: Manage Conversations and Context

- The chat keeps track of conversation history to provide contextually relevant answers.
- Use the "New Chat" button to reset context when switching topics.
- Scroll through chat history to revisit previous queries and responses.

### Step 6: Troubleshoot Common Issues

- **No models listed:** Verify your provider setup and tokens. Check the models availability status.
- **Slow or no response:** Confirm network connectivity and AI service health.
- **Unexpected errors:** Notifications will display error messages; try submitting your query again or restart the chat.
- **Query returns empty results:** Refine or clarify your question.

Always ensure your schema is correctly loaded and accessible. The AI models generate queries based on the schema and table details available.

---

## 3. Practical Examples to Get You Started

### Example 1: Basic Data Retrieval

> "List all active users created in the past 30 days"

- Expected: AI generates a SQL SELECT query filtered by creation date and status.
- Output: Table listing matching user records.

### Example 2: Aggregate Analysis

> "What is the total sales per region this quarter?"

- Expected: AI returns SQL with GROUP BY on region and SUM aggregation.
- Output: Table or chart displaying sales totals partitioned by region.

### Example 3: Data Modification Prompt (Advanced)

> "Add a new product named 'Eco Bottle' priced at $15"

- Expected: AI draft an INSERT SQL.
- Note: The system requires confirmation for data modifications before executing.

### Example 4: Conversational Clarifications

> User: "Show me the top 3 products"
> AI: Responds with results.
> User: "Only those in the 'Kitchen' category"

- The AI incorporates previous context to refine query.

---

## 4. Tips & Best Practices

- **Be Clear and Specific:** Provide sufficient context to get precise answers.
- **Use Natural Language:** No need to write SQL; the AI will translate.
- **Confirm Modifications:** For inserts, updates, or deletes, provide explicit confirmation when prompted.
- **Manage Token Usage:** External models may consume API tokens; monitor usage.
- **Leverage Examples:** Start with sample prompts to understand AI capabilities.

---

## 5. Troubleshooting Common Problems

Confirm your AI providers are configured correctly in the model dropdown. If tokens are required, make sure they are valid and environment variables are set. Refresh models by reselecting the provider.

Check the exact error message displayed. Common causes include malformed queries, schema mismatches, or provider connectivity issues. Retrying or switching models can help.

Ensure your query specifies enough filtering criteria. Check that your database schema is up to date and accessible.

AI chat depends on external API responsiveness. Network issues or API rate limits impact performance. Try again after some time or switch to a local model if available.

Use the "New Chat" button to clear old context if conversations become inconsistent.

---

## 6. Next Steps and Additional Resources

- Explore the [Using the Scratchpad and Raw Query Executor](/guides/ai-and-natural-language/scratchpad-and-raw-sql) guide for advanced query editing.
- Learn more about [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database) to ensure your schema is properly configured.
- Review [Troubleshooting Common Issues](/getting-started/troubleshooting/troubleshooting-common-issues) if you encounter persistent problems.
- For Enterprise Edition users, explore how [Visual Data Charts](https://whodb.com/docs/usage-houdini/what-is-houdini) leverage AI conversation for deeper insights.

---

### Illustrative Workflow Diagram

```
flowchart TD
  U["User"] --> |"Select AI Provider & Model"| UI["AI Chat Interface"]
  UI --> |"Submit Query"| AI["AI Model (Ollama, ChatGPT, Anthropic)"]
  AI --> |"Generate SQL/Text Response"| Plugin["Chat Plugin & Query Engine"]
  Plugin --> DB["Connected Database"]
  DB --> Plugin
  Plugin --> UI
  UI --> U

  subgraph Conversation Flow
    UI --> UI
    AI --> AI
  end

  classDef external fill:#f9f,stroke:#333,stroke-width:2px;
  class AI external;
```

This flow illustrates how your natural language query progresses through model selection, AI interpretation, database execution, and response presentation.

---

For detailed technical background, see the [Conversational AI Integration Concept](https://whodb.com/concepts/integration-patterns/ai-integration) and the [System Architecture Overview](/overview/architecture-concepts-group/system-architecture-overview) sections.

---

*End of Guide*

---


# guides/ai-and-natural-language/scratchpad-and-raw-sql.mdx
## Using the Scratchpad and Raw Query Executor

A hands-on guide to the scratchpad (Jupyter notebook-like) feature and the raw execution page. Execute SQL, analyze plans, organize queries, and capture history for advanced exploratory data tasks.

# Using the Scratchpad and Raw Query Executor

## Overview

The Scratchpad and Raw Query Executor page in WhoDB offers a powerful, interactive workspace where you can write and execute raw SQL queries or analyze query plans directly. Inspired by Jupyter notebooks, this feature is designed for advanced exploratory data analysis, letting you organize multiple queries in individual cells or pages, inspect execution results, and track query history—all within a seamless user interface.

This guide will walk you through using the scratchpad environment to execute SQL queries, run query analysis (if supported), manage multiple pages of queries, and explore query results efficiently.

---

## Prerequisites

- **Connected Database:** You must be logged in to WhoDB with an active connection to a database that supports raw SQL execution.
- **Database Support for Scratchpad:** The feature is available for databases that support the scratchpad (e.g., PostgreSQL, SQLite3; Redis disables this feature).
- **Familiarity with SQL:** This is intended for users comfortable writing raw SQL queries.
- **Enterprise Edition Features (Optional):** Query analysis capabilities require the Enterprise Edition and support for the 'analyzeView' feature on your database type.

---

## What You Will Achieve

By following this guide, you will be able to:

- Use multiple interactive query cells to write and run SQL statements.
- Switch between different modes: normal query execution or query plan analysis.
- Add, delete, and organize query cells and pages for better workflow management.
- View tabular results with pagination or visual query plans.
- Copy, edit, rerun past queries from the history for efficient experimentation.

---

## Interface Overview

- **Pages Tabs:** Multiple scratchpad pages allow separation of query sets, each named for easy reference.
- **Query Cells:** Each page consists of one or more query cells where SQL code is written.
- **Mode Toggle:** Switch between "Query" execution and "Analyze" mode (when supported).
- **Execution Controls:** Run queries, clear input, add new cells, or delete cells.
- **Result Display:** Outputs show query results in tables or query plans visualized with graphs.
- **History Panel:** Toggle visibility to access recent queries with status indicators.

---

## Step-by-Step Instructions

### 1. Accessing the Scratchpad

- Open WhoDB and navigate to the **Scratchpad and Raw Query Executor** page via the main menu or from the Dashboard Scratchpad button.
- You will land on "Page 1" with a single editable query cell ready for your input.

### 2. Writing and Running Queries

- Click inside the query cell editor to type your SQL statement. Example:

```
SELECT * FROM public.users WHERE active = TRUE LIMIT 10;
```

- Press the **Submit** button or use the run command in the editor to execute the query.

- The executed query appends to the page history; results display below the cell:
  - For SELECT queries, a paginated results table appears.
  - For other statements (INSERT, UPDATE, DELETE), a confirmation message shows execution success.

### 3. Switching Modes (Query vs Analyze)

- Use the mode toggle on the left of each cell to switch:
  - **Query** mode runs the SQL normally.
  - **Analyze** mode runs query explanation plans (only for supported DBs like PostgreSQL).

- When in Analyze mode and if enabled, the results show an interactive JSON-based graphical representation of execution plans.

### 4. Managing Query Cells

- **Add a Cell:** Click the 'Add' button to insert a new query cell immediately after the current one.
- **Delete a Cell:** Use the delete option to remove a cell (disabled if there is only one cell).
- **Clear Cell:** Reset the current cell content with the Clear button.

### 5. Navigating and Organizing Pages

- Scratchpad supports multiple "pages" to separate different query workflows.
- **Add a Page:** Use the add page button near the tab bar to create a new page.
- **Select a Page:** Click a page tab to switch the active page and work on its queries.
- **Rename a Page:** Double-click the page name in the tab to edit.
- **Delete a Page:** Use the cancel icon on the tab (disabled if only one page exists).

All changes are maintained in local state for fluid switching.

### 6. Using Query History

- Toggle the **history view** within each cell to list prior submitted queries on that page.
- Each history item shows success (green) or failure (red).
- Click a history item to:
  - Load that query back into the editor for editing.
  - Execute it again immediately.
  - Copy it to clipboard.

### 7. Copying Query Text

- Use the clipboard icon to copy the current query or any history item for external use or sharing.

---

## Practical Examples

### Example 1: Simple Select Query

```
SELECT id, name FROM employees WHERE department = 'Sales' LIMIT 20;
```
- Write in the editor.
- Run in Query mode.
- View paginated results below.

### Example 2: Analyzing a Query Plan (Postgres)

```
SELECT * FROM orders WHERE order_date >= '2024-01-01';
```
- Switch to Analyze mode.
- Execute query.
- Inspect the visualized execution graph depicting index scans and joins.

### Example 3: Using Multiple Pages

- Create Page 1 with analysis queries.
- Create Page 2 for data-modification queries (INSERT, UPDATE).
- Switch between pages to separate concerns and avoid mixing query contexts.

---

## Tips and Best Practices

- **Write simple, focused queries per cell** to keep execution and results manageable.
- **Clear unused cells** to declutter the workspace.
- **Use the history panel often** to recycle and iterate on previous queries.
- **Name pages meaningfully** to mirror your project or analysis stages.
- For databases that don’t support analysis mode, all queries run in Query mode.

---

## Troubleshooting

### Common Issues and Solutions

| Problem                            | Cause                                                 | Solution                                                |
|----------------------------------|-------------------------------------------------------|---------------------------------------------------------|
| Query returns error message       | SQL syntax error or invalid query                      | Verify SQL syntax; consult database docs for query format |
| Analyze mode is unavailable       | Feature not enabled or unsupported database            | Confirm Enterprise Edition and DB type (Postgres supported) |
| Results table shows no data       | Query executed but no rows matched                      | Adjust your WHERE clause or data filters                    |
| History not updating              | Temporary UI glitch                                    | Reload the page; history is session-bound                  |
| Cells or pages not adding/deleting | Minimum one cell/page enforced                         | Must have at least one active cell and one page            |

---

## Next Steps & Related Documentation

- Explore the [Exploring and Managing Data](https://whodb.com/guides/essential-workflows/exploring-and-managing-data) guide to learn more about inline data editing.
- Use the [Conversational AI & Querying with AI Chat](https://whodb.com/guides/ai-and-natural-language/conversational-queries-and-ai-models) guide to query databases with natural language.
- For database schema visualization, consult the [Visualizing Your Database Schema](https://whodb.com/guides/essential-workflows/visualizing-your-database-schema) page.
- Review [Connecting to Your Database](https://whodb.com/guides/essential-workflows/connecting-to-your-database) if you need to establish or modify database connections.

---

---


# guides/best-practices-and-optimization/working-efficiently-with-large-datasets.mdx
## Working Efficiently with Large Datasets

Tips and techniques for leveraging WhoDB’s performance optimizations, such as table virtualization, lazy loading, and pagination. Best suited for administrators and power users handling enterprise-sized databases.

# Working Efficiently with Large Datasets in WhoDB

Optimize your experience managing enterprise-sized databases in WhoDB by leveraging its powerful performance features, including table virtualization, lazy loading, and pagination. This guide empowers database administrators and power users to navigate and manipulate large datasets seamlessly without compromising speed or responsiveness.

---

## 1. Understanding the Challenges

Handling vast amounts of data within any UI-oriented database management tool can quickly become slow and resource-intensive. Rendering thousands or millions of rows at once not only overwhelms your browser but also degrades the user experience.

WhoDB addresses these challenges by implementing advanced optimizations designed specifically for large datasets, ensuring that even enterprise-level databases remain snappy and responsive.

---

## 2. Key Performance Features in WhoDB

### Table Virtualization

- **What it is:** Instead of rendering all table rows, WhoDB dynamically renders only the rows visible in the viewport.
- **Benefit:** Massive performance boost by drastically reducing DOM elements.
- **User impact:** Scrolling remains smooth regardless of table size.

### Lazy Loading with Pagination

- **What it is:** Data is fetched and loaded incrementally in pages rather than all at once.
- **Benefit:** Limits memory consumption and reduces network load.
- **User impact:** You can control page size, request more data on demand, and keep the interface responsive.

### Incremental Data Fetching

- **Integrated with:** Filters and search operations to load only necessary data chunks.
- **Outcome:** Avoids loading huge datasets unnecessarily when refining queries.

---

## 3. How to Work with Large Datasets in WhoDB

### Step 1: Access Your Data Table
- Navigate to the **Tables** page in the sidebar.
- Select your desired storage unit (table or collection) to explore the data.

### Step 2: Configure Page Size
- At the top of the data view, set the **Page Size** to control how many rows load per page.
- Default is 10 rows, but you can increase this (e.g., 50, 100, or up to 1000) depending on your system capabilities.

### Step 3: Use Pagination Controls
- Use the pagination bar below the table to navigate between pages.
- Change pages to fetch the next batch of rows lazily, avoiding loading all data simultaneously.

### Step 4: Apply Filters and Searches
- Use the filter panel to build where conditions that narrow results incrementally.
- Filters request only relevant data subsets by the backend, reducing client workload.

### Step 5: Benefit from Virtualized Scrolling
- Scrolling through tables with thousands of rows stays fluid as WhoDB renders only visible rows.
- This allows you to browse large datasets without any UI freezes or sluggishness.

### Step 6: Export Efficiently
- When ready to export large filtered results, use the **Export** button.
- Export works on the currently loaded data or filtered subset, making it manageable and fast.

---

## 4. Practical Tips & Best Practices

- **Choose optimal page size:** Larger page sizes load more data but can increase memory usage and initial load times. Test to find a balanced size.
- **Leverage filtering early:** Apply precise filters before loading to keep the working dataset small.
- **Avoid unneeded columns:** Narrow down visible columns through schema exploration for lighter data rendering.
- **Use lazy loading with purpose:** When scrolling, pause occasionally to allow data fetching to complete before pushing further.
- **Monitor network and browser:** Large pages or inefficient queries can impact backend and frontend - optimize queries for speed.

---

## 5. Common Pitfalls and Troubleshooting

### Pitfall 1: UI freezing when loading very large pages
- **Cause:** Page size too large or heavy complex query filters
- **Solution:** Reduce the page size or simplify queries. Use filtering before pagination.

### Pitfall 2: Incorrect or slow filtering results
- **Cause:** Filters may be applied client-side if backend lacks support
- **Solution:** Confirm backend supports filtering capabilities. Check database plugin limits.

### Pitfall 3: Export timing out or incomplete
- **Cause:** Attempting to export too large unfiltered datasets
- **Solution:** Filter data before export and use smaller page chunks.

### Pitfall 4: Virtualized rows not rendering correctly
- **Cause:** Browser or UI state inconsistencies.
- **Solution:** Refresh page, or adjust page size and sorting filters.

---

## 6. Advanced Use Case: Combining Scratchpad with Large Dataset Exploration

- Use the **Scratchpad** page to write and run raw SQL queries that include pagination clauses.
- You can manually control `LIMIT`, `OFFSET`, or equivalent clauses to fetch slice segments exactly.
- Submit queries to backends and receive manageable chunks.
- Combine this with WhoDB’s filters and schema insights for powerful targeted data analysis.

---

## 7. Summary of Your Workflow

1. Navigate to the Tables page and select your storage unit.
2. Adjust page size to an optimal number.
3. Apply filters early to limit data scope.
4. Use pagination to fetch data lazily.
5. Scroll smoothly via built-in table virtualization.
6. Export carefully filtered, paged data.
7. Use Scratchpad for customized raw queries if needed.

---

## 8. Related Documentation & Next Steps

- [Connecting to Your Database](../essential-workflows/connecting-to-your-database) — Learn how to connect databases to WhoDB.
- [Exploring and Managing Data](../essential-workflows/exploring-and-managing-data) — Master browsing, filtering, editing, and adding data.
- [Using the Scratchpad and Raw Query Executor](../ai-and-natural-language/scratchpad-and-raw-sql) — For crafting custom SQL queries beyond UI controls.
- [Visualizing Your Database Schema](../essential-workflows/visualizing-your-database-schema) — Explore relationships and data models visually.

Working with large datasets is smoothest when combining filtering with pagination and virtualization — always narrow your dataset before loading.

Avoid trying to load or export extremely large datasets in one go; break tasks into manageable chunks for best performance.

---


# guides/best-practices-and-optimization/security-and-authentication.mdx
## Security and Authentication Essentials

Guidelines for managing user credentials, session security, safe authentication flows, and best practices for running WhoDB in production environments.

# Security and Authentication Essentials

## Overview
This guide provides practical instructions and best practices for managing user credentials, ensuring session security, implementing safe authentication flows, and maintaining secure operation of WhoDB in production environments. It focuses exclusively on the authentication and security aspects within WhoDB’s web application layer.

## Prerequisites
- You must have WhoDB installed and running.
- Familiarity with basic web application operations.
- Access to WhoDB’s login interface or API gateway configuration.
- Administrator or user roles that can manage login profiles.

## Expected Outcome
By following this guide, you will understand how to securely log in and log out of WhoDB, manage authentication tokens, configure session security, and apply best practices for running WhoDB safely in production.

## Time Estimate
Approximately 15-25 minutes depending on familiarity with authentication concepts.

## Difficulty Level
Intermediate: Requires understanding of authentication flows, session management, and production security concerns.

---

## 1. Understanding Authentication Flow in WhoDB
WhoDB uses a token-based authentication system combined with session cookies or API gateway tokens to securely manage user credentials and sessions.

- **Login:** Users provide database credentials or select saved profiles via the login page.
- **Token Generation:** Credentials are encoded into a base64 string and stored either in a cookie or passed via Authorization headers.
- **Token Validation:** On each API request, the token is decoded and validated to ensure the session is authorized.
- **Logout:** Invalidates the session by clearing the token and profile data.

### How It Works Behind the Scenes
When a request arrives, the `AuthMiddleware` examines the route:

- Public routes allow unauthenticated access.
- Protected routes require a valid authentication token.
- Tokens are validated either from a cookie (`Token`) or an Authorization header (for API Gateway setups).
- Profile credentials tied to tokens are resolved and attached to request context for authorization checks.

Understanding this flow ensures that security mechanisms work seamlessly with WhoDB's UI and API requests.

---

## 2. Logging In to WhoDB

### Step 1: Navigate to the Login Page
- Open your browser and go to `https://your-whodb-instance/login`.

### Step 2: Choose Your Database Type
- Select from supported databases (e.g., MySQL, PostgreSQL, SQLite, MongoDB).
- The form dynamically adjusts required fields based on this selection.

### Step 3: Enter Connection Credentials
- Provide hostname, database name, username, and password as applicable.
- For PostgreSQL or MongoDB, you can paste a connection URL, and WhoDB will parse the details automatically.

### Step 4: Configure Advanced Settings (Optional)
- Click the 'Advanced' button to reveal extra connection options (e.g., port, SSL mode).
- Modify only if you understand the connection details.

### Step 5: Submit Credentials
- Click the 'Submit' button to authenticate.
- On success, you will be redirected to the storage unit dashboard.

### Step 6: Using Saved Profiles
- If you have saved login profiles, select one from the 'Available profiles' dropdown.
- Click 'Login' to authenticate with stored credentials.

Successful login shows a notification and takes you to the data exploration page.

### Common Pitfalls
- Leaving required fields empty triggers validation errors.
- Incorrect credentials result in login failure notifications.
- Connection URL parsing might fail if the URL is malformed.

Never share your passwords or connection URLs publicly. Use secure channels for credential sharing.

---

## 3. Session Security and Token Management

### Token Storage
- WhoDB stores authentication tokens in HTTP cookies for browser sessions.
- In API Gateway mode, tokens are passed in HTTP `Authorization` headers prefixed by `Bearer `.

### Token Validation
- Tokens are base64 encoded JSON containing user and connection info.
- Each API request verifies token integrity and expiration.
- Invalid, missing, or malformed tokens cause an immediate `401 Unauthorized` response.

### Token Expiry and Revocation
- Tokens validated against a whitelist in `env.Tokens` for API gateway scenarios.
- Logout explicitly clears stored tokens to prevent reuse.

Token validation is a critical security step ensuring only authorized users access WhoDB.

---

## 4. Logging Out of WhoDB

### Step 1: Initiate Logout
- Click the logout button or navigate to `https://your-whodb-instance/logout`.

### Step 2: Logout Process
- The system executes a GraphQL mutation to clear session tokens.
- Session data is cleared from local storage and cookies.

### Step 3: Confirmation
- A notification confirms successful logout.
- The user is redirected to the login page.

After logout, any attempt to access protected routes redirects to login.

---

## 5. Best Practices for Running WhoDB in Production

### Secure Credential Storage and Access
- Ensure environment variables or external vaults securely store sensitive tokens and credentials.
- Do not hard-code credentials or expose them in logs.

### Limit Access Through Network Controls
- Restrict WhoDB access using firewalls, VPNs, or API gateways.
- Use HTTPS to encrypt all traffic and protect credential transmissions.

### Token and Session Management
- Regularly rotate tokens and credentials.
- Enforce session timeouts and inactivity logout.

### Configuration Management
- Enable strict CORS policies to control allowed origins.
- Monitor logs for unauthorized access attempts.

### Monitoring & Alerts
- Implement alerting on failed login attempts or unusual authentication patterns.

Running WhoDB with default settings in a production environment can expose sensitive data if best practices are not followed.

---

## 6. Troubleshooting Common Issues

Ensure all required fields for your database type are complete before submitting. For database URLs, verify the format and completeness.
Check that your token is being set in cookies or Authorization header properly. If behind an API Gateway, ensure token validation is enabled and tokens are registered.
Requests exceeding 1MB are blocked by middleware. Optimize payload size or check for malformed requests.
Verify cookies are properly cleared. Browser settings or extensions could block cookie removal.

Use browser developer tools to inspect HTTP headers, cookies, and network requests during login and logout flows to diagnose issues.

---

## 7. Summary Diagram of Authentication Flow

```
flowchart TD
  Start([User accesses WhoDB]) --> CheckPublicRoute{Is route public?}
  CheckPublicRoute -- Yes --> PublicAccess[Allow access without authentication]
  CheckPublicRoute -- No --> CheckToken[Check Authorization Token]
  CheckToken -->|Token missing| Unauthorized[Return 401 Unauthorized]
  CheckToken -->|Token present| DecodeToken[Decode and validate token]
  DecodeToken -->|Invalid token| Unauthorized
  DecodeToken -->|Valid token| FetchProfile[Retrieve user credentials]
  FetchProfile --> AuthorizedAccess[Allow request to proceed]
  AuthorizedAccess --> ProcessRequest[Execute user requested API or UI action]
  ProcessRequest --> End[Response returned]

  StartLogout([User clicks logout]) --> SendLogoutMutation[Send Logout GraphQL mutation]
  SendLogoutMutation --> ClearSession[Clear cookies and session data]
  ClearSession --> RedirectLogin[Redirect to Login page]

  Unauthorized -.->|Attempt access| RedirectLogin
```

---

## Related Documentation
- [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database) — for securing database credentials.
- [Troubleshooting Common Issues](/getting-started/troubleshooting/troubleshooting-common-issues) — for resolving authentication errors.
- [Initial Configuration](/getting-started/initial-config-launch/initial-configurations) — for setting environment variables and enabling API gateway mode.
- [Logout Implementation Details](/frontend/src/pages/auth/logout.tsx) — for understanding client-side logout.

## Next Steps
- Review production deployment security guidelines.
- Enable HTTPS and configure CORS for your deployment.
- Implement regular security audits and log monitoring.

This guide centralizes security and authentication user needs, empowering you to safely manage access and credentials in WhoDB.

---


# concepts/architecture-overview/system-architecture.mdx
## System Architecture Overview

Discover how WhoDB is architected for agility, speed, and extensibility. Learn about the separation of frontend and backend services, communication patterns, and the embedding of static frontend assets for seamless deployment. This overview highlights the modular nature of the system and its ability to support both Community and Enterprise Editions with minimal friction.

# System Architecture Overview

Discover how WhoDB is architected to deliver a fast, extensible, and agile database management experience through modular separation of frontend and backend components, seamless integration of static assets, and flexible support for Community and Enterprise Editions.

---

## Introduction

WhoDB is designed with a clear focus on user productivity, extensibility, and ease of deployment. This system architecture overview presents how WhoDB separates concerns between the interface and server logic, enabling rapid iteration and scalability. Key architectural decisions emphasize embedding frontend assets for smooth deployment and maintaining a modular backend that supports multiple database types alongside integrated AI-driven features.

Whether you’re installing WhoDB for evaluation or deploying it in production, understanding this architecture will help you configure, troubleshoot, and extend the platform effectively.

---

## Core Architectural Components

### Frontend (UI Client)

- **Role & Responsibilities:**
  The frontend is a React-based single-page application (SPA) built with TypeScript, responsible for providing an intuitive and responsive user interface. It handles user interactions, renders complex database visualizations, facilitates conversational AI queries, and manages inline data editing.

- **Technology Stack:**
  - React with TypeScript
  - Vite for building and development
  - TailwindCSS for theming and styling
  - Apollo GraphQL Client for API communication

- **Static Asset Embedding:**
  Once built, the frontend static files are embedded into the backend server binary. This means the server serves the UI directly, simplifying deployment with no separate frontend server needed.

- **Dynamic Edition Support:**
  The frontend integrates dynamic import strategies and build-time environment variables to support both Community Edition (CE) and Enterprise Edition (EE) features from a single codebase, enabling seamless transitions between editions without disrupting user experience.

### Backend (API Server)

- **Role & Responsibilities:**
  The backend manages database connections, handles API requests from the frontend, executes AI integrations, and provides a plugin architecture for database extensibility. It parses and orchestrates queries, manages security, and consolidates data for UI consumption.

- **Technology Stack:**
  - Go language backend for performance
  - GraphQL API to provide a unified interface for frontend queries
  - Embedded frontend assets to serve UI
  - Plugin mechanisms for community and enterprise database connectors

- **Edition Flexibility:**
  Supports both CE and EE through build tags and modular code separation, allowing features such as advanced database connectors and enhanced security to be included in EE with minimal friction.

---

## User Request Flow

Understanding the path of a user request clarifies how the components interact to provide a cohesive experience.

1. **User Interaction:**
   Users interact with the React frontend served by the backend server.

2. **GraphQL Queries:**
   The frontend sends GraphQL queries or mutations to the backend API for database metadata, data retrieval, updates, or AI-enhanced requests.

3. **Backend Processing:**
   The backend validates and processes the requests, delegates to database plugins or AI integrations as needed.

4. **Data Aggregation:**
   Results are marshaled into GraphQL responses and sent back to the frontend.

5. **UI Rendering:**
   The frontend updates the interface, showing updated data visualizations, query results, or AI conversational outputs.

This cycle happens rapidly, enabling smooth user workflows from schema visualization to conversational querying.

---

## Modularity & Extensibility

WhoDB's architecture is designed for growth:

- **Plugin Engine:**
  The backend supports plugin-based database connectors, allowing future databases to be added with minimal core changes. Plugins handle the nuances of each database’s query dialects and schema structures.

- **AI Integration Points:**
  AI providers like Ollama, OpenAI, and Anthropic are integrated through modular interfaces, allowing users to select models and providers dynamically.

- **Frontend Component Loading:**
  EE-exclusive components and features are dynamically loaded through controlled imports, maintaining a lean CE footprint.

- **Theme and UI Extensions:**
  The frontend supports theme customization and component extension points, enabling organizations to tailor visuals and UX flow.

---

## Deployment and Build Strategy

### Frontend Build Embedding

- **Build Process:**
  The frontend React app is built using Vite into static assets.

- **Embedding:**
  These static files are copied into the backend source and embedded using Go’s embed functionality during the backend build process.

- **Result:**
  The final backend binary acts as a standalone executable, not requiring additional web server configuration.

### Separate Builds for CE and EE

- Environment variables (`VITE_BUILD_EDITION`) govern feature sets.
- GraphQL type generation adapts dynamically to the edition.
- Backend uses Go build tags (`ee`) for EE.

### Docker Support

- Dockerfiles support both CE and EE with entrypoint scripts that serve the embedded UI and backend API.
- Multi-architecture builds and Docker Compose setups allow easy deployment.

---

## Visual Diagram

```
flowchart TD
  subgraph Frontend
    UI["React UI (SPA)"]
    UI -->|GraphQL Requests| API["Backend GraphQL API"]
  end

  subgraph Backend
    API --> DBPlugins["Database Plugins (e.g., MySQL, PostgreSQL, MongoDB)"]
    API --> AIIntegration["AI Integration Module (Ollama, OpenAI, Anthropic)"]
    API --> EmbedFrontend["Embedded Frontend Static Assets"]
  end

  DBPlugins --> DB["Databases"]
  AIIntegration --> LLM["Language Models"]

  subgraph Deployment
    Backend["Go Backend Server Binary"]
    Backend -->|Serves| UI
  end

  %% Relationships
  API -.-> Backend
```

---

## Practical Tips for Users

- **Single Binary Convenience:**
  Run the backend executable after building or installing, which serves both your API and UI.

- **Seamless Edition Switching:**
  Choose CE or EE at build time without needing separate UI deployments.

- **Plugin Extensibility:**
  When connecting new databases, understand the plugin approach that isolates connector logic.

- **AI Features:**
  AI-powered features are integrated as services behind the GraphQL API, allowing expanded capabilities without frontend complexity.

- **Monitoring:**
  Use backend logs to trace request handling, especially when diagnosing connection or query issues.

---

## Troubleshooting Common Scenarios

- **Frontend Not Loading:**
  Verify the backend binary includes the embedded frontend assets. If missing, rebuild frontend, copy assets, then rebuild backend.

- **Edition Feature Mismatch:**
  Confirm your build environment variable `VITE_BUILD_EDITION` matches the backend build tag (`ee` for Enterprise), aligning frontend and backend.

- **Database Plugins Failing:**
  Check plugin configurations and database credentials. Refer to plugin documentation per specific database.

- **GraphQL Schema Mismatches:**
  Always regenerate GraphQL types after backend schema changes to avoid frontend type errors.

---

## Further Reading

Explore related documentation for deeper understanding and workflows:

- [Connecting to Your Database](../guides/essential-workflows/connecting-to-your-database)
- [Core Concepts and Terminology](../overview/architecture-concepts-group/core-concepts-and-terminology)
- [Plugin Engine & Database Integration](./plugin-engine)
- [Request Lifecycle & Data Flow](./data-flow)
- [Conversational AI Integration](../concepts/integration-patterns/ai-integration)

---

## Summary

WhoDB’s system architecture balances modularity and simplicity by separating frontend UI and backend server while embedding static assets for straightforward deployment. The architecture’s extensibility supports diverse databases, flexible AI integration, and edition-specific features with minimal overhead, enabling users to manage data efficiently and scale with evolving needs.

---

For a successful start, ensure you follow the prescribed build and deployment workflow: build frontend → embed → build backend. Synchronize edition settings between backend and frontend for a seamless experience.

---

## Source Code Reference

You can explore the main backend build and frontend configuration files at:

- [core/Dockerfile (build process)](https://github.com/clidey/whodb/blob/main/core/Dockerfile)
- [frontend/vite.config.ts (frontend build config)](https://github.com/clidey/whodb/blob/main/frontend/vite.config.ts)
- [Build and Run Guide](https://github.com/clidey/whodb/blob/main/BUILD_AND_RUN.md)

These files anchor the architectural design in practical implementation.

---


# concepts/architecture-overview/plugin-engine.mdx
## Plugin Engine & Database Integration

Explore how WhoDB enables deep database interoperability through its unified plugin engine. Understand the structure and responsibilities of different plugins (e.g., Postgres, MySQL, MongoDB, Redis, Elasticsearch), how they are registered into the core engine, and how they expose database capabilities to the higher layers. See how CE versus EE plugin loading works.

# Plugin Engine & Database Integration

Welcome to the core of WhoDB's flexibility and power: the Plugin Engine. This page explains how WhoDB unifies diverse database technologies through a sophisticated plugin architecture, enabling you to seamlessly explore, query, and manage a wide variety of data sources under one intuitive interface.

---

## Why the Plugin Engine Matters

Imagine managing multiple databases—PostgreSQL, MySQL, MongoDB, Redis, Elasticsearch—all with distinct query languages, schemas, and operational nuances. Without a standard approach, juggling these systems requires toggling different tools and syntaxes, risking errors and inefficiency.

WhoDB's plugin engine resolves this by acting as a centralized adapter hub. Each plugin encapsulates the logic needed to communicate with a specific database type, abstracting connection details, querying, and schema introspection into a consistent experience. Whether you're working with relational tables, document stores, or key-value data, the Plugin Engine exposes a unified set of capabilities to the application layers.

This seamless interoperability is the backbone that enables WhoDB’s AI integration, schema visualization, conversational querying, and inline data editing.

---

## Core Architecture and Design

At its heart, the plugin engine is structured around WhoDB's `engine.Engine` object. This engine maintains a registry of plugins, each representing a database technology and implementing a common interface to perform core operations.

### Plugin Registration

Upon startup, WhoDB initializes the main engine and registers the Community Edition (CE) plugins for supported databases. These plugins include:

- PostgreSQL
- MySQL and MariaDB
- SQLite3
- MongoDB
- Redis
- Elasticsearch
- ClickHouse

For Enterprise Edition (EE) builds, the engine loads additional or enhanced plugins dynamically, extending capabilities to cover enterprise-grade features and proprietary integrations.

### Plugin Interface Responsibilities

Each plugin implements a standardized set of functions enabling WhoDB to:

- Retrieve available databases and schemas.
- List and describe storage units (tables, collections, indices).
- Query data with support for pagination and filtering.
- Add, update, and delete rows or documents.
- Execute raw queries and expose data results.

This consistent interface allows the WhoDB UI and backend to interact with heterogeneous databases without bespoke logic per type.

### Plugin Functions Overview

The key plugin functions are:

| Function                  | Purpose                                   |
|---------------------------|-------------------------------------------|
| `GetDatabases`            | Lists databases available on the server  |
| `GetAllSchemas`           | Returns all schemas in the database       |
| `GetStorageUnits`         | Retrieves tables, collections, or indices|
| `GetRows`                 | Fetches data rows/documents based on filters|
| `AddStorageUnit`          | Creates new tables or collections         |
| `AddRow`                  | Inserts a new row or document              |
| `UpdateStorageUnit`       | Updates metadata or structure              |
| `DeleteRow`               | Deletes rows or documents                  |
| `RawExecute`              | Runs a raw query and returns results      |
| `Chat`                    | Supports conversational AI query handling |

Not every plugin supports all operations; some may explicitly mark operations as unsupported if the underlying system lacks the feature.

---

## Plugin Examples

Let's explore how WhoDB implements and registers a few key plugins to illustrate their responsibilities.

### PostgreSQL Plugin

The PostgreSQL plugin leverages GORM (an ORM library Go) to interact with the database. It defines supported data types and SQL operators, and implements specialized queries to retrieve schema metadata and table info.

For example:

- The `GetAllSchemasQuery()` returns the information schema query to list schemas.
- `GetTableInfoQuery()` retrieves table names, types, sizes, and row counts.
- `GetRows()` retrieves paginated data with filtering support.

The plugin exposes raw SQL execution and conversion helpers to map SQL rows into the internal `GetRowsResult` format.

### MySQL/MariaDB Plugin

Similarly, the MySQL plugin builds upon the GORM plugin base with MySQL-specific SQL queries for schema and table info. It defines supported column types and SQL operators unique to MySQL.

Both the MySQL and MariaDB plugins are implemented as separate types but share the core `MySQLPlugin` codebase, showcasing extensibility.

### Elasticsearch Plugin

Unlike relational databases, the Elasticsearch plugin interacts with an HTTP client to communicate with the Elasticsearch REST API.

Key distinctions include:

- No direct support for listing databases or schemas.
- Storage units correspond to Elasticsearch indices.
- Querying translates internal filter conditions into Elasticsearch DSL JSON queries.
- Data results are returned as JSON documents.

Because Elasticsearch is a search engine, functionalities like raw SQL execution or conversational chat queries are marked as unsupported.

### Other Examples

WhoDB also supports:

- MongoDB via native client integrations.
- Redis for key-value data.
- ClickHouse for analytical columnar storage.
- SQLite3 as an embedded lightweight database.

Each plugin implements consistent but tailored logic to align with their database’s capabilities and interfaces.

---

## Community Edition vs. Enterprise Edition Plugin Loading

WhoDB defines a clear separation between Community Edition (CE) and Enterprise Edition (EE) features.

- The **Community Edition** includes core plugins for widely used open-source databases, ensuring a robust out-of-the-box experience.

- The **Enterprise Edition** enables advanced and proprietary plugins, loaded dynamically via a registration function enabled only in EE builds.

This extensibility mechanism allows EE deployments to add custom or enhanced database connectors, advanced security or query capabilities, and enterprise integrations without bloating the CE distribution.

Specifically, during engine initialization:

- The CE plugins register in the main engine unconditionally.
- If an EE initializer function is present, it runs to register EE-only plugins.

This design balances open access and commercial scalability gracefully.

---

## Visualizing the Plugin Engine Architecture

```
flowchart TD
  subgraph WhoDB Core
    Engine["Engine (Plugin Registry)"]
    UI["User Interface Layers"]
    API["Backend API Server"]
  end

  subgraph CE Plugins
    PostgresPlugin["PostgreSQL Plugin"]
    MySQLPlugin["MySQL / MariaDB Plugin"]
    SQLitePlugin["SQLite3 Plugin"]
    MongoPlugin["MongoDB Plugin"]
    RedisPlugin["Redis Plugin"]
    ElasticPlugin["Elasticsearch Plugin"]
    ClickHousePlugin["ClickHouse Plugin"]
  end

  subgraph EE Plugins
    EEPlugins["Enterprise Edition Plugins"]
  end

  UI --> API
  API --> Engine
  Engine --> PostgresPlugin
  Engine --> MySQLPlugin
  Engine --> SQLitePlugin
  Engine --> MongoPlugin
  Engine --> RedisPlugin
  Engine --> ElasticPlugin
  Engine --> ClickHousePlugin
  Engine --> EEPlugins

  classDef core fill:#005f73,stroke:#0a9396,stroke-width:2px,color:#fff
  classDef plugins fill:#94d2bd,stroke:#0a9396,stroke-width:1px

  class Engine,UI,API core
  class PostgresPlugin,MySQLPlugin,SQLitePlugin,MongoPlugin,RedisPlugin,ElasticPlugin,ClickHousePlugin,EEPlugins plugins
```

This diagram presents how the WhoDB core engine interfaces with diverse plugins, allowing the UI and API layers to remain agnostic of underlying database details.

---

## Best Practices and Usage Tips

- **Choose Plugin per Database Type:** When connecting a database, WhoDB automatically selects the appropriate plugin supporting that database type.

- **Leverage Standardized Capabilities:** Use core operations like schema browsing, data querying, and row editing through the unified interface, trusting the plugin abstraction.

- **Expect Some Limitations per Backend:** Not all backends support all operations (e.g., Elasticsearch does not support raw SQL). Refer to plugin documentation for supported features.

- **Configure Credentials Carefully:** The plugin engine uses supplied credentials to manage connections securely; ensure proper roles and permissions on the database side.

- **Enterprise Edition Users:** Utilize dynamic EE plugins for advanced integrations; keep the CE and EE plugins updated to maximize WhoDB’s extensibility.

- **Troubleshooting:** If encountering unexpected behavior with a database, verify which plugin is selected and consult logs for the plugin’s internal errors.

---

## Troubleshooting Common Plugin Issues

- **Plugin Not Found or Not Loaded:** Confirm your edition (CE vs EE) and that plugins for your database type are registered during initialization.

- **Unsupported Operations Errors:** Some plugins (e.g., Elasticsearch) do not support certain features like raw SQL queries or chat. Check the error messages for clear indications.

- **Connection Failures:** Credentials or network issues can prevent plugin connectivity. Verify host, port, authentication, and networking.

- **Schema or Data Not Appearing:** Plugins rely on database metadata queries; verify the user’s permissions and database health.

- **Plugin Version Mismatch:** Use compatible versions of WhoDB core and plugins to avoid interface changes causing failures.

For detailed steps, refer to the [Connecting to Your Database](https://who-db-docs/guides/essential-workflows/connecting-to-your-database) guide.

---

## Summary

This page introduced the WhoDB Plugin Engine as the pivotal abstraction layer enabling seamless integration with multiple database systems. It detailed plugin responsibilities, CE versus EE plugin handling, and demonstrated the engine’s role in producing a unified data management experience.

Continue your exploration with:

- [System Architecture Overview](https://who-db-docs/concepts/architecture-overview/system-architecture) — understand the entire system.
- [Connecting to Your Database](https://who-db-docs/guides/essential-workflows/connecting-to-your-database) — learn to connect specific databases.
- [Integrations and Extensibility](https://who-db-docs/overview/architecture-concepts-group/integration-overview) — dive into AI and plugin extensibility.

If you are an Enterprise user, explore your plugin options and deployment strategies documented separately.

---

For developers and integrators, source code for plugins and engine initialization can be found in the core repository under `/core/src/plugins` and `/core/src/src.go`.

---

---


# concepts/architecture-overview/data-flow.mdx
## Request Lifecycle & Data Flow

Trace the journey of a user action—from the user interface (React frontend), through GraphQL API calls, backend routing, plugin invocation, to eventual data transformation and visualization. This page maps typical data flows such as executing a chat query, fetching table rows, or visualizing schema graphs.

# Request Lifecycle & Data Flow

Understanding the journey of your actions within WhoDB—from input through UI to final data visualization—is crucial to mastering the product. This page traces how user requests propagate through the system, highlighting key components, communication points, and data transformations. By following typical scenarios like executing a chat query, fetching table rows, or visualizing the database schema graph, you will gain clarity on what happens behind the scenes to achieve your goal.

---

## Overview of the Request Lifecycle

Every user interaction with WhoDB initiates a request journey that passes through several layers:

1. **User Interface (React Frontend)**: You type SQL queries, interact with tables, or navigate schema graphs.
2. **GraphQL API Calls**: The frontend sends GraphQL queries or mutations via Apollo Client.
3. **Backend Server Routing**: The Go backend receives requests, authenticates, and routes them.
4. **Plugin Invocation & Database Interaction**: Dedicated database plugins handle connecting, querying, and transforming data.
5. **Response Processing & Visualization**: The backend returns results to the frontend, where data is rendered or visualized.

This flow ensures a transparent, efficient, and flexible user experience.

---

## User Interface Initiation

### 1. Raw Query Execution Flow

- Users write raw SQL or analysis commands inside the **Scratchpad** (Raw Execute page).
- The UI component `RawExecuteCell` manages queries, toggles between `Query` or `Analyze` modes, and maintains query history for replay.
- Queries are wrapped appropriately for analysis (e.g., prefixing with `EXPLAIN (ANALYZE, FORMAT JSON)` for PostgreSQL).
- When submitted, the UI uses a lazy GraphQL query hook `useRawExecuteLazyQuery` to send the request.

### 2. Exploring Storage Units

- On the **Explore Storage Unit** page, users set filters and pagination parameters for rows.
- Query construction includes where conditions, page size, and page offset.
- GraphQL lazy queries like `useGetStorageUnitRowsLazyQuery` fetch filtered results.
- Inline editing actions invoke mutations to update or delete rows.

### 3. Visualizing the Schema Graph

- The **Graph Page** fetches graph structure data using `useQuery` with the `GetGraphDocument` query.
- Nodes and edges representing storage units and their relationships are created and managed via ReactFlow.
- Layout is handled with the Dagre algorithm integrating through `getDagreLayoutedElements`.

---

## Communication via GraphQL API

WhoDB's frontend uniformly interacts with the backend through GraphQL:

- **Queries** fetch data like raw results, schema graphs, storage units, or AI chat responses.
- **Mutations** modify storage units, add or delete rows, or update settings.

Example query flow in raw execute:

```
rawExecute({ variables: { query: fullQuery }, onCompleted() { /* update UI */ } });
```

Key GraphQL schema types you will encounter:

- `RawExecute(query: String!): RowsResult!` — Execute arbitrary SQL.
- `Row(schema: String!, storageUnit: String!, where: WhereCondition, pageSize: Int!, pageOffset: Int!): RowsResult!` — Query paginated rows.
- `Graph(schema: String!): [GraphUnit!]!` — Retrieve graph data for schema visualization.

This uniform interface simplifies adding new integrations and features.

---

## Backend & Plugin Layer Handling

Upon receiving GraphQL requests, the backend:

- Verifies authentication using stored login profiles.
- Parses incoming queries and delegates tasks to corresponding database plugins.
- Plugins encapsulate database-specific logic, converting WhoDB requests to native queries and executing them.
- Results are transformed into a unified format (`RowsResult`) with columns, rows, and metadata.

For example, running an execution with analysis mode results in:

- Backend plugins running `EXPLAIN ANALYZE` queries.
- Parsed JSON explain output sent back.

Enterprise Edition (EE) features and plugins (e.g., analyze view) conditionally activate based on licensing and database type.

---

## Data Transformation & Visualization

### Raw Execute Page

- Result sets from raw queries are displayed in tabular form.
- For analysis, a dedicated graph component visualizes execution plans.
- Query history allows replaying or editing past queries.

### Explore Storage Unit Page

- Rows are displayed in a paginated, editable table.
- Filters generate complex where conditions that backend parses.
- Users can add, update, or delete rows with immediate UI feedback.

### Graph Page

- Visualizes storage units as nodes and relationships as edges.
- Graph layout algorithms position nodes for clarity.
- Users can pan, zoom, and download diagram images.

---

## Typical User Flows & Scenarios

### Executing a Raw SQL Query

1. Type SQL or analyze command in Scratchpad cell.
2. Submit query, which triggers a GraphQL request.
3. Backend plugin executes query, returns `RowsResult`.
4. UI renders result as a table or an execution plan graph.
5. Your query is saved in local history for reuse.

### Browsing and Managing Data Rows

1. Select a storage unit in the dashboard.
2. Set filters, page size, and request rows.
3. Edit cells inline; changes trigger GraphQL mutations.
4. Add new rows via a dynamic form, invoking mutations on submission.
5. Delete selected rows securely with confirmation.

### Visualizing Database Schema

1. Open Graph visualization page.
2. GraphQL query fetches storage units and relationships.
3. Backend returns `GraphUnit` data including unit details and relation types.
4. ReactFlow renders an interactive graph.
5. Use layout controls to organize graph as needed.

---

## Practical Tips & Best Practices

- **Query Preparation**: Use the provided command prefixes in analyze mode to get detailed execution insights.
- **History Usage**: Leverage query history in Scratchpad to improve productivity and reduce repetitive typing.
- **Pagination Awareness**: For large tables, adjust page size to maintain UI responsiveness.
- **Filter Construction**: Utilize flexible where condition builders to narrow down dataset efficiently.
- **Graph Exploration**: Refresh and relayout graph views to keep your schema overview clean and updated.

---

## Troubleshooting Common Issues

- **Empty or No Query Results**: Ensure your query syntax is correct, and the database plugin supports the requested operation.
- **Analysis Visualization Fails**: Confirm that EE features are enabled and you're connected to a supported database (e.g., PostgreSQL).
- **Slow Data Loading**: Reduce page size or increase filters for large datasets.
- **Mutation Failures**: Check user authentication and permissions; ensure required fields are not empty.

Refer to the [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) page for further guidance.

---

## Request Lifecycle Summary Diagram

```
flowchart TD

  UI["React Frontend UI"] -->|User Action| GraphQLAPI["GraphQL API Client"]
  GraphQLAPI -->|Send Query/Mutation| Backend["Go Backend Server"]
  Backend -->|Authenticate and Route| Plugin["Database Plugin"]
  Plugin -->|Execute on DB| Database[("Database")]
  Database -->|Query Result| Plugin
  Plugin -->|Transform & Return| Backend
  Backend -->|Response| GraphQLAPI
  GraphQLAPI -->|Render Data| UI

  subgraph AnalyzeFlow ["Analyze Query Handling"]
    UI -->|Analyze Mode query| GraphQLAPI
    Plugin -->|Run EXPLAIN ANALYZE| Database
    Plugin -->|Return JSON Plan| Backend
    Backend --> UI
  end

  subgraph GraphVisualization ["Schema Graph Flow"]
    UI -->|Fetch Graph Data| GraphQLAPI
    Plugin -->|Retrieve Units & Relations| Database
    Backend --> UI
  end

  classDef component fill:#f2f4f8,stroke:#333,stroke-width:1px;
  class UI,GraphQLAPI,Backend,Plugin,Database component;
```

---


# concepts/data-models/core-data-models.mdx
## Core Data Models & Object Abstraction

See how WhoDB unifies SQL, NoSQL, and key-value data into an approachable set of concepts: storage units, rows, columns/properties, relationships, and schemas. Grasp how the abstraction layer provides a universal vocabulary and navigational logic across all supported databases.

# Core Data Models & Object Abstraction

Unlock the power of universal data interaction with WhoDB’s foundational data models. This guide demystifies how WhoDB abstracts diverse database systems — SQL, NoSQL, and key-value stores — into a cohesive vocabulary and navigation framework that feels intuitive yet powerful.

---

## Introduction

Whether you work with PostgreSQL relational tables, MongoDB collections of documents, or Redis key-value pairs, WhoDB presents your data through a consistent set of core concepts. This abstraction empowers you to explore, query, and manipulate data across systems without adapting to wildly different interfaces or terminologies.

Here we explore the main elements:

- **Storage Units** — Unified representation of database entities like tables, collections, or key spaces
- **Rows (or Documents/Entries)** — Individual data records inside storage units
- **Columns / Properties** — Attributes or fields that describe each row
- **Relationships** — Connections between storage units capturing how data items link together
- **Schemas** — Logical groupings organizing storage units and relationships within a context

Each concept is designed to map cleanly onto multiple database paradigms while allowing WhoDB’s UI and AI capabilities to provide consistent, natural experiences.

---

## Storage Units: The Core Abstraction of Data Containers

A Storage Unit is the fundamental organizational unit within WhoDB. It represents any logical grouping of data entities, encapsulating a set of related rows or entries. The abstraction covers:

- **Relational Databases:** Tables in schemas
- **Document Stores:** Collections or views
- **Key-Value Stores:** Namespaces or key groups

### What You See in WhoDB

Each storage unit appears as a navigable entity in WhoDB’s UI, showing metadata such as:
- Name (e.g., `users`, `orders`)
- Type (table, view, collection, keyspace)
- Size and row count
- Structural attributes (like column types)

### Why It Matters

This unified model lets you jump between relational and NoSQL data without switching mental models. When you select a storage unit, you’re preparing to browse or query the contained rows using familiar tools.

---

## Rows (Entries): Your Data Records

Within a storage unit, data is organized as a set of rows or documents — the individual records.

- In SQL databases, these are table rows
- In MongoDB, they correspond to JSON-like documents
- In Redis or other key-value stores, these are key-value entries

### Interacting with Rows

WhoDB allows you to: 
- View rows with pagination for large datasets
- Edit data inline where permitted
- Add new rows with guided input
- Delete rows safely

Regardless of backend database, these operations feel consistent.

---

## Columns and Properties: Defining Attributes

Columns (or properties) represent the named attributes of rows within storage units. Behind the scenes, WhoDB derives columns depending on the data source:

- **For SQL:** Actual table columns with data types
- **For NoSQL:** Field keys present in documents; types inferred where possible

Columns are key to filtering, searching, sorting, and editing data.

### Schema Metadata

WhoDB enriches columns with metadata like:
- Data type (e.g., integer, text, boolean, JSON)
- Nullable or required status
- Index or primary key designations (for applicable databases)

This metadata powers intelligent UI behavior and query generation.

---

## Relationships: Mapping Connections Between Storage Units

Understanding data often means understanding how pieces relate. WhoDB captures relationships to reveal data structure and support complex queries.

### Types of Relationships:

- **One-to-One**
- **One-to-Many**
- **Many-to-One**
- **Many-to-Many**
- **Unknown / Unmapped** (when relationships can’t be inferred)

### How Relationships Are Identified

Relationships are inferred by plugins based on database metadata such as foreign key constraints in relational databases or index patterns in NoSQL systems.

They are represented visually in schema graphs and can be traversed directly.

---

## Schemas: Logical Groupings of Storage Units

Schemas organize storage units under a logical namespace or context.

- In SQL, schemas are explicit namespace containers
- In NoSQL, databases or namespaces often serve this role

WhoDB exposes schemas as the higher-level grouping that helps users orient themselves, discover related storage units, and scope queries.

---

## Unified Data Model in Action: User Journey Example

1. **Connect Your Database:** Choose a database and schema (or database namespace) to explore.
2. **Browse Storage Units:** View a list of tables or collections, each with rich metadata.
3. **Explore Relationships:** Use the schema visualization to understand how data entities link.
4. **Manage Rows:** Filter, search, edit, or add new rows with a uniform interface.
5. **Invoke AI Chat:** Ask natural language questions that operate across these abstractions seamlessly.

This consistent experience removes barriers between database types, enabling fluency and productivity.

---

## Tips and Best Practices

- **Familiarize Yourself with Storage Unit Types:** Knowing whether you’re working with a table, view, or collection helps predict capabilities.
- **Leverage Relationships:** Use the schema graph to formulate queries that span related storage units.
- **Use Filters Intuitively:** Columns are your leverages for precise data slices—experiment with filtering and sorting.
- **Mind Permissions:** Some editing actions may be disabled based on your security profile or database restrictions.

---

## Common Pitfalls and How to Avoid Them

- **Expecting Uniform Capabilities:** Not all database types support all operations (e.g., raw query execution vs. AI chat). Consult plugin-specific documentation if needed.
- **Overwhelmed by Large Datasets:** Use filters and pagination to maintain responsiveness.
- **Misunderstanding Relationships:** Auto-inferred relationships might miss complex or implicit links; use schema visualization for clarity.

---

## Diagram: Core Data Model Relationships

```
graph TD
  SU["Storage Unit"] -->|contains| R["Row / Entry"]
  R -->|has attributes| C["Columns / Properties"]
  SU -->|belong to| Sch["Schema"]
  SU -->|related via| Rel["Relationship"]
  Rel --> SU

  subgraph Description
    SU_desc["Represents tables, collections, etc."]
    R_desc["Individual data records"]
    C_desc["Fields or attributes"]
    Sch_desc["Namespace or logical grouping"]
    Rel_desc["Data entity connections"]
  end

  SU --- SU_desc
  R --- R_desc
  C --- C_desc
  Sch --- Sch_desc
  Rel --- Rel_desc

  classDef concept fill:#e5f6ff,stroke:#1c7ed6,color:#074f7d;
  class SU,R,C,Sch,Rel concept;
```

---

## Next Steps

To extend your mastery of WhoDB’s data abstractions:

- Explore the [Schema & Relationship Visualization Guide](/concepts/data-models/schema-visualization) for visual insights
- Dive into [Exploring and Managing Data](/guides/essential-workflows/exploring-and-managing-data) to learn data navigation and editing
- Try out the [AI Chat Guide](/guides/ai-and-natural-language/conversational-queries-and-ai-models) to query data naturally
- Review the [System Architecture Overview](/concepts/architecture-overview/system-architecture) for context on how these models fit into the platform

By developing a solid understanding of these core data models, you’ll unlock the full potential of WhoDB as a seamless, cross-database data management and AI query platform.

---

---


# concepts/data-models/schema-visualization.mdx
## Schema & Relationship Visualization

Learn how WhoDB constructs and displays interactive schema graphs. Understand the 'graph' abstraction for visualizing storage units (tables, collections, indexes) and their relationships across different database types, including join discovery and foreign key mapping.

# Schema & Relationship Visualization

Understanding your database schema visually is crucial for effective data exploration and management. WhoDB leverages an interactive graph abstraction to display storage units—such as tables, collections, and indexes—and their relationships, providing users with a clear, unified view across different database systems including SQL, NoSQL, and others.

---

## What is the Graph Abstraction?

The "graph" in WhoDB represents an interactive visualization of your database’s structural elements (Storage Units) and their relationships. Each node in the graph corresponds to a storage unit like a table or collection, while edges illustrate relationships based on foreign keys, joins, or inferred connections depending on the database type.

This visualization helps you:

- Quickly grasp complex schemas with multiple storage units.
- Understand how data entities relate in your database.
- Navigate directly to storage unit details or data browsing workflows.

## Storage Units: Nodes in the Graph

Storage units in WhoDB are abstractions over database objects:

- **SQL databases:** Typically tables or views.
- **NoSQL databases:** Collections, indexes, or equivalent groupings.

Each storage unit node displays key attributes such as name and metadata (key properties, index hints) to assist users in identifying relevant units.

### Example Attributes of a Storage Unit

| Attribute Key | Value Example             |
|---------------|--------------------------|
| Engine        | InnoDB (for MySQL)        |
| Rows          | 25,000                   |
| Primary Key   | id                       |
| Description   | User accounts information |

These attributes are surfaced within the node cards in the graph layout.

## Relationship Types: Edges in the Graph

Edges connecting storage units represent explicit or inferred relationships. WhoDB distinguishes between several relationship types:

| Relationship Type | Description                        |
|-------------------|----------------------------------|
| OneToOne          | A unique 1:1 relationship (e.g., PK-FK pairs)  |
| OneToMany         | A single record relates to multiple records  |
| ManyToOne         | Multiple records relate back to one record  |
| ManyToMany        | Complex cross-links via join tables  |
| Unknown           | Unknown or undetermined relationships |

The application automatically detects and classifies these based on:

- Foreign key constraints (SQL databases like PostgreSQL, MySQL)
- Join discovery mechanisms
- Schema metadata from database inspection

Edges are bidirectionally rendered for many-to-many relationships, aiding comprehension of mutual links.

## How WhoDB Constructs the Graph

WhoDB dynamically queries your connected database and imports schema metadata to build the graph. The process includes:

1. **Schema Inspection:** Retrieving all storage unit names and attributes.
2. **Relationship Discovery:** Querying metadata tables to detect foreign keys, unique constraints, and join-based relations.
3. **Graph Model Assembly:** Combining data into nodes and edges annotated with relationship types.
4. **Layout Computation:** Applying algorithmic layout (using Dagre) to position nodes for clarity.

### Database-Specific Graph Queries

The underlying method varies by database type:

- **PostgreSQL:** Uses information_schema to find foreign keys, primary keys, uniques, and many-to-many associations.
- **ClickHouse:** Analyses system tables to infer dependencies and constraints.
- **Others:** Adapted heuristics or metadata queries depending on database capabilities.

This abstraction ensures a consistent user experience despite differing database architectures.

## Exploring the Graph in the UI

- **Interactive Nodes:** Click any storage unit to expand and view more attributes, or navigate to detailed data views.
- **Zoom & Pan:** Navigate large schemas smoothly.
- **Layout Controls:** Reorganize graph automatically for better readability.
- **Download Diagram:** Export the visual schema as a PNG image for sharing or documentation.

### User Workflow Example

Imagine you are connected to a PostgreSQL database with customer, orders, and products tables. On the graph page:

1. Nodes appear for each table.
2. Edges display, showing OneToMany from customers to orders.
3. Clicking the `orders` node displays its columns and keys.
4. Navigating to `orders` data lets you filter or edit rows.

This workflow rapidly transforms abstract metadata into actionable insights.

## Best Practices

- Regularly refresh the graph after schema changes to avoid stale metadata.
- Use graph layouts to declutter visual complexity.
- Leverage relationship types to understand join directions before writing queries.
- Export snapshots for team collaboration or documentation.

## Common Pitfalls & Troubleshooting

- Verify your database connection is active and the selected schema contains storage units.
- Refresh the graph page or reload the app.
- Check for permission restrictions on schema metadata.

- Some databases do not enforce foreign keys; relationships may be missing.
- Consider adding explicit constraints or use query tools for manual join inspection.
- Confirm the correct schema is selected in WhoDB.

- Use the layout button to reorganize nodes.
- Zoom in/out for better viewing.
- Filter storage units or reduce visible nodes if the graph is too large.

- Ensure you use the download button after the auto layout finishes.
- Retry exporting with sufficient zoom and full graph visible.

## Technical Overview of the Graph Data Model

WhoDB's GraphQL API exposes the graph as a list of `GraphUnit`s, each containing a `StorageUnit` and its relational edges:

```
enum GraphUnitRelationshipType {
  OneToOne
  OneToMany
  ManyToOne
  ManyToMany
  Unknown
}

type GraphUnitRelationship {
  Name: String!
  Relationship: GraphUnitRelationshipType!
}

type GraphUnit {
  Unit: StorageUnit!
  Relations: [GraphUnitRelationship!]!
}
```

This structured model powers the frontend's reactive graph rendering with detailed relationship semantics.

## Diagram: Simplified Graph Data Flow

```
flowchart TD
    subgraph "Database Metadata"
        DBMeta["Schema Info & Constraints"]
    end

    subgraph "WhoDB Backend"
        GraphQLAPI["GraphQL Query for Graph"]
        GraphModel["Graph Model Layer"]
    end

    subgraph "WhoDB Frontend"
        GraphPage["Schema Graph Page"]
        GraphRenderer["React Flow Graph Renderer"]
    end

    DBMeta -->|Metadata Queries| GraphQLAPI
    GraphQLAPI --> GraphModel
    GraphModel --> GraphPage
    GraphPage --> GraphRenderer
    GraphRenderer -->|Interactive UI| GraphPage
```

## Related Documentation

- [Core Data Models & Object Abstraction](/concepts/data-models/core-data-models): Understand underlying abstractions for storage units.
- [Visualizing Your Database Schema Guide](/guides/essential-workflows/visualizing-your-database-schema): Step-by-step for interactively using the graph page.
- [Connecting to Your Database Guide](/guides/essential-workflows/connecting-to-your-database): Setup database connections to enable schema retrieval.
- [Exploring and Managing Data Guide](/guides/essential-workflows/exploring-and-managing-data): Dive into data browsing and inline editing linked from graph nodes.

---

For comprehensive mastery of your database’s structure and relationships, use the Schema & Relationship Visualization as your starting point to unlock WhoDB’s powerful exploration and management capabilities.

---

# Practical Tips

- Refresh your database connection if schema changes are not reflected immediately.
- Use schema filtering to focus on relevant storage units.
- Combine visualization with raw queries for fast troubleshooting.
- Take advantage of the downloadable PNG export to share schema diagrams with your team.

# Summary
WhoDB’s Schema & Relationship Visualization page empowers users to see the full topology of their database schema through an interactive graph. It abstracts tables and collections as storage units and visually illustrates how they interconnect via foreign keys and other relationships, facilitating faster understanding, navigation, and data operations.

This visualization is foundational for database administrators, developers, and data analysts seeking to efficiently explore and manage complex schemas across SQL and NoSQL systems.

---

If you encounter issues, consult the troubleshooting tips here or reach out to support through the community channels.

Explore the graph today to deepen your understanding and accelerate your database workflows.

---

---


# concepts/security-scalability/security-auth.mdx
## Security Model & Authentication

Examine WhoDB's security perimeter, including credential storage, authentication flow, session cookie management, and role of the backend in enforcing data access. Learn about public and protected routes, token management, and areas of extensibility for SSO or custom auth.

# Security Model & Authentication in WhoDB

## Introduction

Understanding the security model and authentication flow in WhoDB is fundamental to ensuring the integrity and confidentiality of your data. This page explains how WhoDB manages user credentials, authenticates requests, and controls access to its API. You’ll learn about the role of session cookies, token management, protected vs. public routes, and how the backend enforces these security policies to protect your database environment.

## Security Perimeter Overview

WhoDB uses a layered security approach centered on authentication and credential management. Key elements include:

- **Credential Storage:** User credentials are securely encoded and stored in HTTP-only cookies or transmitted via bearer tokens.
- **Authentication Middleware:** Intercepts and validates each incoming request to enforce access control.
- **Public vs. Protected Routes:** Differentiates unprotected endpoints used during development or introspection from secure API calls.
- **Token Validation:** Supports API tokens for gateway-enabled setups to validate user sessions.
- **Extensibility:** The architecture can be extended to support additional authentication schemes like SSO or custom OAuth providers.

This model ensures that WhoDB only processes requests from authenticated users and stops unauthorized access early in the request lifecycle.

---

## Key Concepts

### 1. Credential Storage and Session Cookies

When a user logs in with their credentials, WhoDB encodes this information as JSON, then base64-encodes it into a string stored in an HTTP-only cookie named `Token`. This cookie is sent with each HTTP request, providing the backend access to the user’s credentials without exposing them to client-side scripts.

```
// Encoding login info and setting cookie
cookieValue := base64.StdEncoding.EncodeToString(loginInfoJSON)
cookie := &http.Cookie{
    Name:     string(AuthKey_Token),
    Value:    cookieValue,
    Path:     "/",
    HttpOnly: true,
    Expires:  time.Now().Add(24 * time.Hour),
    SameSite: http.SameSiteStrictMode,
}
http.SetCookie(ctx.Value(common.RouterKey_ResponseWriter).(http.ResponseWriter), cookie)
```

The cookie's HTTP-only and SameSite flags safeguard against client-side tampering and cross-site request forgery (CSRF).

### 2. Authentication Middleware Flow

WhoDB uses an HTTP middleware component that wraps all incoming requests to enforce security policies.

#### What the middleware does:

- **Check for Public Routes:** Allows unauthenticated access to certain endpoints, including GraphQL Introspection queries in development mode and any requests outside the `/api` path.
- **Limit Request Body Size:** Protects the server from denial-of-service via large payloads by setting a 1MB maximum for request bodies.
- **Token Extraction:** 
  - If the API Gateway is enabled (via configured tokens), it extracts a bearer token from the `Authorization` header.
  - Otherwise, it looks for the `Token` cookie.
- **Token Decoding and Validation:** Decodes the token, unmarshals user credentials, and validates them.
- **Profile Resolution:** Matches credential IDs against saved login profiles and injects the resolved credentials into the request context for downstream handlers.

If any check fails, the middleware immediately responds with appropriate HTTP error codes such as 401 Unauthorized or 413 Payload Too Large.

### 3. Public vs. Protected Routes

To provide flexibility, WhoDB defines:

- **Public routes:** 
  - All non-`/api` routes (primarily frontend or static content).
  - GraphQL Introspection queries (only in development mode for schema exploration).
  - Specific GraphQL operations such as `Login`, `Logout`, `GetProfiles`, which are allowed without authentication for onboarding.

- **Protected routes:** 
  - All other `/api` routes require valid credentials.
  - These are the core API endpoints that interact with database metadata, query execution, AI models, and other sensitive operations.

### 4. Token Management & Validation

When the API Gateway feature is enabled by setting valid tokens in the environment (`WHODB_TOKENS`), requests must include a bearer token in the `Authorization` header which is validated against this list.

If the gateway is not enabled, WhoDB relies on the cookie-based token mechanism.

This dual mechanism allows for seamless usage in different deployment scenarios, including enterprise environments with stricter API gateway controls.

### 5. Credential Profiles and Database Selection

WhoDB maintains user credential profiles loaded via environment variables per database type. Upon authentication, if the credential includes a profile ID, the backend matches it against these profiles, enriching the credentials with any specific database or connection details.

This allows users to switch easily between database profiles without re-entering full credentials, supporting efficient workflow management.

## User Authentication Flow

The following steps outline what happens when a user interacts with WhoDB's login system:

1. **User Submits Login:** The frontend sends login credentials which are encoded and set in an HTTP-only cookie.
2. **Authenticated Requests:** Subsequent requests include the cookie or bearer token.
3. **Middleware Validation:** The backend middleware decodes and validates the provided token from headers or cookies.
4. **Context Injection:** Valid credentials are attached to the request context for later GraphQL resolvers.
5. **Profile Resolution:** The system checks if the credentials correspond to a saved profile.
6. **Request Processing:** Authorized requests proceed to query the database or perform allowed operations.

### Logout Handling

Logging out invokes backend code that clears the authentication cookie, effectively revoking session access.

```
func Logout(ctx context.Context) (*model.StatusResponse, error) {
    http.SetCookie(ctx.Value(common.RouterKey_ResponseWriter).(http.ResponseWriter), nil)
    return &model.StatusResponse{
        Status: true,
    }, nil
}
```

## Extensibility & Future-Proofing

While WhoDB's current security model focuses on cookie and token-based authentication, it is architected to allow enhancements such as:

- Adding Single Sign-On (SSO) integrations.
- Supporting OAuth and federated authentication.
- Integrating custom authentication plugins at the middleware level.

This aligns with WhoDB’s modular, plugin-based design ethos, offering a flexible foundation for evolving enterprise security needs.

---

## Practical Tips and Best Practices

- **Keep Tokens Secure:** Avoid exposing tokens or credentials to client-side scripts by relying on HTTP-only cookies.
- **Use API Gateway Mode in Enterprise:** Enable `WHODB_TOKENS` to centralize and strengthen API token management.
- **Monitor Request Sizes:** Ensure clients do not exceed request limits to prevent service disruptions.
- **Leverage Login Profiles:** Configure multiple database credential profiles for convenient switching without re-login.
- **Protect Development Introspection:** Disable or restrict introspection queries and public routes in production environments.

## Troubleshooting Common Authentication Issues

- **Unauthorized Errors:** Check if the token is properly sent in the `Authorization` header or if cookies are set and sent with requests.
- **Token Decode Failures:** Verify tokens are correctly base64 encoded and JSON marshalled.
- **Request Body Too Large:** Remember the maximum request size is 1MB; split large requests accordingly.
- **Missing Profiles:** Confirm environment variables define valid database credential profiles matching expected IDs.

## Diagram: Authentication Request Flow

```
flowchart TD
    U["User / Client"] -->|Login Submit| FE["Frontend UI"]
    FE -->|Sends Credentials| BE["WhoDB Backend Middleware"]

    subgraph "Authentication Middleware"
        BE --> CheckPublic["Check if Public Route"]
        CheckPublic -->|Yes| PassThrough["Allow Request"]
        CheckPublic -->|No| ExtractToken["Extract Token from Cookie or Header"]
        ExtractToken --> DecodeToken["Base64 Decode & JSON Unmarshal"]
        DecodeToken --> ValidateToken["Validate Token/Session"]
        ValidateToken -->|Valid| InjectCtx["Add Credentials to Context"]
        ValidateToken -->|Invalid| Reject["Return 401 Unauthorized"]
    end

    InjectCtx --> ProcessReq["Process GraphQL or REST Request"]
    PassThrough --> ProcessReq
    ProcessReq --> DBAccess["Access Database via Plugins"]
    DBAccess --> Response["Return Data to Client"]
    Reject --> FE
    Response --> FE

    click BE "core/src/auth/auth.go" "Authentication Middleware Implementation"
```

---

## Summary

The WhoDB security model robustly manages user authentication via session cookies or bearer tokens validated by the backend authentication middleware. It distinguishes public and protected routes to secure sensitive operations, supports configurable API gateway tokens, and maintains credential profiles for efficient multi-database access. Extensible by design, this security perimeter lays a solid foundation for secure database management and user session control.

---

## Further Reading & Related Documentation

- [Security and Authentication Essentials Guide](https://whodb.com/docs/guides/best-practices-and-optimization/security-and-authentication) — Practical workflows and security best practices.
- [Connecting to Your Database](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database) — Credential usage and connection profiles.
- [System Architecture Overview](https://whodb.com/docs/concepts/architecture-overview/system-architecture) — Broader context of the backend server and middleware.
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) — Identifying and solving authentication and connection problems.

---

Should you require secure single sign-on or customized authentication, consult with WhoDB enterprise support or refer to upcoming extensions in the plugin architecture.

---


# concepts/security-scalability/permissions-data-access.mdx
## Permissions & Data Access Patterns

Understand the approach WhoDB takes to data access control: from credential-based database connection down to field and row-level visibility. See how WhoDB's user sessions map to underlying database permissions, and the boundaries for who can view or modify data.

# Permissions & Data Access Patterns in WhoDB

WhoDB offers a robust and flexible approach to data access control, ensuring that users interact with your connected databases securely and appropriately. This guide unpacks the permission architecture from the moment credentials are used to establish database connections, down to fine-grained control at the row and field level. Understanding these concepts enables you to configure WhoDB to match your organizational security policies and maximize secure data accessibility.

---

## Understanding WhoDB’s Permission Model

At its core, WhoDB's data access follows a credential-based model. When a user attempts a login, WhoDB authenticates based on the database connection credentials provided — either directly or via saved profiles. These credentials dictate the permissions available for viewing or modifying data within the linked database.

### Credential-Based Authentication

- **Login Credentials:** Users can provide database credentials manually (host, username, password, etc.) or select from pre-defined profiles stored in WhoDB.
- **Profile Usage:** Profiles encapsulate saved credentials and metadata, enabling streamlined login without repeated manual input.
- **Session Mapping:** Upon login, WhoDB maps the active user session to the exact permission set associated with the provided credentials.

This mechanism means that permission enforcement originates at the database layer, aligned with database roles, users, and policies out-of-the-box.

This approach ensures that WhoDB does not override your database’s native security model but acts as a gateway reflecting your database's permission constraints.

---

## Permission Boundaries and Session Scope

Each logged-in session’s scope tightly corresponds to the underlying database user’s privileges:

- **Schema and Storage Units:** Access to specific schemas and their storage units reflects granted read or write permissions of the database user.
- **Operations Allowed:** Read (SELECT), write (INSERT, UPDATE, DELETE), and schema-related operations are permitted in WhoDB only if the credentials support them.
- **Profile Saved Permissions:** Saved profiles store connection details but do not store permissions themselves; permissions are dynamic per database user rights.

WhoDB inherits, not redefines, authorization logic — any permission changes in the database immediately apply to active and future sessions connected via those credentials.

---

## Data Access Levels Supported

WhoDB operates within these permission dimensions:

| Access Level      | Description                                                             | WhoDB Implementation                                |
|-------------------|-------------------------------------------------------------------------|-----------------------------------------------------|
| Global Database   | Permission to log in and connect to the database instance              | Valid credentials required for login                |
| Schema Level      | Permission to view or alter specific database schemas                   | Schema discovery and visibility controlled          |
| Storage Unit Level| Permission to browse, query, edit tables/collections/documents          | UI access reflects accessible storage units         |
| Row Level        | Permission to read, add, update, or delete individual records           | Inline edits and row operations respect DB rights    |
| Field Level      | Permission to view or modify specific columns or document fields        | Field selection and editing constrained accordingly |

Row-level or field-level filtering relies entirely on the database's native permission system or implemented security policies (e.g., views or row-level security) — WhoDB does not impose an additional layer but surfaces what the database permits.

---

## Workflow: How Permissions Affect User Interactions

### 1. Connecting and Logging In

- User inputs credentials or selects a saved profile.
- WhoDB validates required fields based on database type.
- On successful authentication, a user session is created that reflects that user’s database permissions.

### 2. Exploring Storage Units

- Storage units (tables, collections) visible in WhoDB correspond exactly to that user's database permissions.
- Attempts to view or manipulate unauthorized storage units result in errors or absence from listing.

### 3. Browsing & Filtering Data

- Queries issued through WhoDB encapsulate user rights; filters and pagination respect read permissions.
- Lack of select rights means data is inaccessible.

### 4. Editing Data

- Updates, inserts, or deletes execute only if the database user has the required write permissions.
- Attempts to modify restricted rows or fields are rejected by the database, surfaced to the user via WhoDB notifications.

### 5. Session Lifecycle

- Login state and permissions remain active until logout or session expiration.
- Permissions refresh dynamically if credentials or database roles change and user logs in again.

---

## Practical Tips & Best Practices for Managing Permissions

- **Use Database Roles:** Manage permissions through database roles rather than individual user accounts for simpler and scalable permission management.
- **Leverage Profiles:** Create named profiles in WhoDB for each role or permission scope to ease user login and ensure consistent access.
- **Test with Minimal Privileges:** Always test WhoDB connections with the least privileges needed to accomplish tasks.
- **Secure Stored Profiles:** Ensure stored login profiles are secured via environment protections and that users don’t share credentials inadvertently.
- **Audit Database Security Policies:** Combine WhoDB’s visualization and data exploration features with database native security policies like row-level security or views for fine-grained control.

Avoid using elevated administrative credentials for general WhoDB use. Restrict admin users to management tasks to reduce risk exposure.

---

## Common Pitfalls & Troubleshooting

| Issue                      | Cause                                 | Resolution                                            |
|----------------------------|---------------------------------------|-------------------------------------------------------|
| Cannot See Expected Tables | Insufficient DB permissions            | Confirm database user has SELECT permissions on tables|
| Edit Operations Fail       | Write permissions missing or denied   | Verify user can INSERT/UPDATE/DELETE on target tables |
| Profile Login Fails        | Invalid or outdated credentials       | Update profile credentials with correct info          |
| Partial Data Visibility    | Row-level security or view restrictions| Review DB policies; test access from native DB clients|
| Unexpected Errors          | Mismatch in schema or database type   | Verify settings in WhoDB Login page match DB setup    |

For detailed login troubleshooting, please consult the [Login and Connection Issues](https://whodb.com/docs/faq/troubleshooting-optimizations/login-auth-issues) documentation.

---

## How Permissions Map to WhoDB Components

### Login and Authentication

- Managed via `LoginPage` component.
- Users input connection creds or select a stored profile.
- Validation ensures required fields per database type.
- Session state held in Redux `auth` store with profiles and current session.

### Storage Unit Visibility

- Controlled through queries that fetch storage units accessible to logged-in user.
- UI components like `StorageUnitPage` and `ExploreStorageUnit` render only authorized data units.

### Inline Editing and Data Operations

- Editing operations are performed via GraphQL mutations like `UpdateStorageUnit`, `AddRow`, and `DeleteRow`.
- These invoke database queries that require underlying permissions.
- Errors surface to UI as notifications managed by centralized feedback mechanisms.

---

## Visualizing Permissions Flow

```
flowchart TD
    A[User Initiates Login] --> B[Provide Credentials or Select Profile]
    B --> C[WhoDB Validates Inputs]
    C -->|Valid| D[Authenticate Against Database]
    C -->|Invalid| E[Show Error: Missing Required Fields]
    D -->|Success| F[Create User Session with DB User Permissions]
    D -->|Failure| G[Show Authentication Failure Notification]
    F --> H[Fetch Accessible Storage Units & Schemas]
    H --> I[Display Allowed Storage Units in UI]
    I --> J[User Browses or Queries Data]
    J --> K{Is User Authorized for Operation?}
    K -->|Yes| L[Execute Query or Mutation]
    K -->|No| M[Show Permission Denied Notification]
    L --> N[Return Data or Confirmation]
    M --> N

    classDef error fill:#f9d6d5,stroke:#f12d29,stroke-width:2px;
    class E,G,M error;
```

---

## Key Takeaways

- WhoDB’s data access strictly reflects the permissions of the logged-in database user.
- Profiles streamline repeated logins while respecting credential scope.
- Row- and field-level permissions depend on your database's native security.
- Properly managing database roles and users maximizes secure, productive use of WhoDB.
- UI feedback and errors help diagnose permission-related issues interactively.

---

## Next Steps

- Review the [Connecting to Your Database Guide](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database) to configure profiles and credentials correctly.
- Explore the [Security Model & Authentication Documentation](https://whodb.com/docs/concepts/security-scalability/security-auth) to deepen understanding of WhoDB’s authentication flows.
- For advanced access control, implement database-side row-level security or views as appropriate.
- Visit the [Exploring and Managing Data Guide](https://whodb.com/docs/guides/essential-workflows/exploring-and-managing-data) to see how permissions impact everyday workflows.

---

## Glossary

| Term              | Definition                                                                             |
|-------------------|----------------------------------------------------------------------------------------|
| Storage Unit      | A database abstraction representing tables, collections, or similar data containers.   |
| Profile           | Saved database credentials facilitating login without manual re-entry.                 |
| Role              | Database-level grouping of permissions assigned to users for access control.          |
| Row-Level Security| Database policies restricting access on individual rows within tables or collections.  |
| Schema            | Logical grouping of database objects such as tables and views.                         |

---

## References

- [Login Page Source](https://github.com/clidey/whodb/blob/main/frontend/src/pages/auth/login.tsx)
- [Authentication Store](https://github.com/clidey/whodb/blob/main/frontend/src/store/auth.ts)
- [Database Connection Guide](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database)
- [Security Model Documentation](https://whodb.com/docs/concepts/security-scalability/security-auth)
- [Exploring and Managing Data](https://whodb.com/docs/guides/essential-workflows/exploring-and-managing-data)

---

By understanding and working within these permission frameworks, you ensure that WhoDB remains a secure and effective interface to your database environments, respecting and leveraging your database's inherent security life cycle.

---


# concepts/security-scalability/scalability-performance.mdx
## Scalability & Performance Considerations

Explore techniques WhoDB uses for fast interaction even with large datasets and complex schemas: lazy loading, table virtualization, connection pooling, and efficient API pagination. Get guidance on deployment architectures, concurrency limits, and strategies for high-throughput scenarios.

# Scalability & Performance Considerations

Whodb is designed to provide high responsiveness and efficiency even when managing large datasets and complex database schemas. This page explores the key techniques, architectural choices, and usage patterns that allow Whodb to maintain fast interactions while delivering a rich, user-friendly experience.

---

## The Performance Challenge

When interacting with databases, particularly those with large tables or complex relationships, users often face slow response times, delays in rendering, or cumbersome navigation. Whodb addresses these challenges by optimizing how data is fetched, displayed, and managed in the interface.

Consider a data analyst exploring a multi-million-row orders table: loading the entire dataset simultaneously would freeze any interface and degrade user experience. Whodb’s strategies prevent this by fetching only what is needed, when it is needed.

---

## Key Techniques for Scalability and Performance

### 1. Lazy Loading and Pagination

Whodb uses lazy loading to request data incrementally rather than all at once.

- **Pagination:** Data grids load a limited number of rows per page (default 10), which users can adjust. This keeps the UI responsive and reduces memory demands.
- **Dynamic Data Fetching:** As users navigate through pages or apply filters, Whodb fetches just the corresponding data slice.

> **User Value:** This approach ensures fast loading and fluid browsing without overwhelming system resources.

### 2. Table Virtualization

To efficiently display large numbers of rows, Whodb leverages table virtualization techniques:

- Only rows visible within the user’s viewport are rendered.
- As the user scrolls, off-screen rows are discarded from the DOM, and new rows are rendered.

This maintains smooth scrolling and quick rendering even for tables with thousands or more rows.

### 3. Smart Filtering & Query Optimization

Filters in Whodb intelligently adjust based on the database type and fields present:

- Filters generate efficient SQL or database-specific queries to limit results server-side.
- This reduces data transferred over the network and speeds up result delivery.

Example: Applying a filter on a product name or an order status initiates a query that fetches only matching records.

### 4. Connection Pooling & Backend Efficiency

While not exposed directly to users, Whodb’s backend manages database connections via connection pools to provide:

- Faster query response by reusing existing connections.
- Reduced latency when switching between queries or navigating datasets.

This ensures Whodb can handle multiple concurrent users or requests effectively.

### 5. Efficient API Request Handling & Pagination

The backend API supports:

- Pagination parameters such as `pageSize` and `pageOffset` to limit query scope.
- Query batching for the Scratchpad feature, allowing execution of multiple independent queries efficiently.

This keeps data transfer optimized and prevents server overload.

### 6. Deployment Considerations for Scale

For high-throughput or enterprise deployments, consider:

- Deploying Whodb in a containerized environment (Docker) with appropriate CPU and memory allocation.
- Running multiple Whodb instances behind a load balancer to distribute user load.
- Ensuring your database itself is scaled and optimized, as Whodb performance is also dependent on the database response times.

---

## User Experience Flow Highlighting Performance

Imagine a product manager examining sales data:

1. **Login and Selection:** The user logs in and selects the `orders` table.
2. **Lazy Data Fetch:** The first 10 rows load instantly.
3. **Filtering:** The user filters for orders with `status = completed`; only matching rows are fetched and displayed quickly.
4. **Pagination:** Navigating to page 5 triggers a new fetch of the corresponding rows.
5. **Inline Actions:** Editing a cell or adding a new row triggers a targeted update without reloading the entire dataset.

This flow keeps interactions snappy, avoids waiting on full dataset loads, and supports focused data exploration.

---

## Practical Tips and Best Practices

- For very large tables, keep page sizes moderate (10-50 rows) to balance detail and speed.
- Use filters early to narrow down datasets and reduce server and network load.
- Avoid opening many Scratchpad query cells simultaneously; close unused ones.
- Monitor backend logs to watch for slow queries and optimize indexes at the database level.
- For deployments serving many users, consider scaling out the backend and database separately.

---

## Common Pitfalls and Troubleshooting

  - Ensure that pagination is enabled and page size is not set excessively high.
  - Check network latency and backend response times.
  - Verify database indexes exist on commonly filtered columns.
  - Consider rebuilding the database statistics and caches.

  - Confirm that the database supports inline updates for the data type.
  - For Redis sets or MongoDB collections, inline editing may have limitations—refer to the documentation for unsupported field types.
  - Review error messages in the UI or logs for permission or connection issues.

  - Avoid very heavy or complex queries without appropriate limits.
  - Break down large queries into smaller parts.
  - Confirm backend resource availability and database health.

---

## Summary Diagram: Data Flow Optimizations

```
flowchart TD
  UI["Whodb UI"] -->|Page Request: pageSize, pageOffset| Backend["Whodb Backend"]
  Backend -->|Connection Pool Management| Database["Target Database"]
  Database -->|Returns Paginated Rows| Backend
  Backend -->|Returns Data Slice| UI
  UI -->|Apply Filters/Search| Backend

  subgraph Performance Enhancements
    direction TB
    Backend -.->|Connection Pooling| DBConnectionPool["DB Connection Pool"]
    UI -.->|Virtualization & Lazy Rendering| TableVirtualization["Table Rendering Optimizations"]
    Backend -.->|Smart Filtering Queries| QueryOptimizer["Query Optimizer"]
  end

  classDef components fill:#f9f,stroke:#333,stroke-width:1px;
  class UI,Backend,Database components;
```

---

## Next Steps

To further optimize and handle large datasets effectively:

- Explore the [Working Efficiently with Large Datasets](https://whodb.com/docs/guides/best-practices-and-optimization/working-efficiently-with-large-datasets) guide for UI-specific tips.
- Review deployment and [Scaling Strategies and Performance Optimization](https://whodb.com/docs/deployment/operationalization/scaling_performance) for production environments.
- Consult the [Security and Authentication Essentials](https://whodb.com/docs/guides/best-practices-and-optimization/security-and-authentication) for secure, performant configurations.

---

For detailed usage examples, refer to the [Exploring and Managing Data](https://whodb.com/docs/guides/essential-workflows/exploring-and-managing-data) guide and leverage the AI Chat interface for intelligent querying without heavy manual filters.

---

# Summary
This documentation explains the scalability and performance approaches Whodb employs to enable fast, efficient database interactions, even with large data volumes and complex structures. It covers lazy loading, pagination, virtualized rendering, connection pooling, smart filtering, and deployment strategies to maintain a smooth user experience.

Key sections include:
- The Performance Challenge
- Core Performance Techniques
- User Experience Flow
- Practical Tips & Troubleshooting
- Performance Data Flow Diagram
- Next Steps and Related Resources

Important links:
- [Working Efficiently with Large Datasets](https://whodb.com/docs/guides/best-practices-and-optimization/working-efficiently-with-large-datasets)
- [Scaling Strategies and Performance Optimization](https://whodb.com/docs/deployment/operationalization/scaling_performance)
- [Exploring and Managing Data](https://whodb.com/docs/guides/essential-workflows/exploring-and-managing-data)

Cross-references:
- System Architecture Overview
- Security and Authentication Essentials
- Scratchpad and Raw SQL Guide

To enhance your usage, start by applying filters early, keeping pagination reasonable, and monitoring your database performance for optimization opportunities.

---


# concepts/integration-patterns/ai-integration.mdx
## Conversational AI Integration

Unpack WhoDB's AI integration: how natural language queries are interpreted and translated to SQL or database-specific operations using ChatGPT, Ollama, and Anthropic. Review context handling, fallback strategies, and ways to customize or extend provider support as new models emerge.

# Conversational AI Integration

Explore how WhoDB harnesses Conversational AI to transform natural language queries into actionable SQL or database-specific commands. This integration leverages powerful AI models such as ChatGPT, Ollama, and Anthropic to enable dynamic, intuitive data interactions through natural language input.

---

## Overview

WhoDB offers a seamless conversational experience by interpreting user queries in natural language and translating them into valid database operations. Leveraging multiple AI providers, the system processes context, maintains dialogue state, and applies fallback strategies to ensure robust and effective responses.

This page unpacks the core concepts behind WhoDB's AI integration, explains how user queries are interpreted, and guides you on customizing and extending AI support as new models become available.

---

## How Conversational AI Works in WhoDB

### Natural Language to SQL Translation

At the heart of WhoDB’s conversational AI is the capability to interpret user queries expressed in plain English (or other supported languages) and convert them into SQL or equivalent database commands specific to the connected storage units.

When you enter a question or command (e.g., "Show me the top 10 customers by revenue last year"), WhoDB sends this input to an AI model which understands:

- The schema and structure of your database,
- Context from previous interactions,
- The specific SQL dialect or query conventions,

and returns a generated SQL query tailored to fulfill your request.

### Supported AI Providers and Models

WhoDB currently integrates with the following AI providers:

- **ChatGPT** (OpenAI's GPT models)
- **Ollama** (Local or hosted model runner)
- **Anthropic** (Claude models and variants)

These providers are accessible through a unified interface, where WhoDB sends the natural language prompt and receives a structured response.

You can select from available models per provider, allowing for flexibility in balancing cost, speed, and accuracy.

### Contextual Conversation Management

To create fluid, human-like exchanges, WhoDB retains the chat history — the sequence of previous user inputs and system outputs — and sends this as context with each new query to the AI model.

This multi-turn conversation enables follow-up questions without needing to repeat details. For example:

1. User: "How many customers did we have in 2023?"
2. AI-generated query runs and returns results.
3. User: "Show me their countries."

The system interprets the second query in context to the first, generating relevant SQL accordingly.

### AI Response Handling

Upon receiving AI-generated text, WhoDB parses the SQL query or operational instructions contained within the response. The server then:

- Validates the SQL for syntax and safety,
- Executes the query through the connected database plugin,
- Returns query results or error messages back to the user,
- Displays the conversational AI text alongside any executed commands.

If the AI response includes advanced visual output commands (available in Enterprise Edition), such as "sql:pie-chart" or "sql:line-chart," WhoDB can render interactive charts directly in the conversation.

---

## User Workflow: Querying Data Using Conversational AI

1. **Select AI Provider and Model:** Choose your preferred AI provider (e.g., ChatGPT) and select a model optimized for conversational SQL generation.
2. **Enter a Natural Language Query:** Type in your question or command in the chat input field.
3. **Send the Query:** Press enter or click send to submit.
4. **Review AI Interpretation:** The AI generates SQL code based on your input and context.
5. **View Results and Dialogue:** Results are displayed in tabular form or via visual charts, alongside conversational text.
6. **Follow Up or Refine:** Continue the conversation with clarifications or additional questions leveraging context.

### Example:

> **User:** "List all products sold in Europe last quarter."

> **AI Response:** Generates SQL query filtering sales data by region and date.

> **WhoDB:** Executes query, displays the product list.

> **User:** "Now show total revenue for each product category."

> **AI Response:** Generates aggregated SQL query grouped by category.

> **WhoDB:** Displays the summary revenue table.

---

## Context Handling and Fallback Strategies

### Conversation State Management

WhoDB’s conversational engine encapsulates:

- **PreviousConversation:** A serialized transcript of earlier user and system messages sent with each AI request.
- **Schema Information:** The current database schema is sent as context so AI can generate valid SQL referencing actual tables and fields.

This encapsulation ensures the AI is well-informed to maintain conversational relevance.

### Fallback and Error Handling

Sometimes, AI-generated SQL might fail due to syntax errors, unsupported features, or ambiguous queries. WhoDB employs a fallback strategy:

- **Syntax Checking:** Queries are validated before execution.
- **Error Feedback:** If execution fails, error messages are returned to the conversation.
- **Re-Query Suggestions:** Users can rephrase or clarify their input.

This approach empowers users to refine queries interactively, minimizing frustration.

---

## Customizing and Extending AI Support

### Adding New Providers and Models

WhoDB’s backend includes an abstraction to support multiple LLM (Large Language Model) clients:

- Each client (e.g., `LLMClient`) implements methods to send prompts and parse responses according to provider-specific protocols.
- Providers currently implemented include ChatGPT, Ollama, and Anthropic, with the ability to add OpenAI-compatible clients.

To integrate a new AI provider:

1. Develop an adapter implementing the `LLMClient` interface,
2. Handle authentication (e.g., API keys or tokens),
3. Define prompt construction and response parsing logic,
4. Register the provider so it becomes selectable in the WhoDB UI.

### Managing Models per Provider

Users can choose from available models each provider supports. WhoDB fetches these lists dynamically using the provider's API.

In the UI, you can:

- Select an AI provider,
- View and choose models available for that provider,
- Add external models manually by specifying tokens and model IDs,
- Remove unsupported or unused models.

### Environment Configuration

API keys and tokens for providers can be set via environment variables or directly through the UI for personal tokens, supporting both local and cloud deployments.

### Extensibility Considerations

- The extensible architecture enables WhoDB to stay current as new AI models emerge.
- Enterprise Edition adds further integration capabilities including enhanced visualization and advanced analytics powered by conversational AI.

---

## Best Practices & Tips

- **Understand Your Schema:** Provide thorough schema descriptions in WhoDB to help AI generate valid queries.
- **Be Specific:** The more detailed your natural language query, the more accurate the AI-generated SQL.
- **Use Follow-ups:** Leverage conversational context for iterative refinement.
- **Manage Tokens Securely:** Keep your AI provider tokens secure and configure them according to your deployment.
- **Monitor AI Usage:** Track usage limits and costs associated with AI models.

---

## Troubleshooting Common Issues

- **No Models Available:** Ensure your API keys are correctly configured and environment variables are set.
- **Unrecognized Queries:** Simplify or rephrase your natural language input.
- **Query Execution Failures:** Inspect error messages shown alongside AI responses.
- **Slow Responses or Timeouts:** Check network connectivity and API rate limits.

If problems persist, consult the [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) guide.

---

## Diagram: Conversational AI Request Flow

```
flowchart TD
  UIInput["User Types Natural Language Query"] --> SendRequest["Send Query & Context to AI Provider"]
  SendRequest --> AIModel["AI Provider (ChatGPT, Ollama, Anthropic)"]
  AIModel --> ReturnResponse["AI Generates SQL & Text Response"]
  ReturnResponse --> ParseResponse["Parse Response & Validate SQL"]
  ParseResponse --> ValidateSQL["Syntax & Safety Check"]
  ValidateSQL -->|Valid| ExecuteSQL["Execute SQL via Database Plugin"]
  ValidateSQL -->|Invalid| ShowError["Return Error to User"]
  ExecuteSQL --> ReturnResults["Return Query Results"]
  ReturnResults --> UIOutput["Display Data & AI Text to User"]

  ShowError --> UIOutput

  subgraph ContextHandling
    UIInput -->|Add Conversation History & Schema Info| SendRequest
  end

  classDef process fill:#cde9f9,stroke:#2a9fd6,stroke-width:2px;
  AIModel,ParseResponse,ValidateSQL,ExecuteSQL,ReturnResponse process

  class UIInput,UIOutput,ShowError fill:#f3f4f6,stroke:#888,stroke-width:1px;
```  

---

## Related Documentation

- [Querying Your Data with AI Chat](https://whodb.com/docs/guides/ai-and-natural-language/conversational-queries-and-ai-models) – Practical guide on using the AI Chat page.
- [System Architecture Overview](https://whodb.com/docs/concepts/architecture-overview/system-architecture) – How AI fits within the overall system.
- [Integrations and Extensibility](https://whodb.com/docs/overview/architecture-concepts-group/integration-overview) – Concepts on AI and plugin integration.
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) – Fix common AI integration problems.

---

Harness WhoDB’s Conversational AI integration to unlock a natural, efficient way to extract insights from your data — no complex query knowledge required, just simple conversations.

---


# concepts/integration-patterns/deployment-integration.mdx
## Deployment & Enterprise Integration Patterns

Get insights into how WhoDB is built for rapid deployment (via Docker, Compose), and how its plugin and modular approach supports integration with enterprise data sources, advanced authentication, and observability platforms.

# Deployment & Enterprise Integration Patterns

Welcome to the Deployment & Enterprise Integration Patterns guide for WhoDB. This documentation will help you understand how WhoDB is designed for rapid deployment and extensibility, particularly focusing on its Docker-based deployment, modular plugin architecture, and Enterprise Edition (EE) capabilities. Whether you're preparing for production deployment, integrating advanced authentication systems, or setting up observability tooling, this guide walks you through the concepts and workflows to make your experience smooth and scalable.

---

## 1. Deployment Architecture Overview

WhoDB is architected to support both Community Edition (CE) and Enterprise Edition (EE) deployments with ease. The backend is written in Go, embedding the frontend assets for a streamlined self-contained server. This design simplifies deployment in containerized or cloud environments.

The system supports:

- **Rapid startup and graceful shutdown:** With sensible defaults like a 30-second shutdown timeout, WhoDB ensures minimal downtime.
- **Environmental flexibility:** Environment variables control ports, edition selection, API gateway behaviors, and allowed origins for CORS.
- **Integrated GraphQL API with Playground:** In development mode, introspection and playground help rapid iteration and testing.

The server supports HTTP/HTTPS with WebSocket transports for GraphQL, enabling real-time features like AI chat and schema updates.

### How Deployment Components Fit Together

```
flowchart TD
  subgraph Backend
    A[WhoDB Server] --> B[GraphQL API]
    A --> C[Static Frontend (Embedded Assets)]
    B --> D[Database Plugins]
    B --> E[Authentication Middleware]
  end

  subgraph Deployment
    F[Docker / Docker Compose] --> A
    G[Environment Variables] --> A
    H[Enterprise Plugins] -.-> A
  end

  subgraph Client
    I[User Browser] -->|HTTP/WS Requests| A
  end

  style Backend fill:#f3f7fa,stroke:#0366d6,stroke-width:1.5px
  style Deployment fill:#e8f0fe,stroke:#555,stroke-width:1.5px,stroke-dasharray: 5 5
  style Client fill:#daf0e4,stroke:#2a9d8f,stroke-width:1.5px
```

---

## 2. Rapid Deployment with Docker and Docker Compose

WhoDB supports containerized deployment for quick, reproducible, and scalable setups. The project provides Dockerfiles for both Community and Enterprise Editions.

### Docker Images and Commands

- **Community Edition (CE):** Use the default `clidey/whodb` image.
- **Enterprise Edition (EE):** Use the enterprise-specific image, requiring access to EE modules.

#### Starting with Docker

```
# Pull and run the Community Edition container
docker run -it -p 8080:8080 clidey/whodb
```

#### Using Docker Compose

```
version: "3.8"
services:
  whodb:
    image: clidey/whodb
    environment:
      - WHODB_OLLAMA_HOST=localhost
      - WHODB_OLLAMA_PORT=11434
      - WHODB_ANTHROPIC_API_KEY=your_key_here
      - WHODB_OPENAI_API_KEY=your_key_here
    ports:
      - "8080:8080"
    volumes:
      - ./data:/db  # optional for persisting local SQLite databases
```

```
docker-compose up
```

### Best Practices

- Persist local databases or configuration via volumes.
- Inject API keys and external service endpoints through environment variables for flexibility and security.
- Use multi-architecture Docker builds for compatibility across platforms.

---

## 3. Modular Plugin Architecture and Enterprise Edition Integration

WhoDB’s backend is powered by a modular plugin engine that abstracts connections to heterogeneous databases into a unified interface. This engine supports a rich portfolio of database types including PostgreSQL, MySQL, MongoDB, Redis, Elasticsearch, and ClickHouse.

### Plugin Management

- The engine registers **Community Edition plugins** by default to support a wide range of common data sources.
- When built with the **Enterprise Edition (`-tags ee`) flag**, additional EE plugins and enterprise features are loaded dynamically.

Enterprise Edition plugins enable advanced enterprise data sources, ports, and extended capabilities without modifying the core.

### EE Initialization Workflow

```
// Simplified EE Initialization Example
func InitializeEngine() *engine.Engine {
    e := &engine.Engine{}

    // Register CE plugins
    e.RegistryPlugin(postgres.NewPostgresPlugin())
    e.RegistryPlugin(mysql.NewMySQLPlugin())
    // ... other CE plugins

    // Initialize EE plugins if EE build enabled
    if initEE != nil {
        initEE(e)
    }

    return e
}
```

This pattern allows the EE features to plug into the main engine only when the EE build flag is set, ensuring clear separation and modular extensibility.

---

## 4. Advanced Authentication and Middleware Integration

WhoDB’s server middleware stack incorporates essential features for security, performance, and observability.

### Middleware Highlights

- **Throttle Backlog:** Controls request concurrency to protect backend stability.
- **Request ID & Real IP:** Enables tracing and correct client IP detection.
- **Logging and Recovery:** Captures request information and handles panics gracefully.
- **Timeouts:** Prevents requests from hanging indefinitely (default 30 seconds).
- **CORS Handling:** Configurable origins and headers support frontend integration and API access control.
- **Authentication Middleware:** Implements session validation and enforces user authentication for protected routes.

Middleware ordering is critical; WhoDB ensures logging, recovery, and throttle happen before authentication to optimize performance and robustness.

### OAuth and Enterprise Authentication

Enterprise users benefit from plugin-based hooks that can extend authentication schemes, enabling integration with SSO, OAuth providers, or external identity services.

---

## 5. Observability and Production Readiness

While WhoDB focuses on lightweight deployment, it supports common operational needs:

- **Logging:** Structured logs emit server startup, request processing, and error events, assisting in monitoring and alerting.
- **Graceful Shutdown:** Ensures resource cleanup and active request completion within configured timeouts.
- **Metrics (Pluggable):** The system can be extended to export Prometheus or other observability metrics by enabling configuration.

---

## 6. Building and Running WhoDB in Enterprise and Production Contexts

This section complements the conceptual overview with practical build-and-run strategies.

### Building Enterprise Edition

To build the EE backend with embedded frontend assets:

```
# Build the frontend EE bundle first
cd frontend
pnpm run build:ee

# Copy frontend build into backend
cp -r ./dist ../core/build/

# Build backend with EE tag
cd ../core
go build -tags ee -o whodb-ee
```

### Running

Start the EE backend:

```
./whodb-ee
```

Access the UI at http://localhost:8080 by default.

### Environment Variables of Note

| Variable                  | Purpose                                              |
|---------------------------|------------------------------------------------------|
| `PORT`                    | Override default backend port (default 8080)         |
| `ENVIRONMENT=dev`         | Enables development features like GraphQL introspection |
| `WHODB_OLLAMA_HOST/PORT`  | Configure Ollama AI integration endpoint             |
| `WHODB_ANTHROPIC_API_KEY` | API key for Anthropic AI model use                    |
| `WHODB_OPENAI_API_KEY`    | API key for OpenAI models                             |
| `WHODB_EDITION=ee`        | Explicitly request Enterprise Edition features        |

When running in `dev` mode, introspection and playground UI activate automatically for easier development.

---

## 7. Troubleshooting Common Deployment Issues

### Problem: Server Fails to Start

- Check port availability (default 8080).
- Confirm your environment variables, especially `PORT` and edition flags.
- Look into logs for fatal errors such as plugin registration failures.

### Problem: GraphQL Playground Not Loading

- Ensure `ENVIRONMENT=dev` is set.
- Confirm CORS origins include your frontend URL.

### Problem: Enterprise Plugins Not Loaded

- Verify the build command includes the `-tags ee` flag.
- Confirm the `ee` directory and modules are present.
- Run validation scripts if available to confirm EE environment.

Attempting to build or run EE features without proper configuration or licensing may result in non-functional plugins or runtime errors.

---

## 8. Summary

WhoDB's deployment and integration design balances ease of use with powerful extensibility:

- Container-first approach enables fast, reliable deployments.
- Modular plugin engine supports broad database and service connectivity.
- Enterprise Edition unlocks advanced data sources and authentication.
- Configurable middleware with built-in security and performance features.

By understanding these patterns, you can confidently deploy, extend, and operate WhoDB at scale.

---

## Additional Resources

- [WhoDB Build and Run Guide](./BUILD_AND_RUN.md) — Practical build and deployment instructions including EE workflows.
- [System Architecture Overview](https://whodb.com/docs/concepts/architecture-overview/system-architecture) — Understand core system components.
- [Plugin Engine & Database Integration](https://whodb.com/docs/concepts/architecture-overview/plugin-engine) — Deep dive into plugin architecture.
- [Security Model & Authentication](https://whodb.com/docs/concepts/security-scalability/security-auth) — How WhoDB handles user authentication and sessions.
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) — Diagnosing common deployment problems.

For assistance, reach out to support@clidey.com or consult the community forums.

---


# deployment/prod_deployment/docker_quickstart.mdx
## Deploying with Docker & Docker Compose

Get started with WhoDB’s preferred deployment methods. Learn how to launch WhoDB using a simple Docker command or a Docker Compose configuration for more complex environments, enabling rapid local evaluation as well as scalable production deployments.

# Deploying with Docker & Docker Compose

Welcome to the WhoDB deployment guide focused on launching the application using Docker and Docker Compose. This approach enables you to quickly spin up WhoDB with all its dependencies in isolated containers, ensuring a consistent and scalable environment for local evaluation and production setups.

---

## Why Deploy with Docker?

Docker streamlines deployment by encapsulating WhoDB and its core dependencies into portable containers. This eliminates environment configuration discrepancies, simplifies installation, and accelerates onboarding. Whether testing locally or running in production, Docker Compose orchestrates multiple containers — databases, caches, and WhoDB — for an integrated setup.

---

## Prerequisites

Before proceeding, ensure the following:

- Docker Engine installed and running (version 24.x or later recommended)
- Docker Compose (v2 or integrated with Docker CLI)
- Sufficient permissions to manage Docker containers and networks
- For production, resource availability as per your usage scale (CPU, memory, disk)

If you prefer manual builds or need custom configurations, see the [WhoDB Build and Run Guide](./BUILD_AND_RUN.md).

---

## Quick Start: Launching WhoDB with Docker

To get WhoDB running swiftly using Docker, you have two easy options:

### 1. Single-Container Docker Run

Pull and run the official WhoDB image directly:

```
# Run WhoDB Community Edition
docker run -it -p 8080:8080 clidey/whodb
```

This launches the WhoDB server accessible at `http://localhost:8080`. This method focuses on simplicity but does not include backend database containers.

### 2. Docker Compose Setup for Integrated Environment

For a richer environment with connected databases, caches, and WhoDB running together, use Docker Compose.

```
docker-compose -f dev/docker-compose.yml up
```

This command:
- Starts containers for PostgreSQL, MySQL, MariaDB, MongoDB, Redis, Elasticsearch, and ClickHouse
- Orchestrates network setup for inter-container communication
- Maps default ports to your local machine for direct access

Access WhoDB at `http://localhost:8080` once all containers are running.

---

## Understanding the Docker Compose Configuration

The [docker-compose.yml](dev/docker-compose.yml) file defines individual service containers with environment variables, volume mappings, port bindings, and network connectivity.

### Key Services Included:

| Service       | Purpose                     | Default Port  |
|---------------|-----------------------------|---------------|
| postgres      | PostgreSQL database          | 5432          |
| mysql         | MySQL database               | 3306          |
| mariadb       | MariaDB database             | 3307 (mapped) |
| mongo         | MongoDB NoSQL database       | 27017         |
| redis         | Redis cache/auth store       | 6379          |
| elasticsearch | Search engine cluster        | 9200          |
| clickhouse    | Analytics database           | 8123, 9000    |

### Volumes and Persistence

Each service uses a Docker volume to persist data outside the container lifecycle, ensuring your data survives container restarts and removals.

### Network Setup

All services connect via a shared Docker bridge network named `db`, allowing WhoDB to discover and communicate with them seamlessly.

---

## Step-by-Step Deployment Workflow

Follow this sequence to deploy and verify your WhoDB instance with Docker Compose:

If you haven't already, clone the repository or ensure access to the deployment files including the `docker-compose.yml`.

Review and customize environment variables (e.g., database usernames, passwords) in the `docker-compose.yml` if default credentials do not meet your security standards.

Run:

```
docker-compose -f dev/docker-compose.yml up -d
```

Options:
- `-d` runs containers in detached mode.
- Monitor logs with `docker-compose logs -f`.

Ensure all containers are running:

```
docker ps --filter network=db
```

Check logs for errors or failed startups.

Open your browser to `http://localhost:8080`. You should see the WhoDB interface.

Using WhoDB’s UI, configure connections to your databases running in containers or externally. Credentials from Docker Compose serve as defaults.

---

## E2E Testing Environment Using Docker Compose

Developers and testers can leverage a specialized setup using the `docker-compose.e2e.yaml` file for end-to-end testing.

### Setup Script

The script `dev/setup-e2e.sh` automates this environment creation:

- Cleans existing test state with `cleanup-e2e.sh`
- Builds test binaries with coverage
- Sets up an SQLite test database
- Launches containerized databases with seed data
- Validates containers’ health
- Starts the test server with coverage enabled

Run it as:

```
bash dev/setup-e2e.sh
```

This setup ensures consistent, repeatable test conditions for integration and system tests.

---

## Best Practices for Docker Deployment

- **Use Secure Credentials**: Override default usernames and passwords to harden your environment.
- **Data Backup**: Regularly back up Docker volumes storing databases to prevent data loss.
- **Resource Allocation**: Monitor and allocate sufficient CPU and memory to containers for optimal performance.
- **Use Environment Variables**: Leverage Docker Compose environment overrides and `.env` files for configuration flexibility.
- **Update Images Periodically**: Pull updated images for WhoDB and database containers to incorporate fixes and improvements.

---

## Troubleshooting Common Docker Deployment Issues

Verify logs with:

```
docker-compose logs 
```

Common causes include port conflicts, corrupted volumes, or misconfigured environment variables.

Ensure local machine ports (e.g., 8080, 5432) are not already in use:

```
lsof -i :8080
```

Kill conflicting processes or change ports in the Docker Compose file.

Confirm that Docker volumes are defined and mounted correctly. Inspect volumes with:

```
docker volume ls
```

Avoid using ephemeral containers for production data.

- Confirm the WhoDB container is running.
- Check firewall and Docker network settings.
- Confirm port forwarding is configured correctly.
- Use `docker logs` to check for startup errors.

---

## Advanced Configuration

### Customizing Docker Compose for Production

- Scale services using Docker Compose profiles or Kubernetes for larger deployments.
- Consider isolating WhoDB backend and frontend behind reverse proxies or load balancers.
- Secure communication with SSL/TLS for both WhoDB and database services.

### Running Enterprise Edition

To deploy the Enterprise Edition with Docker, build the Enterprise Docker image using the `core/Dockerfile.ee` and run similarly with Docker Compose, ensuring you have the proper EE license and modules.

```
docker build -f core/Dockerfile.ee -t whodb:ee .
```

Update your Docker Compose service image accordingly.

---

## Summary

Deploying WhoDB with Docker and Docker Compose brings speed, reliability, and modularity to your deployment process. Whether launching quickly for evaluation or building a scalable, multi-service production environment, these instructions guide you step-by-step from setup to troubleshooting.

For full command references, build options, and manual deployment, see the [Build and Run Guide](./BUILD_AND_RUN.md).

---

For further assistance, consult related documentation or reach out to the WhoDB community and support channels.

---


# deployment/prod_deployment/env_config.mdx
## Environment Variables & Third-Party Integrations

Understand how to configure core environment variables, set up API keys for LLM integrations (Ollama, OpenAI, Anthropic), enable or disable telemetry, and manage secrets securely. This page provides practical advice and variable reference for maximizing WhoDB’s features while adhering to security best practices.

# Environment Variables & Third-Party Integrations

Configuring WhoDB for production and advanced usage requires setting key environment variables that govern core system behavior, third-party AI integrations, telemetry, and secrets management. This page guides you through configuring these essential environment variables to unlock the full potential of WhoDB while adhering to security best practices.

---

## 1. Core Environment Variables

These variables form the foundation of your WhoDB deployment environment and control critical settings across backend and frontend components.

### 1.1 Application Mode & Build Edition

- `ENVIRONMENT`
  - Purpose: Defines the runtime mode
  - Recommended Values:
    - `dev` — Enables developer features like GraphQL introspection
    - `prod` (default) — Production-ready optimizations

- `VITE_BUILD_EDITION`
  - Purpose: Selects the frontend build edition
  - Options:
    - `ce` — Community Edition
    - `ee` — Enterprise Edition (requires EE build and license)

### 1.2 Backend Server Settings

- `PORT`
  - Purpose: Configures the port on which the backend server listens
  - Default: `8080`

- `WHODB_TOKENS`
  - Purpose: Enables API gateway token-based authentication
  - Format: Comma-separated tokens (e.g. `token1,token2`)
  - When set, API Gateway mode activates enforcing token validation for protected routes

Always ensure `PORT` does not conflict with other services and API tokens are kept secret. Using `WHODB_TOKENS` secures API access for automation or multi-user deployments.

### 1.3 Database Credential Profiles

WhoDB supports multiple database profiles via environment variables for automatic credential discovery.

- Format for Single Profile:
  - `WHODB_` e.g. `WHODB_POSTGRES`
  - Value: JSON string representing one or more credentials

- Format for Multiple Profiles:
  - `WHODB__1`, `WHODB__2`, etc.
  - Each holds a JSON string for a single credential profile

- Supported Database Types:
  - POSTGRES, MYSQL, MONGODB, SQLITE3, CLICKHOUSE, etc.

Credential JSON structure must include fields such as `alias`, `host`, `user`, `password`, `database`, `port`, and optional `config` key-value pairs.

Example single profile JSON:
```
[
  {
    "alias": "MainPostgres",
    "host": "localhost",
    "user": "admin",
    "password": "secret",
    "database": "postgres_db",
    "port": "5432",
    "config": {}
  }
]
```

## 2. AI and LLM Provider Integration Variables

WhoDB’s conversational AI features integrate with multiple LLM providers. To enable these, you configure API keys, endpoints, and allowlist origins.

### 2.1 Ollama Integration

- `WHODB_OLLAMA_HOST`
  - Default: `localhost`
  - Description: Custom hostname for Ollama API

- `WHODB_OLLAMA_PORT`
  - Default: `11434`
  - Description: Custom port for Ollama API

> Ollama integration requires the Ollama server accessible on the configured host and port.

### 2.2 OpenAI Integration

- `WHODB_OPENAI_API_KEY` (Required to enable)
- `WHODB_OPENAI_ENDPOINT` (Optional)
  - Default: `https://api.openai.com/v1`

### 2.3 Anthropic Integration

- `WHODB_ANTHROPIC_API_KEY` (Required to enable)
- `WHODB_ANTHROPIC_ENDPOINT` (Optional)
  - Default: `https://api.anthropic.com/v1`

### 2.4 OpenAI-Compatible Providers

Designed to support self-hosted or third-party APIs that mimic OpenAI.

- `WHODB_OPENAI_COMPATIBLE_API_KEY`
- `WHODB_OPENAI_COMPATIBLE_ENDPOINT`
- `WHODB_CUSTOM_MODELS`
  - Comma-separated list of custom model names

### 2.5 Allowed Origins

- `WHODB_ALLOWED_ORIGINS`
  - Comma-separated list of allowed CORS origins for the API

Do not expose API keys in public or insecure environments. Secure keys with environment-specific secrets managers.

## 3. Telemetry and Feature Flags

While WhoDB collects optional telemetry to improve the product, this can be disabled for privacy.

- `WHODB_TELEMETRY_DISABLED`
  - Set to any non-empty value to opt out of telemetry collection.

- Feature flags are managed internally and vary between Community and Enterprise Editions.

Enterprise Edition feature flags enable extended capabilities including AI Chat, multi-profile support, custom themes, and advanced database support. These flags are automatically managed by the EE build system.

## 4. Managing Secrets Securely

Because WhoDB relies on environment variables for sensitive data such as API keys and database passwords, follow these best practices:

- Use environment variable injection mechanisms specific to your deployment platform (e.g., Docker secrets, Kubernetes secrets, .env files excluded from version control).
- Avoid committing secrets to source repositories or logs.
- Rotate credentials and keys regularly.
- Leverage encrypted secrets management tools when possible.

For Docker Compose deployments, map external secret files or use `.env` files carefully, and restrict file permissions for stored secret files.

## 5. Example Docker Environment Configuration

Below is a minimal example of environment variables to enable WhoDB with PostgreSQL and basic AI chat features using OpenAI:

```
version: "3.8"
services:
  whodb:
    image: clidey/whodb:latest
    ports:
      - "8080:8080"
    environment:
      - ENVIRONMENT=prod
      - PORT=8080
      - WHODB_TOKENS=your-secure-token
      - WHODB_POSTGRES='[{"alias":"primary","host":"db","user":"admin","password":"secret","database":"mydb","port":"5432","config":{}}]'
      - WHODB_OPENAI_API_KEY=sk-xxxxxxx
      - WHODB_ALLOWED_ORIGINS=http://localhost:3000,http://mydomain.com
    volumes:
      - ./data:/db
```

## 6. Troubleshooting Environment Variable Issues

Check for proper JSON formatting without trailing commas and valid field naming. Parse errors will be logged in the backend.

Ensure API keys are set correctly and not empty. Missing keys disable AI model integration silently.

Confirm no other service occupies the configured backend port. Use `lsof` or equivalent to find conflicts.

Verify variable declarations in Docker Compose or Kubernetes manifests and confirm containers restart after environment changes.

---

## References & Next Steps

- For database connection details, see the [Connecting to Your Database guide](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database).
- To understand AI capabilities setup, consult the [Conversational AI Integration page](https://whodb.com/docs/concepts/integration-patterns/ai-integration).
- For initial launch steps and validation, visit [Initial Configuration and First Run documentation](https://whodb.com/docs/getting-started/initial-config-launch/initial-configurations).
- Explore security best practices in the [Security and Authentication Essentials guide](https://whodb.com/docs/guides/best-practices-and-optimization/security-and-authentication).

---

## Additional Resources

- [Build and Run Guide (BUILD_AND_RUN.md)](https://github.com/clidey/whodb/blob/main/BUILD_AND_RUN.md) — for detailed build, run, and environment setup instructions
- [Docker Quick Start](https://whodb.com/docs/deployment/prod_deployment/docker_quickstart) — for containerized deployment options

---

By carefully configuring these environment variables and managing secrets securely, you ensure WhoDB runs reliably, securely, and fully leverages its AI-powered features in your production or development environments.

---

### Quick Reference Table

| Environment Variable            | Purpose                                             | Notes                                         |
|-------------------------------|-----------------------------------------------------|-----------------------------------------------|
| `ENVIRONMENT`                  | Set runtime mode (`dev` or `prod`)                  | Enables GraphQL introspection if `dev`       |
| `VITE_BUILD_EDITION`           | Frontend edition (`ce` or `ee`)                      | Must match backend EE build                    |
| `PORT`                        | Backend server port                                  | Defaults to 8080                              |
| `WHODB_TOKENS`                | API gateway tokens (comma-separated)                 | Enables API gateway enforcement                 |
| `WHODB_`              | JSON-encoded database credentials                    | Supports multiple profiles via `_1`, `_2`, etc |
| `WHODB_OLLAMA_HOST`            | Hostname for Ollama AI service                      | Defaults to `localhost` or `host.docker.internal` inside Docker |
| `WHODB_OLLAMA_PORT`            | Port for Ollama API                                 | Defaults to `11434`                            |
| `WHODB_OPENAI_API_KEY`        | API key for OpenAI                                  | Required to enable ChatGPT integration          |
| `WHODB_OPENAI_ENDPOINT`        | Custom OpenAI endpoint                              | Defaults to public OpenAI endpoint            |
| `WHODB_ANTHROPIC_API_KEY`     | API key for Anthropic                               | Required for Anthropic integration             |
| `WHODB_ANTHROPIC_ENDPOINT`     | Custom Anthropic endpoint                           | Defaults to Anthropic public endpoint         |
| `WHODB_OPENAI_COMPATIBLE_API_KEY` | API key for OpenAI-compatible APIs                | Requires custom models configuration          |
| `WHODB_OPENAI_COMPATIBLE_ENDPOINT` | Endpoint for OpenAI-compatible APIs                | Required for custom integrations               |
| `WHODB_CUSTOM_MODELS`          | Comma-separated list of custom model names          | Used with compatible API keys                   |
| `WHODB_ALLOWED_ORIGINS`       | Allowed CORS origins (comma-separated URLs)          | Secures API access from trusted domains       |
| `WHODB_TELEMETRY_DISABLED`    | Disable telemetry collection                         | Set to any non-empty string to opt-out          |

---

For precise syntax and examples, always refer to the [Build and Run Guide](https://github.com/clidey/whodb/blob/main/BUILD_AND_RUN.md) and ensure environment variable files or container configs do not expose secrets inadvertently.

---

# End of Environment Variables & Third-Party Integrations Documentation

---


# deployment/prod_deployment/edition_selection.mdx
## Choosing Community vs. Enterprise Edition

Decide which version of WhoDB to deploy by comparing features, deployment mechanics, and licensing differences. This page outlines edition-specific build steps and how to switch between Community and Enterprise deployments, ensuring users choose the right foundation for their needs.

# Choosing Community vs. Enterprise Edition

Selecting the appropriate edition of WhoDB is a critical step that shapes your deployment experience, capabilities, and maintenance approach. This guide helps you understand the fundamental differences between the Community Edition (CE) and Enterprise Edition (EE), clarifies build and deployment flow distinctions, and provides actionable steps to switch between editions, ensuring your deployment foundation matches your organizational needs.

---

## 1. Overview of Editions

WhoDB offers two main editions, each tailored to distinct user groups and deployment scenarios:

| Feature Aspect             | Community Edition (CE)                            | Enterprise Edition (EE)                           |
|----------------------------|-------------------------------------------------|-------------------------------------------------|
| **Target Users**            | Individual developers, small teams, open source enthusiasts | Organizations requiring enhanced functionality, scalability, and enterprise integrations |
| **Feature Set**             | Core database support including PostgreSQL, MySQL, SQLite3, MongoDB, Redis, Elasticsearch, ClickHouse | All CE features plus advanced plugins, enhanced authentication, compliance features, and enterprise-grade support |
| **Licensing**               | Open source under Apache 2.0                      | Commercial license with additional legal terms and support contracts |
| **Extensibility**           | Plugin architecture with core database adapters  | Extended plugin ecosystem including proprietary enterprise plugins and middleware |
| **Support & Maintenance**  | Community-driven with public issue tracking      | Dedicated support, patches, and SLAs             |

Choosing between CE and EE depends on your specific requirements around features, scalability, support, and licensing. CE is ideal for cost-sensitive or community-powered projects, whereas EE empowers enterprise deployments with additional capabilities and assurances.

## 2. Feature Differences in Detail

### Core Plugin Availability
Community Edition provides a solid foundation supporting the following databases through official plugins:

- PostgreSQL
- MySQL and MariaDB
- SQLite3
- MongoDB
- Redis
- Elasticsearch
- ClickHouse (Community variant)

Enterprise Edition builds on this foundation by registering additional proprietary plugins during engine initialization, enhancing compatibility and functionality.

### Authentication and Security Enhancements
EE offers advanced authentication schemes and tighter security integrations beyond the basic credential mechanisms in CE, aligning with enterprise compliance and governance standards.

### AI and Conversational Query Capabilities
Both editions embed AI-augmented data conversational capabilities, but EE may include support for specialized AI providers or models that require licensing.

### Deployment and Observability
Enterprise Edition includes middleware components supporting observability, monitoring, and integration with enterprise operational toolchains.

The above feature distinctions are enforced both at build time and run time by selecting the appropriate edition flag.

## 3. How to Build and Switch Editions

WhoDB's source supports dual edition build paths. The backend binary and frontend artifacts can be built specifically for CE or EE.

### 3.1 Backend Build Steps

You can build the backend for either edition using the provided script:

```
./scripts/build-backend.sh [ce|ee]
```

- Running `./scripts/build-backend.sh ce` generates the Community Edition backend binary (`whodb`).
- Running `./scripts/build-backend.sh ee` generates the Enterprise Edition backend binary (`whodb-ee`).

This script performs the following steps:

1. Generates GraphQL code tailored for the selected edition.
2. Downloads necessary Go dependencies.
3. (For EE) Downloads additional Enterprise dependencies.
4. Runs `go generate` if necessary.
5. Compiles the binary with edition-specific build flags.

Building EE requires access to the `ee` directory containing proprietary code, which must be present in the project root.

### 3.2 Frontend Edition Configuration

The frontend selects the edition via an environment variable `VITE_BUILD_EDITION`. It defaults to `ce`.

```
export const BUILD_EDITION = (import.meta.env.VITE_BUILD_EDITION as 'ce' | 'ee') || 'ce';
```

You can switch the UI edition by setting this variable before building the frontend:

```
VITE_BUILD_EDITION=ee pnpm run build
```

The UI will then load edition-specific GraphQL schema and features appropriately.

### 3.3 Runtime Edition Selection

The backend binary built for a specific edition will register plugins and enable features accordingly during engine initialization.

In the source code, enterprise plugins are registered only when the EE initialization function is set and invoked:

```
if initEE != nil {
    initEE(MainEngine)
}
```

If this function is not set (such as in CE builds), EE-only functionality is omitted.

Be sure to deploy the matching backend and frontend editions to avoid feature mismatch issues.

## 4. Licensing and Compliance Implications

- CE is offered under the permissive Apache License 2.0, allowing free use, distribution, and modification.
- EE typically requires a commercial license agreement; consult your legal counsel before deploying EE in production.

Adherence to licensing is crucial to maintain compliance and gain official support for EE.

## 5. Troubleshooting Edition Switching

If you encounter issues where EE features do not appear after building:

- Verify the backend binary is built with the `ee` tag.
- Confirm the frontend environment variable `VITE_BUILD_EDITION=ee` is set.
- Ensure the `ee` directory is present and contains the necessary enterprise source.
- Check logs during startup for plugin registration errors.

## 6. Summary and Recommendations

| Scenario                   | Recommendation                             |
|----------------------------|--------------------------------------------|
| Small projects, open source exploration | Use Community Edition for simplicity and cost savings |
| Teams needing enterprise plugins, advanced auth | Choose Enterprise Edition and follow EE build instructions |
| Migrating or testing EE | Build both editions side-by-side and test integration before deployment |

---

## Appendix: Build Script Insights

The `build-backend.sh` script orchestrates the build process with these key phases:

- **GraphQL Code Generation:** Ensures schema matches edition
- **Dependency Management:** Downloads Go modules for core and EE
- **Code Generation:** Runs `go generate` on Go files
- **Binary Compilation:** Uses `-tags ee` for Enterprise builds; binary named `whodb-ee`
- **Version Metadata:** Incorporates Git version info into build

This careful separation enforces edition integrity and enables seamless switching.

---

## Additional Resources

For deeper deployment guidance, see:

- [Deploying with Docker & Docker Compose](https://whodb.com/docs/deployment/prod_deployment/docker_quickstart)
- [Environment Variables & Third-Party Integrations](https://whodb.com/docs/deployment/prod_deployment/env_config)
- [Build & Run Guide (GitHub)](https://github.com/clidey/whodb)
- [Plugin Engine Architecture](https://whodb.com/docs/concepts/architecture-overview/plugin-engine)

## Related Documentation

- [Getting Started: Installation Methods](https://whodb.com/docs/getting-started/setup-requirements/installation-methods)
- [System Architecture Overview](https://whodb.com/docs/overview/architecture-concepts-group/system-architecture-overview)
- [Security & Authentication Essentials](https://whodb.com/docs/guides/best-practices-and-optimization/security-and-authentication)

---

Deploy with confidence by accurately aligning your choice of Community or Enterprise Edition with your project goals and operational demands.

---


# deployment/operationalization/monitoring_logging.mdx
## Monitoring and Logging

Monitor the health and activity of your WhoDB deployment. Discover how to capture logs, hook WhoDB into external monitoring systems, interpret common metrics, and troubleshoot effectively. This page provides troubleshooting best practices and links out to relevant log configuration files.

# Monitoring and Logging

Monitoring the health and activity of your WhoDB deployment is essential for maintaining reliability, diagnosing issues, and ensuring smooth production operations. This guide walks you through capturing logs, integrating with external monitoring systems, interpreting key metrics, and troubleshooting effectively.

---

## Table of Contents
1. [Introduction to Monitoring and Logging](#introduction-to-monitoring-and-logging)
2. [Logging Overview](#logging-overview)
3. [Configuring WhoDB Logging](#configuring-whodb-logging)
4. [Integrating with External Monitoring Systems](#integrating-with-external-monitoring-systems)
5. [Key Metrics to Monitor](#key-metrics-to-monitor)
6. [Troubleshooting Common Log Issues](#troubleshooting-common-log-issues)
7. [Best Practices for Monitoring WhoDB](#best-practices-for-monitoring-whodb)
8. [Additional Resources](#additional-resources)

---

## Introduction to Monitoring and Logging

Running WhoDB in production demands visibility into application behavior and system health. Logs provide a real-time and historical record of application events and errors, enabling you to audit activity, detect failures, and optimize performance.

Monitoring extends beyond logs by capturing system and application metrics, alerting on anomalies and helping maintain uptime.

This page focuses on practical guidance to set up, utilize, and troubleshoot WhoDB logs, and to integrate them with monitoring infrastructure.

---

## Logging Overview

WhoDB employs structured logging using the `logrus` package, allowing logs to be outputted with levels such as Info, Warning, and Fatal.

Logs include:
- Startup and shutdown sequences
- API and backend errors
- Database plugin activity
- AI integration warnings

Logs are written to stdout/stderr by default, making them Docker and cloud-friendly.

---

## Configuring WhoDB Logging

### Default Logging Behavior

By default, WhoDB logs essential server lifecycle events:

```
INFO Starting WhoDB...
INFO Welcome to WhoDB!
INFO Get started by visiting: http://0.0.0.0:8080
```

Warnings and errors are also logged with descriptive messages.

### Customizing Log Levels or Outputs

Currently, WhoDB’s configuration defaults to info-level logs, but the `log` package uses `logrus`, which supports advanced configuration.

To enable advanced log configuration (e.g., JSON output or file logging), you can extend the `core/src/log/log.go` initialization with custom hooks or redirect output.

### Viewing Logs in Docker

If running WhoDB via Docker, use:

```
docker logs 
```

for real-time access to stdout logs.

### Log Format

Logs follow this format:

```
  
```

Warnings and errors provide call-site context aiding root cause analysis.

---

## Integrating with External Monitoring Systems

### Containerized Deployment

When deploying via Docker or Docker Compose, you can leverage Docker's native log drivers to forward WhoDB logs to:

- syslog
- Fluentd
- ELK Stack (Elasticsearch, Logstash, Kibana)
- Cloud logging services (AWS CloudWatch, GCP Stackdriver, Azure Monitor)

Configure logging drivers in your Docker daemon or compose file.

### Exporting Logs

For persistent log storage, mount your container's log directory or redirect logs to a file volume, then ingest with your observability stack.

### Application Metrics

Though primarily focused on logs, WhoDB exposes operational metrics (see the environment variable `MetricsEnabled` in the backend), which can integrate with Prometheus or other alerting platforms if extended.

Check the production deployment docs or source to enable and configure metrics collection.

---

## Key Metrics to Monitor

While detailed metrics collection requires additional configuration, here are key logical monitoring areas:

- **Server Health**: Uptime, CPU and memory usage
- **Request Rates**: Incoming API requests per second
- **Error Rates and Types**: HTTP 5xx errors or database connection failures
- **Plugin Activity**: Status and latency of database connectors
- **AI Integration Warnings**: Failures connecting to ChatGPT, Ollama, or Anthropic

Active monitoring of these metrics ensures responsiveness and stability.

---

## Troubleshooting Common Log Issues

### Missing Logs or Silent Failures

- Confirm WhoDB started and is running (check Docker logs or console output).
- Verify environment variables that control logging or metrics (`ENVIRONMENT`, `MetricsEnabled`).
- For containerized deployments, ensure proper volume mounts and stdout forwarding.

### Port Conflicts

If logs report failure to bind port 8080:

```
lsof -i :8080
kill -9 
```

Kill conflicting service before restarting WhoDB.

### AI Integration Logs

Warnings such as:

```
WARN Failed to open browser: ...
WARN Unsupported platform. Please open the URL manually
```

are non-critical and indicate environment limitations.

Ensure required API keys are properly configured as per environment variable documentation.

### Frontend Build Missing Errors

Errors about missing `build/` indicate frontend assets are not embedded correctly:

- Run frontend build
- Copy the build folder to backend

See [BUILD_AND_RUN.md](./BUILD_AND_RUN.md) for detailed instructions.

---

## Best Practices for Monitoring WhoDB

- **Leverage Docker logging drivers or a centralized logging solution** to collect, search, and alert on WhoDB logs.
- **Enable environment-based log level adjustments** where possible, especially for debugging production issues.
- **Regularly review logs post-deployment** to detect anomalies early.
- **Setup metric collection and alerting** for critical system and integration failures.
- **Maintain a clean shutdown and restart procedure** to avoid resource leaks, visible in logs.

---

## Additional Resources

- [Build and Run Guide](./BUILD_AND_RUN.md): For deployment and build instructions
- [Environment Variables & Third-Party Integrations](./deployment/prod_deployment/env_config): Configuring logging, metrics, and AI providers
- [Troubleshooting Common Issues](./getting-started/troubleshooting/troubleshooting-common-issues): Common operational problems and resolutions
- [System Architecture Overview](./concepts/architecture-overview/system-architecture): Understanding modular components generating logs
- [Monitoring and Logging](./deployment/operationalization/monitoring_logging): For related monitoring concepts

---

Keeping your WhoDB deployment well-monitored and logged is pivotal to operational excellence. Use this guide to establish a robust observability foundation that empowers efficient troubleshooting, system insight, and seamless production performance.

---


# deployment/operationalization/scaling_performance.mdx
## Scaling Strategies and Performance Optimization

Explore practical approaches for scaling WhoDB horizontally or vertically, including container-based scaling, resource tuning, and handling high concurrency. Tap into best practices for lightweight operation (in-memory modes, lazy-loading) and performance enhancements at scale.

# Scaling Strategies and Performance Optimization

Welcome to the guide dedicated to scaling WhoDB effectively and optimizing its performance to meet your production demands. This page is your trusted resource for practical, actionable strategies that ensure WhoDB operates smoothly as your data volume, concurrent users, and complexity grow.

Whether you're deploying WhoDB for a small team or scaling it for enterprise-grade workloads, this guide walks you through proven approaches—from resource tuning and containerized scaling to handling high concurrency and enhancing performance with lightweight operation techniques.

---

## 1. Understanding WhoDB's Scaling Context

WhoDB is designed as a lightweight, performant database management tool primarily focused on providing users with a responsive, intuitive interface. Its architecture supports integration across diverse databases and leverages a modular, plugin-based backend alongside a React-powered frontend.

Scaling WhoDB effectively means ensuring that user interactions—such as data exploration, schema visualization, natural language querying, and inline editing—remain fast and fluid even under heavy loads or large datasets.

---

## 2. Horizontal and Vertical Scaling Approaches

### Horizontal Scaling

Scaling horizontally involves running multiple instances of WhoDB behind a load balancer, distributing user load and increasing availability.

- **Containerized Deployments**: Use Docker Compose or orchestration platforms like Kubernetes to deploy multiple WhoDB containers.
- **Load Balancers**: Configure NGINX, HAProxy, or cloud-based load balancers to route traffic among instances.
- **Session Handling**: Since WhoDB handles authentication with session tokens (HTTP-only cookies), ensure sticky sessions or centralized session storage if necessary to maintain seamless user experience.

**Benefits:**
- Improved fault tolerance by avoiding single points of failure.
- Capacity to serve increased concurrent users.

### Vertical Scaling

Vertical scaling involves allocating more resources (CPU, memory) to a single WhoDB instance.

- Increase CPU cores to enhance query processing, especially for complex schema visualizations or scratchpad executions.
- Allocate more RAM to improve caching and responsiveness.

**Benefits:**
- Simpler deployment without distributed system complexity.
- Effective for moderate increases in load.

### Best Practice: Combine both strategies when appropriate for predictable high load environments.

---

## 3. Container-Based Scaling

Docker and container orchestration are the recommended ways to deploy and scale WhoDB:

1. **Use Docker Compose for Basic Horizontal Scaling:**

   - Define multiple WhoDB service instances.
   - Map ports via load balancer or reverse proxy.

2. **Leverage Kubernetes for Enterprise-Grade Scaling:**

   - Deploy WhoDB as a Deployment with multiple replicas.
   - Use Kubernetes Service for load balancing.
   - Configure readiness and liveness probes for health checks.

3. **Persist Data Appropriately:**

   - WhoDB itself manages connections to external databases.
   - Ensure persistent storage for mounted SQLite files if applicable.
   - Backup WhoDB configurations and environment variables securely.

4. **Resource Allocation:**

   - Set resource limits and requests explicitly in your container specs to avoid resource contention.

Use container orchestration features like auto-scaling based on CPU or memory to dynamically adjust WhoDB instances according to actual load.

---

## 4. Resource Tuning for Optimal Performance

Ensuring WhoDB runs efficiently involves tuning CPU, memory, network, and storage:

- **CPU:**
  - Allocate dedicated CPU cores on production machines.
  - For containerized deployments, reserve appropriate CPU shares.

- **Memory:**
  - Minimum recommended memory size depends on usage but allocate at least 2GB RAM for standard deployments.
  - Monitor memory usage to detect leaks or spikes.

- **Network:**
  - Ensure low latency between WhoDB servers and underlying databases.
  - Use secure, fast connections (e.g., VPC peering, VPN) especially in cloud setups.

- **Storage:**
  - For SQLite deployments, mount databases from persistent volumes.
  - For other databases, ensure WhoDB has reliable and fast access to the data source.

Monitor real-time resource utilization and adjust container or host settings accordingly to prevent CPU throttling or out-of-memory failures.

---

## 5. Handling High Concurrency

Users expect near-instantaneous responses even during spikes. Achieve this by:

- **Connection Pooling:**
  - Manage database connections efficiently in the backend plugin engine.
  - Prevent saturating database connection limits.

- **Query Optimization:**
  - Use WhoDB smart filters and pagination to limit returned data volumes.
  - Avoid loading excessively large datasets in UI views.

- **Backend Scaling:**
  - Horizontal scaling with multiple backend instances spreads load.

- **Frontend Efficiency:**
  - WhoDB's React frontend employs virtual scrolling and lazy loading.
  - Avoid fetching all data at once.

If you notice latency under load, inspect and optimize slow queries or consider increasing instance count dynamically.

---

## 6. Lightweight Operation and Lazy Loading

WhoDB excels as a lightweight tool — this has vital performance implications:

- **In-Memory Modes:**
  - Frontend uses in-memory caching to speed repeated interactions.

- **Lazy Loading:**
  - UI only fetches data and schema information on demand.
  - Pagination limits data fetched per request (default 10 rows per page with configurable options).

- **Table Virtualization:**
  - Large tables render efficiently without overwhelming the browser.

Make use of smart filters and pagination controls to maintain UI responsiveness when working with big datasets.

---

## 7. Performance Enhancements at Scale

To further optimize WhoDB:

- **Enable Telemetry and Metrics:**
  - By default, WhoDB collects performance metrics to improve UX.
  - Toggle schema in Settings > Telemetry and Performance Metrics.

- **Cache Schema & Metadata:**
  - Cache database schema snapshots to reduce repeated calls.

- **Optimize Plugin Configuration:**
  - Disable unnecessary database plugins to reduce overhead.

- **Monitor Logs and Metrics:**
  - Regularly check logs for slow queries, errors, or connection issues.

- **Use Latest Builds:**
  - Keep WhoDB updated to benefit from ongoing performance improvements.

Follow best practices from [Monitoring and Logging](https://whodb.com/docs/deployment/operationalization/monitoring_logging) to proactively detect bottlenecks.

---

## 8. Troubleshooting Common Performance Issues

- Ensure filters and pagination are properly applied.
- Avoid requesting all rows in one go.
- Analyze database query performance outside WhoDB.
- Check network latency.

- Inspect container resource limits.
- Identify memory leaks by monitoring over time.
- Reduce simultaneous users or scale horizontally.

- Verify database connection pool sizes.
- Confirm network reliability.
- Implement retry policies for transient failures.

- Update frontend with latest builds.
- Ensure table virtualization is enabled.
- Limit data fetched per view.

---

## 9. Summary and Best Practices

- Use container orchestration for scalable, reliable deployments.
- Combine horizontal and vertical scaling per your environment.
- Utilize WhoDB's lazy-loading and pagination to manage large datasets.
- Monitor application health, resource usage, and logs continuously.
- Tune database connection pooling to fit your workload.
- Keep telemetry enabled (or disabled in Enterprise with privacy considerations) to gain insights.
- Keep WhoDB updated to benefit from performance fixes and enhancements.

---

## 10. Additional Resources

- [Deploying with Docker & Docker Compose](https://whodb.com/docs/deployment/prod_deployment/docker_quickstart) - fast start and containerization instructions.
- [Monitoring and Logging](https://whodb.com/docs/deployment/operationalization/monitoring_logging) - setup for observability.
- [Working Efficiently with Large Datasets](https://whodb.com/docs/guides/best-practices-and-optimization/working-efficiently-with-large-datasets) - UX focus for performance.
- [System Architecture Overview](https://whodb.com/docs/overview/architecture-concepts-group/system-architecture-overview) - deeper insight into internal flows.

---

Scaling WhoDB intelligently empowers your teams with reliable, swift database interaction at any scale. By applying these strategies and tuning principles, you unlock the true potential of WhoDB’s lightweight yet powerful design.

---

---


# deployment/operationalization/backup_disaster_recovery.mdx
## Backup and Disaster Recovery

Protect your data and minimize downtime by following backup and recovery best practices. Learn how to back up both configuration and database data for all supported databases, implement restoration workflows, and automate regular safety checks for peace of mind.

# Backup and Disaster Recovery

Protecting your data and ensuring rapid recovery in case of failures or data loss are paramount in maintaining a reliable WhoDB deployment. This guide provides practical instructions on how to back up both configuration and database data for all supported database engines, restore from backups efficiently, and set up automated backup routines and integrity checks to minimize downtime and prevent data loss.

---

## 1. Understanding Backup Types in WhoDB

WhoDB requires backing up two key components to ensure full recovery capability:

- **Configuration Data**: This includes WhoDB’s environment variables, login profiles, and system settings that control how the service connects to your databases.
- **Database Data**: The actual content of your databases managed and visualized through WhoDB, which may be SQL or NoSQL depending on your chosen backend.

Backing up your database data is distinct from WhoDB but crucial since WhoDB acts as a visualization and management layer on top of these data stores.

---

## 2. Backing Up Your Database Data

WhoDB supports multiple databases including PostgreSQL, MySQL, SQLite3, MongoDB, Redis, Elasticsearch, MariaDB, and ClickHouse. Backup procedures vary by database type:

### PostgreSQL

1. Use `pg_dump` or `pg_basebackup` for full database dumps.
2. Example full dump command:

```
pg_dump -U user -h localhost -Fc -d postgres -f whodb_postgres_backup.dump
```
3. Store backups securely off the primary database host.

### MySQL and MariaDB

1. Use `mysqldump` to export the entire database.
2. Example command:

```
mysqldump -u user -p password mysql > whodb_mysql_backup.sql
```
3. Regularly verify backups by importing to a test environment.

### SQLite3

1. Simply copy the SQLite `.db` files that you have mounted into the container.
2. Example:

```
cp sample.db sample_backup.db
```

### MongoDB

1. Use `mongodump` for full BSON data backups.
2. Example:

```
mongodump --username user --password password --out ./whodb_mongo_backup
```

### Redis

1. Copy the Redis dump file, usually `dump.rdb`, from Redis data directory.
2. Optionally save snapshot on demand with `SAVE` or `BGSAVE` commands.

### Elasticsearch

1. Use snapshot and restore API to back up indices to a shared FS or cloud repository.
2. Snapshot commands require repository registration.

### ClickHouse

1. Use ClickHouse’s built-in backup tools or export tables as needed.

---

## 3. Backing Up WhoDB Configuration

WhoDB configurations are defined primarily through environment variables and Docker volumes:

- Store your Docker Compose files and `.env` files securely.
- Backup any mounted volumes linked to WhoDB’s configuration or runtime data.
- Ensure that your login profiles, including credentials set via environment variables, are saved in secure key management systems or vaults.

---

## 4. Restoration Workflows

When disaster strikes and you must restore your WhoDB deployment, follow these steps:

### Step 1: Restore Your Database

- Restore from the backup files using database-specific tools (`pg_restore`, `mysql`, `mongorestore`, etc.)
- Confirm the database is operational and accessible.

### Step 2: Restore WhoDB Configuration

- Redeploy WhoDB using your saved Docker Compose and environment files.
- Ensure database connection profiles and credentials are accurate and secure.

### Step 3: Validate the Deployment

- Access WhoDB web UI.
- Verify connection to restored databases.
- Perform key workflows such as Table Schema visualization and data browsing.

---

## 5. Automating Backups and Safety Checks

To reduce risk, implement automated routines:

- **Schedule database backups** using cron jobs, Kubernetes CronJobs, or managed services depending on your environment.
- **Monitor backup success** and configure alerts for failures.
- Use checksum or integrity verification tools where supported.
- Maintain multiple backup copies with retention policies aligned with your business needs.

**Example Cronjob for PostgreSQL backup:**

```
0 2 * * * pg_dump -U user -h localhost -d postgres -F c -f /backup/whodb_postgres_$(date +"%Y%m%d").dump
```

---

## 6. Best Practices and Tips

- Regularly test restoration processes in a non-production environment.
- Encrypt backup files when storing them offsite.
- Ensure WhoDB login profiles are decoupled from user interface and access credentials are never exposed.
- Keep your database and WhoDB Docker images up to date to benefit from security patches.
- Document your backup and restore procedures as part of your operational playbook.

---

## 7. Troubleshooting Backup and Recovery

### Problem: Backup files are corrupt or incomplete
- Inspect logs from backup tools.
- Check disk space on backup destinations.
- Verify database connectivity and permissions.

### Problem: WhoDB fails to connect after restoration
- Confirm that database service endpoints and credentials have not changed.
- Validate environment variables and Docker volume mounts.
- Review WhoDB logs for connection errors.

### Problem: Automated backups not running
- Check cron syntax and permissions.
- Review container or host schedules.
- Confirm backup script executables and paths.

For further help, consult the [Troubleshooting Common Issues](/getting-started/troubleshooting/troubleshooting-common-issues) page.

---

## 8. Additional Resources

- [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database)
- [System Architecture Overview](/overview/architecture-concepts-group/system-architecture-overview)
- [Security and Authentication Essentials](/guides/best-practices-and-optimization/security-and-authentication)
- [Deploying with Docker & Docker Compose](/deployment/prod_deployment/docker_quickstart)

Secure backup and disaster recovery are the final safety nets that guarantee your WhoDB deployment remains resilient and trustworthy. Follow these guidelines closely to secure your data and maintain your operational confidence.

---


# deployment/operationalization/security_hardening.mdx
## Security Hardening for Production

Harden your WhoDB deployment against threats. This page covers exposed surfaces, authentication (cookie/session management), secure configuration of secrets, network security (firewall, TLS), and best practices for using WhoDB in regulated or sensitive environments.

# Security Hardening for Production

Strengthening your WhoDB deployment is essential to protect your data and infrastructure from evolving security threats. This guide walks you through the critical areas of security hardening—exposed surfaces, authentication safeguards, secrets management, network protections, and compliance best practices—empowering you to confidently deploy WhoDB in sensitive or regulated environments.

---

## 1. Harden Exposed Surfaces

The first step to securing WhoDB is minimizing and protecting the surface area exposed to potential attackers.

- **Restrict API Endpoints Access:** WhoDB exposes certain HTTP routes for its API and UI. Use firewall rules or reverse proxy configurations to restrict access only to trusted clients and networks.

- **Limit Public Routes:** By design, WhoDB's authentication middleware allows only a limited set of "public" routes (e.g., GraphQL introspection and login/logout operations). Ensure these endpoints are not unnecessarily exposed beyond what is required.

- **Disable Unnecessary Features:** If you have no need for features like the AI chat interface or advanced enterprise plugins, disable or restrict access to them via configuration or deployment choices.

Regularly audit network exposure with tools like `nmap` or cloud provider security scanners to confirm only intended endpoints are open.

---

## 2. Robust Authentication & Session Management

WhoDB manages authentication primarily using HTTP-only encrypted cookies or API gateway tokens, keeping user credentials secure and access controlled.

### Cookie and Session Management

- **HTTP-Only Cookies:** Authentication tokens are set as HTTP-only cookies, preventing client-side script access to these tokens and mitigating cross-site scripting (XSS) risks.

- **Limited Cookie Lifespan:** Configure session duration and implement appropriate timeout policies to reduce token misuse risks.

- **Secure Cookie Flags:** When deploying with TLS, ensure cookies use `Secure` and `SameSite` flags. This safeguards tokens during transit and limits cross-site request forgery (CSRF).

### API Gateway Token Authentication

- **Bearer Tokens:** For API Gateway enabled deployments, authentication tokens are passed in `Authorization: Bearer` headers.

- **Token Validation:** Ensure your tokens are securely generated, signed, and validated on every request.

### Best Practices

- Use strong, unique passwords for your database connections.
- Prefer profiles with limited privileges in your database—never use superuser credentials.
- Always log out users upon session termination using the `/logout` endpoint to invalidate tokens and cookies.

Verify authentication tokens are never exposed to client-side scripts or logs.

---

## 3. Secure Configuration of Secrets

WhoDB depends on several sensitive configuration values, such as database credentials and API keys. Protecting these is critical.

- **Environment Variables:** Store secrets in environment variables instead of hard-coded files or source control.

- **Secret Management Tools:** Use vault solutions (HashiCorp Vault, AWS Secrets Manager, etc.) for dynamic retrieval and rotation of secrets.

- **Least Privilege Principle:** Use credential sets scoped narrowly to required database schemas or operations.

- **Encrypted Storage:** Where persistence of secrets is necessary (e.g., config files or state), encrypt them at rest.

- **Avoid Logs Leakage:** Ensure logs, debug dumps, or error messages never output secrets unintentionally.

Review your deployment scripts and CI/CD pipelines to confirm secrets are masked and handled securely during deployments.

---

## 4. Network Security & Transport Layer Protection

Securing WhoDB's network interactions shields your deployment from interception and unauthorized access.

### TLS Configuration

- **Enable TLS:** Terminate TLS (HTTPS) either on WhoDB directly or through a fronting reverse proxy/load balancer.

- **Strong TLS Settings:** Use current TLS versions (1.2+), disable weak cipher suites, and enable HTTP Strict Transport Security (HSTS).

- **Certificate Management:** Use trusted certificates from established Certificate Authorities or leverage automated tools like Let's Encrypt.

### Firewall & Access Controls

- **Restrict Inbound Access:** Permit only trusted IP ranges to access WhoDB's backend and UI ports.

- **Segmentation:** Deploy WhoDB within a secure network segment or VPC isolated from public internet access, exposing only necessary endpoints.

- **API Gateway Security:** If enabled, place WhoDB behind an API gateway to enforce advanced access policies, throttling, and centralized logging.

Never expose WhoDB directly to the internet without proper TLS and firewall measures.

---

## 5. Best Practices for Regulated and Sensitive Environments

Deployments handling sensitive data or under compliance obligations require added diligence.

- **Audit Logging:** Enable and secure comprehensive audit logging for user activity, access attempts, and configuration changes.

- **Regular Updates:** Keep WhoDB and all dependencies updated with security patches. Subscribe to release notes and advisories.

- **Access Controls:** Implement role-based access control at both WhoDB and database levels.

- **Data Encryption at Rest:** Use encrypted filesystems or database-native encryption to safeguard stored data.

- **Backup Security:** Secure backups with encryption and restrict access to ensure data confidentiality in recovery situations.

- **Penetration Testing:** Regularly perform security assessments to discover and remediate potential vulnerabilities.

Refer to organizational security policies and compliance mandates (e.g., HIPAA, GDPR) to supplement WhoDB security configurations appropriately.

---

## 6. Step-by-Step: Applying Security Hardening to Your Deployment

### Step 1: Secure Your Network
- Configure firewall rules to allow only trusted clients.
- Set up TLS termination with valid certificates.

### Step 2: Configure Authentication Correctly
- Use HTTP-only, Secure cookies with proper flags.
- If API gateway enabled, deploy tokens securely and enforce expiration.

### Step 3: Manage Secrets Safely
- Store database credentials and API keys in environment variables or secrets manager.
- Avoid embedding secrets in code or config files.

### Step 4: Limit Exposure of Endpoints
- Use reverse proxies to restrict access to only necessary routes.
- Disable unused features or pages.

### Step 5: Monitor and Audit
- Enable logging of authentication events.
- Set up alerting for suspicious activities.

Test your hardened deployment by attempting unauthorized accesses in a controlled environment to validate protections.

---

## 7. Troubleshooting Common Security Issues

Ensure that cookies are correctly set with Secure and SameSite flags compatible with your deployment domain and browser settings. Check reverse proxy headers that may strip cookies.

Verify token validity and presence in requests. Confirm environment variables and secrets were correctly loaded and match database credentials. Check firewall and proxy rules are not blocking legitimate traffic.

Confirm certificate validity dates, trusted CA chain, and proper binding on your web server or proxy. Check TLS version compatibilities.

---

## 8. Additional Resources

- [Security and Authentication Essentials](https://whodb.com/docs/guides/best-practices-and-optimization/security-and-authentication) — deeper dive into WhoDB’s authentication flows.
- [Deploying with Docker & Docker Compose](https://whodb.com/docs/deployment/prod_deployment/docker_quickstart) — recommended deployment methods supporting secure configurations.
- [Environment Variables & Third-Party Integrations](https://whodb.com/docs/deployment/prod_deployment/env_config) — manage your secrets and runtime settings safely.
- [System Architecture Overview](https://whodb.com/docs/overview/architecture-concepts-group/system-architecture-overview) — understand how WhoDB processes requests securely.

---

By methodically applying these security hardening principles, you ensure your WhoDB deployment is resilient and trustworthy, enabling safe data management even in regulated or sensitive environments.

---


# faq/common-questions/product-purpose-inspiration.mdx
## What is WhoDB and What Inspired It?

Discover the vision behind WhoDB, what problems it solves, and how it builds on the strengths of similar tools like Adminer. Learn how WhoDB aims for lightweight efficiency while providing advanced database visualization and conversational data access.

# What is WhoDB and What Inspired It?

Discover the vision behind WhoDB, understand the problems it solves, and learn how it builds on the strengths of established tools like Adminer while advancing database management with modern, lightweight efficiency and AI-driven data access.

---

## Introduction

WhoDB is a next-generation database management tool that unifies access to SQL, NoSQL, and cloud databases through a sleek, intuitive web interface. Born from the inspiration of lightweight tools like Adminer, WhoDB enhances user productivity by combining simplicity with powerful features including advanced schema visualization and conversational AI data querying.

At its core, WhoDB is designed to meet the needs of developers, analysts, and database administrators who require quick, accurate, and natural interaction with diverse database systems without the bloat or complexity of many traditional tools.

## The Problem WhoDB Solves

Managing data across multiple database technologies is challenging. Users often juggle several disconnected tools to perform routine operations like browsing tables, editing records, or understanding complex relationships. Many existing solutions trade off speed, flexibility, or ease of use, leading to frustration and inefficiency.

Particularly, the lack of unified UI and interaction model between SQL and NoSQL databases slows development and data analysis workflows. Moreover, visualization of database schemas and relationships can be cumbersome or absent, leaving users to mentally connect the dots.

## Origins and Inspiration

Adminer is widely respected for its lightweight, single-file PHP approach to SQL database management. Its simplicity and speed inspired WhoDB’s emphasis on lightweight design and easy deployment. However, WhoDB advances beyond Adminer by introducing native support for various database types beyond SQL, integrated schema graph visualizations, and a built-in conversational AI interface that interprets natural language queries, turning them into SQL or NoSQL operations.

This harmonious blend of speed, efficiency, and intelligence sets WhoDB apart as an essential tool in modern data workflows.

## Key Vision and Goals

- **Unified Database Experience:** Seamlessly manage multiple database types from a single platform.
- **Lightweight and Fast:** Minimal system footprint with rapid UI responsiveness, ideal for development and production alike.
- **Enhanced Visualization:** Interactive schema graphs that help users explore and understand their data structures quickly.
- **Conversational AI Integration:** Empower users to query databases using natural language, simplifying complex data retrieval.
- **Extensibility and Modularity:** Modular plugin architecture to support extensible database and AI provider integrations.

## How WhoDB Builds on Adminer’s Strengths

| Feature                 | Adminer                                     | WhoDB                                        |
|-------------------------|---------------------------------------------|----------------------------------------------|
| Lightweight             | Single PHP file, very fast                   | Modular React/Go stack with embedded frontend; fast and minimal resource usage |
| Database Support        | Mainly SQL (MySQL, PostgreSQL, etc.)        | Broader: SQL, NoSQL (MongoDB), Column stores, Enterprise DBs                             |
| UI & Usability          | Basic UI with focus on clean look            | Modern React-based UI with advanced workflows, filtering, and inline editing           |
| Schema Visualization    | Limited static views                         | Interactive graph visualization of schemas and relationships                           |
| Querying               | Manual SQL query execution                   | Natural language querying with conversational AI assistance                            |
| Extensibility           | Plugin support via PHP                       | Plugin engine architecture supporting diverse backends and AI providers              |

## What Users Achieve with WhoDB

By choosing WhoDB, users can:

- Quickly connect and switch between different types of databases without context switching.
- Explore database schemas visually, grasp complex relationships at a glance.
- Perform CRUD operations efficiently with inline editing and filtering.
- Harness AI-driven natural queries to extract insights without SQL expertise.
- Deploy easily with Docker or manual methods, minimizing operational overhead.

## Real-World Scenario

Imagine a developer responsible for maintaining an application using PostgreSQL for transactional data, MongoDB for logs, and a cloud data warehouse. Traditionally, this would mean using three different tools. With WhoDB, the developer logs into a single interface that provides unified access to all these data sources.

Navigating through an interactive schema graph, they trace a relationship between user data and purchase history, then pose a natural language query asking, "Show me the top 10 customers by total spend last month." Instantly, WhoDB transforms this request into an optimized query across SQL and NoSQL stores, presenting results without writing a single SQL statement.

This fluid workflow accelerates decision-making and cuts down tool fatigue, illustrating WhoDB’s core value proposition.

## Getting Started with WhoDB

To begin experiencing this vision, users should start with the following:

- **Connect to Your Database:** Follow the quickstart guides to securely connect your databases to WhoDB.
- **Explore Schemas Visually:** Use the schema visualization tool to familiarize yourself with your database structure.
- **Try Conversational AI Queries:** Experiment with natural language queries in the AI Chat interface.
- **Edit and Manage Data:** Utilize inline editing and filtering to efficiently maintain your data.

## Related Documentation

- [Connecting to Your Database](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database)
- [Visualizing Your Database Schema](https://whodb.com/docs/guides/essential-workflows/visualizing-your-database-schema)
- [Querying Your Data with AI Chat](https://whodb.com/docs/guides/ai-and-natural-language/conversational-queries-and-ai-models)
- [Installation Methods](https://whodb.com/docs/getting-started/setup-requirements/installation-methods)

WhoDB combines the best principles of simplicity and power. Try starting with simple queries and schema exploration, then gradually unlock conversational AI for complex analytics.

While WhoDB supports many databases, ensure your specific database version and configuration are compatible as noted in the database support documentation.

---

By grounding itself in the proven lightweight philosophies of Adminer, WhoDB confidently brings modern features such as interactive visualization and AI-powered querying to the forefront, delivering a unified, efficient, and intelligent data management experience.

---

---


# faq/common-questions/database-compatibility-support.mdx
## Which Databases Does WhoDB Support?

Get a detailed overview of all supported databases in both Community and Enterprise editions. Understand how WhoDB ensures a consistent experience across SQL, NoSQL, and graph database systems and how database support is architected.

# Which Databases Does WhoDB Support?

Explore the comprehensive list of databases supported by WhoDB across both the Community and Enterprise editions. This page helps you understand how WhoDB provides a unified and consistent experience for managing SQL, NoSQL, and other database types through its plugin architecture.

---

## Overview

WhoDB is designed as a versatile and unified database management tool that integrates multiple databases into a seamless user experience. Whether you are working with relational databases like PostgreSQL and MySQL, NoSQL databases such as MongoDB, or even newer analytical engines like ClickHouse, WhoDB allows you to access and manage your data with consistent workflows.

The database support in WhoDB is architected through its modular plugin engine, which abstracts database-specific behaviors and facilitates consistent UI patterns and operational capabilities.

## Supported Database Types

### Community Edition Supported Databases
- **PostgreSQL**
- **MySQL**
- **MariaDB**
- **SQLite3**
- **MongoDB**
- **Redis**
- **ElasticSearch**

### Enterprise Edition Exclusive Databases
- **ClickHouse**

The Enterprise Edition extends support to additional databases, such as ClickHouse, leveraging advanced plugins and integration mechanisms.

## Database Categories and Characteristics

| Database Type    | Type       | Support Highlights                            | Schema Support | Scratchpad Support |
|------------------|------------|----------------------------------------------|----------------|--------------------|
| PostgreSQL       | SQL        | Full SQL, schemas, triggers, and advanced types | Yes            | Yes                |
| MySQL            | SQL        | Widely supported features, schemas             | Yes            | Yes                |
| MariaDB          | SQL        | Compatible with MySQL, full schema support      | Yes            | Yes                |
| SQLite3          | SQL (embedded) | File-based database, no schema support          | No             | Yes                |
| MongoDB          | NoSQL (document) | Collection-based, no schemas, no raw SQL support | No             | No                 |
| Redis            | NoSQL (key-value) | In-memory data store, limited editing features  | No             | No                 |
| ElasticSearch    | NoSQL (search)  | Document search optimized, no tables or schemas | No             | No                 |
| ClickHouse       | Analytical SQL | Columnar, supports SQL-like queries             | Yes            | Yes                |

### Clarifications

- **Schemas**: SQL databases like PostgreSQL and MySQL support database schemas to organize storage units (tables). NoSQL databases like MongoDB and Redis do not support schemas.
- **Scratchpad/Raw Query Execution**: Allows running arbitrary queries in the database’s native language. Not all databases support this feature (e.g., MongoDB and Redis do not).

## How WhoDB Ensures Consistency

### Plugin Architecture
WhoDB implements a plugin engine where each supported database has a dedicated plugin to translate native database concepts into WhoDB’s unified data model.

For example:

- PostgreSQL plugin fully supports schema discovery, table info, and advanced data types.
- MongoDB plugin maps collections to storage units and indexes.

This modular approach provides:

- **Consistent UI**: The interface behaves similarly regardless of database type.
- **Unified Features**: Features like schema visualization, data browsing, and scratchpad query execution adapt gracefully to database capabilities.
- **Extensibility**: New databases can be added via plugins without breaking existing functionality.

### Examples of Data Model Alignment

In WhoDB’s data model:

- **Storage Units** represent tables, collections, or keyspaces depending on the database.
- **Rows/Entries** and **Columns/Properties** are abstracted to provide common ground between SQL rows and NoSQL documents.

This allows users to navigate various databases as if using a single interface, simplifying data management.

## Practical User Workflows by Database

### Relational Databases (PostgreSQL, MySQL, MariaDB, SQLite3)

- Log in with credentials specifying the database and schema.
- Browse tables via the Table Schema page, filtering and searching data inline.
- Use the Scratchpad to run raw SQL queries, including complex joins and transactions.
- Visualize table relationships in Graph View.

### NoSQL Databases (MongoDB, Redis, ElasticSearch)

- Connect using appropriate credentials and select collections or keys.
- Browse collection documents or cache entries with simplified filtering.
- Limited or no raw query editing available (no scratchpad support).
- View indexes and basic schema outlines.

### ClickHouse (Enterprise Edition)

- Access via Enterprise license and credentials.
- Utilize full SQL capabilities with high-performance analytical queries.
- Scratchpad available for complex query execution.
- Enhanced schema visualization for columnar stores.

## Common Questions About Database Support

- **Can I use WhoDB to manage multiple types of databases simultaneously?**
  - Yes. You can configure multiple login profiles for different databases and switch between them seamlessly.

- **Does WhoDB support database-specific features like triggers or views?**
  - Where exposed by the database and plugin, yes. For example, PostgreSQL triggers and views are visible and manageable.

- **What if my database is not listed here?**
  - WhoDB’s architecture allows new database support through plugin development. Contact support or contribute plugins as needed.

## Troubleshooting Database Compatibility

Because MongoDB and Redis do not support SQL syntax, WhoDB disables the Scratchpad for them. Use their native query interfaces through the UI filters and document browsing.

These databases don't support schemas. WhoDB adapts the interface to show flat lists of storage units (tables or collections) without schema organization.

Yes. Each database has its own native data types. WhoDB translates these into a unified view but respects the original types for operations like filtering and editing.

## Best Practices for Working with Supported Databases

- Use Community Edition for widely-used relational and NoSQL databases if Enterprise features are not needed.
- Choose Enterprise Edition when working with advanced analytical databases like ClickHouse.
- Maintain up-to-date plugins and WhoDB versions to benefit from improved compatibility and features.
- Use login profiles to manage multiple database connections safely.
- Consult the respective database connection and security guides for optimizing performance and security.

## Related Documentation

- [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database): Step-by-step connection instructions for each supported database.
- [Plugin Engine & Database Integration](/concepts/architecture-overview/plugin-engine): Technical details on how WhoDB integrates databases.
- [Exploring and Managing Data](/guides/essential-workflows/exploring-and-managing-data): User workflows with supported databases.
- [Working Efficiently with Large Datasets](/guides/best-practices-and-optimization/working-efficiently-with-large-datasets): Optimization tips for managing large tables.
- [Choosing Community vs. Enterprise Edition](/deployment/prod_deployment/edition_selection): Help deciding on the product edition based on your database needs.

## Summary

WhoDB supports a robust set of SQL, NoSQL, and analytical databases through its modular plugin architecture. Users get a consistent UI and features regardless of the underlying database system, with specific capabilities tailored to each database's strengths. Whether you're working with PostgreSQL schemas, viewing MongoDB collections, or running complex ClickHouse queries, WhoDB provides a unified platform designed for productivity and flexibility.

---

---


# faq/common-questions/what-makes-whodb-different.mdx
## How is WhoDB Different From Other Tools?

Unpack WhoDB’s unique value proposition, especially compared to popular tools like DBeaver. Learn how WhoDB balances features with performance, prioritizing low resource usage and an accessible UI.

# How is WhoDB Different From Other Tools?

WhoDB stands out in the crowded landscape of database management tools by combining a minimalist yet powerful user experience with impressive performance and broad database support. Unlike heavyweight tools such as DBeaver that can be resource-intensive and complex, WhoDB delivers a lightweight, web-based interface designed to let you explore, query, and visualize your data quickly and effortlessly.

## 1. Lightweight and High-Performance

WhoDB is intentionally crafted to require minimal system resources. It offers fast startup times and swift responsiveness even with large datasets or complex schemas. This is achieved through optimized backend plugins and efficient frontend techniques like lazy loading, virtualization, and smart pagination.

- **Example**: While DBeaver can become sluggish managing multiple large databases, WhoDB’s architecture ensures smooth navigation and rapid query execution.

## 2. Web-Based UI for Easy Access

WhoDB’s entirely web-based user interface means you can access your databases through a browser without needing heavyweight desktop client installations.

- The UI is embedded within the backend server application, simplifying deployment and upgrades.

- Enables seamless use from any device without compatibility worries.

## 3. Unified Experience Across Multiple Database Types

WhoDB supports a wide range of databases — relational, NoSQL, and analytical databases — through a modular plugin engine. This results in a consistent, unified way to explore data regardless of the technology.

- **Value:** You don’t need to learn a different tool for each database type.

- **Example:** You can query PostgreSQL, MySQL, ClickHouse, MongoDB, Redis, and Elasticsearch all within the same interface.

## 4. Clear and Intuitive Schema Visualization

One of WhoDB’s signature features is its interactive schema graph visualization that reveals storage units (tables, collections, indices) and the relationships among them.

This visual approach helps users understand data structure quickly — arguably more clearly than traditional ER diagrams in some competing tools.

## 5. Conversational AI Integration

WhoDB integrates with leading AI models to enable natural language querying and conversational data exploration.

- This significantly lowers the barrier for non-technical users or those unfamiliar with SQL.

- It also accelerates prototyping and data analysis workflows.

## 6. Focus on Practical User Workflows

WhoDB is designed around what users need day-to-day:

- Quick connection to databases with credential profiles
- Efficient browsing, filtering, and editing of data
- Running raw SQL with history and organized queries
- Visualizing schema relationships effortlessly

This pragmatic focus contrasts with some tools that layer many advanced but less commonly used features, causing complexity.

## 7. Open Source with Enterprise Extensibility

While the core WhoDB offering is open source and free to use, an Enterprise Edition introduces additional plugins and features tailored to large-scale and regulated environments — enabling flexibility as your needs grow.

## Summary Table

| Feature                   | WhoDB                                       | Typical Competing Tools (e.g., DBeaver)       |
|---------------------------|---------------------------------------------|------------------------------------------------|
| UI Type                   | Web-based, accessible anywhere              | Desktop client only                            |
| Resource Usage            | Very low, optimized backend/frontend        | Can be heavy, requires more RAM/CPU           |
| Supported Databases       | Broad: SQL, NoSQL, analytical               | Also broad but sometimes fragmented            |
| Schema Visualization      | Interactive graph with relationship focus  | Standard ER diagrams, sometimes cluttered     |
| AI and Natural Language   | Native integration with multiple AI models | Rare or none                                  |
| Deployment                | Single binary backend, easy Dockerization   | Complex installs and dependencies              |
| Editing & Querying        | Inline editing, raw SQL with history        | Rich but often complicated UIs                  |

---

## Common Questions

Absolutely. WhoDB complements existing tools by providing a responsive web UI that can speed up everyday exploration and queries while still allowing deep administrative tasks to be performed in specialized clients.

Yes. The Enterprise Edition offers additional plugins and security features required for enterprise-grade deployments, while the Community Edition remains efficient for small to medium teams.

WhoDB covers common SQL dialects and features with its plugin engine, focusing on the most used operations for browsing and querying. Raw SQL execution is supported so advanced users can run full queries as needed.

## Practical Tips for Getting Started

- **Start small:** Connect WhoDB to a familiar database and explore schema visualization to appreciate its clean UI.
- **Leverage AI chat:** Use natural language queries to speed up data exploration without writing SQL.
- **Use profiles:** Save connection credentials to switch between multiple databases effortlessly.
- **Optimize performance:** Take advantage of pagination and filtering to work comfortably with large datasets.

## Troubleshooting Common Concerns

WhoDB uses efficient backend plugins that fetch metadata and data selectively. The web UI uses virtualized tables and lazy loading so only visible data is loaded, minimizing memory and network usage.

Yes, as long as the database is reachable from the WhoDB server backend. Configure credentials and network access properly. Consult the database connection guide for details.

WhoDB supports the most popular SQL and NoSQL databases via its modular plugin architecture. See the supported database list for exact compatibility.

## Further Reading and Related Documentation

- [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database): Step-by-step guidance for linking WhoDB with various databases.
- [Visualizing Your Database Schema](/guides/essential-workflows/visualizing-your-database-schema): How to use WhoDB’s interactive schema graph.
- [Querying Your Data with AI Chat](/guides/ai-and-natural-language/conversational-queries-and-ai-models): Unlock natural language queries powered by integrated AI.
- [Working Efficiently with Large Datasets](/guides/best-practices-and-optimization/working-efficiently-with-large-datasets): Techniques to keep the UI responsive.
- [System Architecture Overview](/overview/architecture-concepts-group/system-architecture-overview): Understand WhoDB’s modular design that ensures performance and extensibility.

---

## Diagram: WhoDB’s Unique Architecture Compared to Traditional Tools

```
flowchart TD
    subgraph WhoDB
      UI["Web-Based UI"]
      Backend["Lightweight Backend/API"]
      Plugins["Modular Database Plugins"]
    end

    subgraph TraditionalTools["Traditional Desktop Tools"]
      DesktopUI["Heavy Desktop Client"]
      EmbeddedDB["Internal DB Engine / Adapters"]
    end

    UI --> Backend
    Backend --> Plugins
    Plugins --> Database["Databases (SQL/NoSQL/Analytics)"]
    DesktopUI --> EmbeddedDB
    EmbeddedDB --> Database

    classDef whoDBStyle fill:#e0f7fa,stroke:#00796b,stroke-width:2px;
    class WhoDB whoDBStyle;

    classDef traditionalStyle fill:#ffccbc,stroke:#bf360c,stroke-width:2px;
    class TraditionalTools traditionalStyle;

    Database --- OS

```

---


# faq/common-questions/deployment-quickstart.mdx
## How Do I Deploy or Run WhoDB?

Step-by-step guidance on launching WhoDB—whether via Docker, Docker Compose, or manual installation. Find out tips for common configuration issues and pointers for both editions.

# How Do I Deploy or Run WhoDB?

Discover step-by-step guidance to launch WhoDB efficiently, whether using Docker, Docker Compose, or manual installation and builds. This guide covers both Community Edition (CE) and Enterprise Edition (EE) deployment methods, tips for configuration, and troubleshooting common issues during setup and runtime.

---

## Quick Start: Launching WhoDB Easily

### Running WhoDB Without Containers

The simplest way to start WhoDB is via the provided scripts for Community or Enterprise Edition. This method runs WhoDB directly on your host system.

Run the following in your project root:
```
./run.sh
```
Access the UI at [http://localhost:8080](http://localhost:8080).

Run the Enterprise Edition with:
```
./run.sh --ee
```
This requires EE source and modules.

These scripts compile and start the Go backend with embedded frontend. Use `--ee` flag to switch editions.

### Development Mode with Hot Reload

For active development where code changes automatically reload the UI and backend:
```
./dev.sh           # For Community Edition
./dev.sh --ee      # For Enterprise Edition
```
Frontend dev server runs on [http://localhost:1234](http://localhost:1234) with hot reload.

---

## Deploying WhoDB with Docker

Docker offers a streamlined environment for deploying WhoDB with minimal local dependencies.

### Run with Docker

Pull and run the Community Edition image easily:
```
docker run -it -p 8080:8080 clidey/whodb
```
This runs WhoDB and exposes it on port 8080.

### Docker Compose Setup

Use the provided `docker-compose.yml` to manage containers and environment variables:
```
version: "3.8"
services:
  whodb:
    image: clidey/whodb
    ports:
      - "8080:8080"
    environment:
      - WHODB_OLLAMA_HOST=localhost
      - WHODB_OLLAMA_PORT=11434
      - WHODB_ANTHROPIC_API_KEY=your_api_key_here
      - WHODB_OPENAI_API_KEY=your_api_key_here
    volumes:
      - ./data:/db
```
Start with:
```
docker-compose up
```

The volume mount `./data:/db` is optional but recommended for persisting SQLite data.
Configure AI API keys or Ollama host here if using conversational AI features.

### Building Docker Images Locally

You can build your own Docker images for CE or EE:

#### Build CE Image
```
docker build -f core/Dockerfile -t whodb:ce .
```

#### Build EE Image (requires EE access)
```
docker build -f core/Dockerfile.ee -t whodb:ee .
```

#### Multi-Architecture Build with Push

Enable Docker buildx and create a builder:
```
docker buildx create --use
```
Then build and push:
```
docker buildx build --platform linux/amd64,linux/arm64 \
  -t whodb-ce:latest \
  -f core/Dockerfile . --push
```

---

## Manual Build and Run Process

For full control or customization, build WhoDB manually from source.

### Prerequisites
- **Go 1.21+**
- **Node.js 18+**
- **pnpm** (`npm install -g pnpm`)
- **Git** (for version info)
- Optional: Docker, Make, Ollama (for AI chat)

### Step 1: Build Frontend

Navigate to the frontend directory:
```
cd frontend
```
Install dependencies if not done:
```
pnpm install
```
Generate GraphQL types with backend running (see GraphQL generation below).

Build frontend assets:
```
# Community Edition
pnpm run build

# Enterprise Edition
pnpm run build:ee
```

### Step 2: Copy Frontend Build to Backend

Remove previous embedded build and copy the new one:
```
rm -rf ../core/build
cp -r dist ../core/build
```

### Step 3: Build Backend

Change directory to core:
```
cd ../core
```
Build the Go binary:
```
# Community Edition
go build -o whodb

# Enterprise Edition
go build -tags ee -o whodb-ee
```

Backend compilation embeds the frontend build from `core/build` to serve assets seamlessly.

### Step 4: Run the Built Binary

Start the program:
```
# Community Edition
./whodb

# Enterprise Edition
./whodb-ee
```
Access WhoDB at [http://localhost:8080](http://localhost:8080).

### GraphQL Types Generation

When changing backend schema, regenerate GraphQL types before rebuilding frontend.

Prerequisites:
- Backend running on `http://localhost:8080` with introspection enabled (run backend in dev mode using `ENVIRONMENT=dev go run .`)

Generate types separately for editions:
```
# CE edition
cd core
ENVIRONMENT=dev go run .

# In another terminal
cd frontend
pnpm run generate:ce

# EE edition
cd core
ENVIRONMENT=dev go run -tags ee .

# In another terminal
cd frontend
pnpm run generate:ee
```

Always use the `@graphql` import alias in frontend code to ensure edition agnostic GraphQL types usage.

---

## Running WhoDB in Development

Run backend and frontend together with live reload for code changes:
```
./dev.sh          # Community Edition
./dev.sh --ee     # Enterprise Edition
```

Backend listens on 8080, frontend dev server on 1234 (hot reload enabled).

Press `Ctrl+C` to stop all running processes.

---

## Troubleshooting

### Common Issues

- **pnpm Not Installed**:
  Install globally:
  ```
  npm install -g pnpm
  ```

- **EE Directory Not Found**:
  Ensure you have access to EE modules and the `ee` directory resides in the project root.
  Run:
  ```
  ./scripts/validate-ee.sh
  ```

- **GraphQL Generation Fails**:
  Confirm backend runs with introspection enabled.
  Download Go module dependencies:
  ```
  cd core
  go mod download
  cd ../ee
  go mod download
  ```

- **TypeScript Errors During Build**:
  Run type check:
  ```
  cd frontend
  pnpm exec tsc --noEmit
  ```
  Refresh GraphQL types if needed.

- **Frontend Build Missing at Runtime**:
  Build frontend and copy to backend:
  ```
  cd frontend
  pnpm run build
  cp -r dist ../core/build
  ```

- **Port 8080 Already in Use**:
  Identify and stop the blocking process:
  ```
  lsof -i :8080
  kill -9 
  ```

### Clean Build Procedure

If persistent issues occur, clean all builds and dependencies:
```
./build.sh --clean          # CE clean build
./build.sh --clean --ee     # EE clean build
rm -rf core/build frontend/dist frontend/node_modules
rm -f core/whodb core/whodb-ee
```

---

## Best Practices and Tips

- Always build frontend before backend to embed assets correctly.
- Use the official build scripts (`build.sh`, `build-backend.sh`, `build-frontend.sh`) for consistency.
- For EE builds, run `./scripts/validate-ee.sh` before building to verify requirements.
- Use Docker for quick, consistent deployments, especially in production.
- Configure environment variables like `PORT`, `VITE_API_URL`, and edition-specific flags for custom deployments.

---

## Additional Help & Resources

- Full build and run instructions with environment configuration: [BUILD_AND_RUN.md](https://github.com/clidey/whodb/blob/main/BUILD_AND_RUN.md)
- Docker deployment guide: [Deploying with Docker & Docker Compose](https://whodb.com/docs/deployment/prod_deployment/docker_quickstart)
- EE validation and building: [scripts/validate-ee.sh](https://github.com/clidey/whodb/blob/main/scripts/validate-ee.sh)
- GraphQL generation details: [frontend/GRAPHQL_SETUP.md](https://github.com/clidey/whodb/blob/main/frontend/GRAPHQL_SETUP.md)

For support, contact support@clidey.com or file an issue on GitHub.

---

## Summary Flow Diagram

```
flowchart TD

  A[User: Decide deployment method] -->|Docker| B[Use Docker image or Compose]
  A -->|Manual| C[Build and run from source]

  subgraph Docker Deployment
    B --> D[Pull image or build locally]
    D --> E[Run container, map port 8080]
    E --> F[Access WhoDB UI]
  end

  subgraph Manual Build
    C --> G[Setup prerequisites: Go, Node, pnpm]
    G --> H[Generate GraphQL types]
    H --> I[Build frontend]
    I --> J[Copy frontend build to backend]
    J --> K[Build backend executable]
    K --> L[Run backend]
    L --> F
  end

  F --> M[Use WhoDB at http://localhost:8080]

  style A fill:#f9f,stroke:#333,stroke-width:2px
  style F fill:#bbf,stroke:#333,stroke-width:2px
```

---

---


# faq/troubleshooting-optimizations/handling-large-queries-smooth-performance.mdx
## How Does WhoDB Handle Large Queries and Datasets?

Understand strategies like lazy loading and table virtualization that ensure smooth performance with big databases. Get advice on what to do if performance lags or memory usage spikes.

# How Does WhoDB Handle Large Queries and Datasets?

Discover how WhoDB stays fast and responsive when working with large queries and massive datasets. This page explains key strategies like lazy loading and table virtualization embedded in the Explore Storage Unit and data viewing pages, guiding you to optimize your experience and troubleshoot common performance hurdles.

---

## Table of Contents
- [Managing Large Datasets with Lazy Loading](#managing-large-datasets-with-lazy-loading)
- [Smooth Scrolling with Table Virtualization](#smooth-scrolling-with-table-virtualization)
- [Practical Tips for Working with Big Tables](#practical-tips-for-working-with-big-tables)
- [Handling Performance Lags and Memory Spikes](#handling-performance-lags-and-memory-spikes)
- [Troubleshooting Common Issues](#troubleshooting-common-issues)

---

## Managing Large Datasets with Lazy Loading

When you open a storage unit (table or collection) in WhoDB's Explore Storage Unit page, the system does not load all the data at once. Instead, it uses **lazy loading**—data is fetched in manageable chunks only as needed.

- The page fetches rows by request, controlled by `Page Size` and `Page Offset`.
- Queries default to loading a preset number of rows (commonly 100) to avoid overwhelming your browser and network.
- You can adjust the page size to balance data quantity and loading speed.

This strategy ensures your interface remains responsive by only rendering the visible and currently relevant subset of data.

### Example:
If you are exploring a table with 50,000 rows, WhoDB will fetch the first 100 rows initially. As you navigate through pages, subsequent chunks of data are retrieved dynamically.

## Smooth Scrolling with Table Virtualization

WhoDB's data tables leverage **table virtualization** via the `react-window` library to display only the rows visible on your screen:

- This minimizes the number of HTML elements rendered at any time.
- The viewport at any moment holds a fraction of the entire dataset, even if the dataset size is huge.
- Off-screen rows are removed from the DOM, saving memory and improving rendering performance.

Together with lazy loading, virtualization enables smooth table scrolling and interaction without delays or stuttering.

### What it means for you:
- No performance degradation when browsing millions of rows.
- Instantaneous response to paging and sorting commands.
- Seamless integration with inline editing, filtering, and row selection.

## Practical Tips for Working with Big Tables

To make your experience smoother and minimize load:

- Use filters to reduce the dataset before fetching, via the query builder in the Explore Storage Unit page.
- Start with moderate page sizes (e.g., 50-200 rows) and increase only if your system can handle it.
- Avoid retrieving entire datasets unless exporting or performing bulk operations.
- Take advantage of inline editing and row deletion at manageable data slices.
- Use pagination controls at the bottom of data tables to navigate efficiently.

## Handling Performance Lags and Memory Spikes

Although WhoDB employs best practices, working with very large datasets can still stress your system. Here is how to handle common performance issues:

### When experiencing UI lag or delays:

- **Reduce page size:** Smaller data chunks load faster and reduce memory usage.
- **Apply filters:** Narrow down your query to the relevant rows or columns.
- **Clear browser cache:** Sometimes UI rendering can slow down due to accumulated browser state.
- **Close unnecessary tabs or applications:** Free system resources.

### If memory usage spikes unexpectedly:

- Confirm that data fetching is paged and not loading full datasets unintentionally.
- Check for unusually large cell values (e.g., huge JSON documents) that may slow rendering.
- Restart the WhoDB web client to clear in-memory caches.

### Server-side hints:
- Ensure your backend database responds efficiently to paged queries.
- Use indexes and optimized queries where possible to reduce backend load.

## Troubleshooting Common Issues

Sometimes, fetching initial data chunks from very large tables takes time due to network latency or backend response speed. Consider reducing the page size or applying filters to limit returned rows. Also, check your database server's performance.

This may result from accumulated client-side state or browser memory pressure. Refresh the page to reset the state, clear your browser cache, and reduce page size settings to moderate values to prevent overload.

Break down your queries with filters or smaller page sizes. Verify backend database query timeout settings. Use the Scratchpad or Raw Execute page to test complex queries and optimize them before running in Explorer.

Regularly monitor query sizes and use filters to keep data loads manageable. Embrace pagination and lazy loading to avoid overwhelming both client and server.

---

## Additional Resources

- [Working Efficiently with Large Datasets Guide](/guides/best-practices-and-optimization/working-efficiently-with-large-datasets) — Detailed best practices for handling big data in WhoDB.
- [Storage Unit Page Overview](/guides/essential-workflows/exploring-and-managing-data) — Learn how to explore, edit, and manage your data using the Storage Unit page.
- [System Architecture Overview](/overview/architecture-concepts-group/system-architecture-overview) — Understand how WhoDB’s frontend and backend collaborate to deliver performant data interactions.
- [Scaling Strategies and Performance Optimization](/deployment/operationalization/scaling_performance) — Advanced operational guidance for running WhoDB at scale.

---

By applying these strategies and tips, you will ensure a fluid, effective experience with WhoDB, no matter your dataset size. Whether browsing millions of records or performing complex queries, WhoDB is engineered to help you stay productive without compromise.

---

_Last updated: June 2024_

---

---


# faq/troubleshooting-optimizations/login-auth-issues.mdx
## Troubleshooting Login and Connection Issues

Learn practical steps for resolving common authentication problems, network errors, or connection failures, including tips for both database credential and saved profile login modes.

# Troubleshooting Login and Connection Issues

Welcome to the comprehensive guide for resolving login and connection issues in WhoDB. This page focuses on helping users troubleshoot common problems encountered during authentication and database connection attempts, whether using direct database credentials or saved profiles.

---

## Table of Contents

- [Understanding Login Modes](#understanding-login-modes)
- [Common Login Issues and Fixes](#common-login-issues-and-fixes)
- [Connection Problems and Solutions](#connection-problems-and-solutions)
- [Network and Environment Considerations](#network-and-environment-considerations)
- [Advanced Troubleshooting Tips](#advanced-troubleshooting-tips)
- [Verification and Best Practices](#verification-and-best-practices)

---

## Understanding Login Modes

WhoDB supports two primary login modes to access your databases:

- **Database Credential Login:** Users manually input hostname, database name, username, password, and optional advanced parameters for a direct connection.
- **Saved Profile Login:** Users select from pre-configured connection profiles saved within WhoDB,
   enabling quick and consistent authentication.

Both methods trigger an authentication flow that validates your credentials with the backend and establishes a session.

---

## Common Login Issues and Fixes

### 1. _Required Fields Missing_

**Problem:** Attempting to submit login form with missing critical fields such as hostname, username, or database name.

**Cause:** The frontend validates required fields depending on the database type. Omission blocks login.

**Solution:**
- Ensure all required fields are filled *before* submitting.
- For PostgreSQL and MySQL, fill Hostname, Database, and Username.
- For SQLite, provide the database file path.
- For MongoDB and Redis, specify Hostname.

Use the `Host Name (or paste Connection URL)` input for some databases to streamline input.

### 2. _Invalid Connection URL Parsing_

**Problem:** Pasting a connection URL fails to extract necessary parts like hostname, username, or database.

**Cause:** URL format may be incorrect or incomplete for WhoDB's parsing logic.

**Solution:**
- Verify URL format matches standard conventions for your database.
- For PostgreSQL URLs, ensure it starts with `postgres://` or `postgresql://`.
- If URL parsing fails, manually enter advanced details such as port and SSL mode.

### 3. _Login Failure Notifications_

**Problem:** Receiving "Login failed" messages or errors like "Unauthorized".

**Cause:** Incorrect credentials, expired session, or backend rejection.

**Solution:**
- Double-check username and password.
- Verify database name and hostname/IP.
- If using saved profiles, ensure the profile still matches valid credentials.
- Check network access and firewall settings to the database host.

### 4. _Advanced Parameters Mistakes_

**Problem:** Misconfiguration in advanced form fields (e.g., incorrect port, SSL mode).

**Cause:** Incorrect or incompatible advanced settings can prevent connection.

**Solution:**
- Use documented defaults for your database type.
- For PostgreSQL, usually port 5432 and SSL mode 'disable' or 'require'.
- For MongoDB SRV URLs, ensure DNS Enabled flag matches your setup.
- Toggle the Advanced form visibility to review and correct.

---

## Connection Problems and Solutions

### 1. _Network Connectivity Errors_

**Symptoms:** Timeouts, unreachable host, connection refused.

**Causes:** Firewall blocks, wrong hostname, network interruptions.

**Check and Fix:**
- Confirm the hostname resolves correctly (DNS).
- Ping or telnet to the database host and port.
- Verify no VPN or proxy is interfering.
- Firewall or security groups on the server allow traffic.

### 2. _Profile-Based Login Fails_

**Symptoms:** Login with a saved profile returns failure.

**Causes:** Profile credentials outdated or the profile service is temporarily unavailable.

**Fix:**
- Edit and update the profile credentials manually.
- Remove and recreate the profile if corrupted.
- Ensure profiles are synced properly if environment variables define credentials.

### 3. _Cookie or Token Issues_

**Symptoms:** Login not persisting, repeated login prompts.

**Causes:** Browser cookies disabled or HTTP-only tokens not set.

**Fix:**
- Enable cookies and allow HTTP-only cookie support.
- Clear browser cookies and try again.
- Ensure backend is reachable and sets cookies properly.

### 4. _Backend or API Gateway Token Problems_

**Symptoms:** Unauthorized errors during usage despite valid credentials.

**Causes:** Expired or invalid API tokens when API Gateway is enabled.

**Solution:**
- Confirm API tokens are valid and match configured tokens.
- Renew or update token configuration if expired.
- Check environment variable `IsAPIGatewayEnabled` settings.

---

## Network and Environment Considerations

### Environment Variables

WhoDB’s operation depends on correctly set environment variables for credentials and runtime modes.

- Confirm variables for database credentials are accurate.
- Check for presence and correctness of API tokens if applicable.
- For Enterprise Edition, verify additional plugin and authentication settings.

### Using Connection URLs vs. Manual Fields

- Connection URLs can accelerate setup but require accurate formatting.
- When pasting URLs, WhoDB attempts to parse into discrete fields; errors here may need manual correction.

### Proxy and VPN

- Be aware VPNs or proxies may interfere with connectivity.
- Local network firewalls or corporate restrictions may block ports.

---

## Advanced Troubleshooting Tips

### Enable Debug Logs

- Monitor frontend console errors and network requests.
- Check backend logs for authentication errors or connection attempts.

### Profile Last Accessed Updates

- Successful login automatically updates ‘last accessed’ metadata conserving session history.
- Stale profiles can cause unexpected login behaviors.

### Handling Large Request Bodies

- The backend restricts login request payloads to 1MB.
- If advanced parameters become too large, simplify or validate inputs.

---

## Verification and Best Practices

### Step-by-Step Verification Checklist

1. Fill all required login fields accurately according to database type.
2. Use connection URLs carefully; verify auto-parsed fields.
3. If login fails, review notifications and error messages.
4. Confirm network availability and firewall settings.
5. For saved profiles, verify credentials have not expired or changed.
6. Enable advanced form parameters only when needed, keep defaults otherwise.
7. Clear browser cookies if session problems persist.
8. Confirm backend tokens and API gateway configurations.
9. Test login success by verifying transition to dashboard/storage view.

### Best Practices

- Save connection profiles for frequently used databases to speed up login.
- Regularly update saved profiles to keep credentials current.
- Use advanced options sparingly and document custom parameters.
- Monitor login errors promptly to address credential or network changes.

---

## Related Documentation

- [Connecting to Your Database](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database) — Setup credentials and connection examples
- [Security and Authentication Essentials](https://whodb.com/docs/guides/best-practices-and-optimization/security-and-authentication) — Managing secure login and session handling
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) — Wider scope of installation and runtime errors
- [First Run and Quick Validation](https://whodb.com/docs/getting-started/initial-config-launch/first-run-and-validation) — Initial login and validation tips

---

## Summary
This troubleshooting guide equips you with practical advice and actionable steps to quickly identify and resolve login and database connection issues in WhoDB. From validating credentials, parsing connection URLs, adjusting advanced settings, to ensuring network and backend readiness, your path is clear to stable, secure access.

Remember: effective login flows rely on accuracy, network accessibility, and proper session management. For persistent issues, consult backend logs and the linked guides to deepen your diagnostic reach.

---

---


# faq/troubleshooting-optimizations/ai-integration-troubleshooting.mdx
## Fixing Problems with Chat and AI Integrations

Find solutions for issues integrating with Ollama, ChatGPT, or Anthropic, such as API key configuration, missing chat options, or troubleshooting natural language query errors.

## Fixing Problems with Chat and AI Integrations

This page helps you resolve common issues encountered when integrating WhoDB's conversational AI features with providers like Ollama, ChatGPT, and Anthropic. Whether you're facing API key configuration errors, missing chat options, or unexpected natural language query failures, the following guidance will help restore your AI chat functionality swiftly.

---

### 1. Common Chat and AI Integration Issues

- **No Chat Options Displayed in UI**
- **API Key or Token Configuration Problems**
- **Failed or Incomplete AI Query Responses**
- **Errors when Adding or Using External AI Models**
- **Slow or Stuck Response in AI Chat**

---

### 2. Diagnosing Missing Chat Providers or Models

If you don't see available chat providers like Ollama, ChatGPT, or Anthropic in the chat UI:

- **Check Environment Variable Configuration:**
  - Confirm your API keys are correctly set as environment variables:
    - `WHODB_OPENAI_API_KEY` for ChatGPT
    - `WHODB_ANTHROPIC_API_KEY` for Anthropic
    - Optional overrides like `WHODB_OLLAMA_HOST` and `WHODB_OLLAMA_PORT` for Ollama
  - Without these keys, respective providers won't load. Ollama is included by default assuming a local service.

- **Validate Provider Presence in Backend:**
  - WhoDB queries available AI providers on startup through a GraphQL API.
  - Misconfiguration or missing keys will exclude providers from the dropdown.

- **Using Multiple or Custom Models:**
  - When using OpenAI compatible endpoints or custom models, ensure `WHODB_OPENAI_COMPATIBLE_API_KEY` and `WHODB_CUSTOM_MODELS` are defined properly.

---

### 3. Troubleshooting API Key and Token Issues

- **Invalid or Missing Tokens:**
  - AI providers require valid API keys or tokens to authenticate.
  - Verify that keys haven't expired or been revoked.
  - Ensure no extraneous spaces or malformed characters in the environment variables.

- **Adding External Models:**
  - When adding custom tokens for third-party models (e.g., ChatGPT or Anthropic) via the 'Add External Model' dialog:
    - Select the correct model type.
    - Enter the corresponding API key/token.
    - Submit and wait for confirmation of successful connection.
  - If the token is invalid, an error notification will appear.

- **Token Scope and Permissions:**
  - Confirm that the API key has sufficient permissions to access the model endpoints.
  - For example, OpenAI tokens require access to chat completion APIs.

---

### 4. Handling AI Chat Query Failures or Errors

- **Failed Query Execution:**
  - If a query does not execute and you see an error message such as "Unable to query. Try again," verify:
    - Network connectivity to API endpoints.
    - Correct model and token selection in the chat UI.
    - Backend logs for detailed error causes.

- **Partial or No Responses:**
  - Streaming responses may be interrupted by network timeouts or API errors.
  - Retry the query after checking your internet connectivity.
  - Confirm API rate limits for your key have not been exceeded.

- **Delayed or Stuck Responses:**
  - Occasionally, AI responses might take longer due to model processing times.
  - Use the loading indicators (e.g., “Thinking” messages) to monitor progress.
  - Cancel and retry if stuck beyond a reasonable time.

---

### 5. Best Practices and Tips for Reliable AI Integrations

- **Keep API Keys Secure:**
  - Use environment variables to store API keys securely, avoiding hardcoding.
  - Rotate keys periodically to maintain security.

- **Verify Model Availability:**
  - Regularly check available chat models after initial setup through the UI’s dropdowns.
  - Add or remove models as needed via the external model manager.

- **Use the Latest Endpoints:**
  - Keep your environment variables pointing to the latest OpenAI/Anthropic endpoints.
  - Custom endpoints must be correctly formatted URLs.

- **Test with Example Queries:**
  - Use preset chat examples on the chat page to verify end-to-end functionality.
  - This confirms that your AI models respond correctly.

- **Monitor Backend Logs:**
  - Inspect server logs for API request failures, authentication errors, or network timeouts.
  - Logs provide insights to root causes beyond frontend symptoms.

---

### 6. Step-by-Step: Refreshing AI Model List and Tokens

Navigate to the AI Chat page in WhoDB from the main menu.

Observe the provider dropdown to confirm if your expected models (Ollama, ChatGPT, Anthropic) appear.

Click 'Add External Model' to input tokens for additional models.
Enter the token securely and submit.

Choose your AI model from the model dropdown.
Input a test query and submit to verify response.

If errors occur, note error messages and verify environment variables or network.
Restart your WhoDB backend if necessary after config changes.

---

### 7. Troubleshooting Quick Reference

IssueCauseSolution

No providers in dropdownMissing or invalid API keys in environment variablesSet correct keys; restart app to reload providers
Adding external model failsIncorrect token or network failureRecheck token validity; confirm network connectivity
Query returns errorAPI rate limits, invalid model, or token expiredCheck key status/rate limits; select correct model
Chat response incomplete or slowNetwork issues or provider service delaysRetry; monitor logs; use stable network
Ollama connection problemsWrong host/port or service not running locallyVerify `WHODB_OLLAMA_HOST`/`WHODB_OLLAMA_PORT`; ensure Ollama server is active

---

### 8. Related Documentation

- [Querying Your Data with AI Chat](https://whodb.com/docs/guides/ai-and-natural-language/conversational-queries-and-ai-models) — Detailed usage of the AI Chat page and providers.
- [Environment Variables & Third-Party Integrations](https://whodb.com/docs/deployment/prod_deployment/env_config) — Configure API keys and endpoints.
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) — Broader troubleshooting for WhoDB.
- [Conversational AI Integration](https://whodb.com/docs/concepts/integration-patterns/ai-integration) — Underlying AI integration architecture.

---

### 9. Getting Further Help

If you continue to experience problems:

- Review server-side logs for detailed error messages.
- Validate API key permissions with your AI provider dashboards.
- Consult WhoDB community forums or contact support through the official website.

Ensuring your API keys remain valid and available in the environment is critical to maintaining a smooth AI chat experience. Regularly verify and update tokens to avoid unexpected disruptions.

---

This guide equips you with the knowledge to identify and solve common integration problems, keeping your WhoDB AI chat feature responsive and reliable.

---


# faq/troubleshooting-optimizations/ui-and-editing-errors.mdx
## Solving UI or Data Editing Errors

Tips for dealing with interface glitches, missing data, or issues when creating, editing, or deleting data in the UI. Covers both local browser problems and server-side issues.

# Solving UI or Data Editing Errors in WhoDB

When working with WhoDB's user interface for managing and editing your database data, encountering glitches or unexpected issues can interrupt your workflow. This documentation page focuses specifically on diagnosing and resolving common UI problems, data entry errors, and related issues that occur while creating, editing, or deleting data in the interface. It addresses problems originating both from your local browser environment and server-side processes.

---

## 1. Common UI and Data Editing Errors

### 1.1. Interface Glitches and Freezing
- **Symptoms:** Buttons or dialogs become unresponsive, data grids stop updating, or UI components fail to render.
- **Causes:** Usually caused by browser memory limits, long-running queries, or unexpected input formats.
- **Resolution:** 
  - Refresh the browser tab and retry the action.
  - Clear browser cache or try a different browser.
  - Limit the number of rows fetched or page size to reduce load.
  - Avoid overly complex or malformed filters.

### 1.2. Missing or Incomplete Data Display
- **Symptoms:** Rows or columns of data fail to appear or show as empty.
- **Causes:** 
  - Network interruptions.
  - Server-side errors retrieving row data.
  - Incompatible database types or missing schema metadata.
- **Resolution:** 
  - Confirm network connectivity.
  - Refresh the data view using the Query button.
  - Adjust filtering or pagination settings to simpler states.
  - Re-log in or check if your database connection is still active.

### 1.3. Errors Adding or Updating Rows
- **Symptoms:** Submission forms for adding or editing data show error messages or fail silently.
- **Causes:** 
  - Required fields missing or invalid.
  - Backend validation or mutation errors.
  - Server-side connection issues.
- **Resolution:**
  - Ensure all required fields are filled with valid inputs.
  - Observe error messages and retry.
  - Check if you have proper permissions.
  - Reauthenticate if session expired.

### 1.4. Row Deletion Fails or Partially Succeeds
- **Symptoms:** Attempted deletion only removes some rows or returns error notifications.
- **Causes:** 
  - Some rows cannot be deleted due to database constraints.
  - Network or backend failure during batch deletion.
- **Resolution:**
  - Delete rows one at a time if batch fails.
  - Review error messages to identify specific row restrictions.
  - Contact your database administrator if permission issues persist.

---

## 2. Troubleshooting Steps

Follow these step-by-step procedures to diagnose and fix common UI or editing problems in WhoDB:

### Step 1: Verify Your Environment
- Confirm your browser is up to date.
- Disable browser extensions that may interfere (e.g., ad blockers).
- Test on a different browser or computer.

### Step 2: Check Network and Connection
- Confirm stable internet connection.
- Reconnect your database profile if disconnected.

### Step 3: Reduce Data Load
- Lower page size or adjust filters to limit fetched rows.
- Navigate to other pages to confirm data pagination works correctly.

### Step 4: Observe and Interpret Notifications
- Watch for real-time notifications after actions like save, delete, or add.
- Use clear error messages to guide input corrections.

### Step 5: Clear Temporary Input
- When forms refuse to close or act erratically, ensure all inputs are reset.
- Use Escape or Cancel buttons as appropriate.

### Step 6: Use Developer Tools for Advanced Debugging
- Open browser console to inspect network requests and errors.
- Report errors with relevant screenshots or logs to support.

---

## 3. Best Practices to Prevent Errors

- **Save edits promptly:** Avoid long-running edits to reduce session expiry risks.
- **Validate inputs:** Always enter data following field type constraints (e.g., UUID, timestamps).
- **Use filtering carefully:** Complex filters can slow or freeze data preview.
- **Limit batch operations:** Large batch deletions or updates are prone to partial failure.
- **Stay updated:** Keep your WhoDB installation and database drivers current.

---

## 4. Specific Tips for Editing and Adding Rows

- When adding new rows, the interface initializes fields with default values such as `gen_random_uuid()` for IDs or `now()` for timestamps.
- Ensure you modify at least one field to enable form submission, otherwise the add dialog will close automatically.
- If working with NoSQL databases, row fields may appear as JSON strings; validate JSON formatting strictly.
- Use the "Add Row" toggle carefully; you can cancel without data loss if no changes are made.

## 5. Handling Server-Side Failures

- When mutations to update or delete rows fail, WhoDB will notify you with error messages including server responses.
- If multiple row deletions are performed and one fails, the process will stop to avoid inconsistent states; retry deletions individually.
- Ensure that your database user has necessary permissions for the operations.

---

## 6. Related Diagnostic Information

- **Notifications:** Look for success or error messages at the top of the UI after operations.
- **Loading Indicators:** Spinners indicate ongoing server interactions; avoid multiple submissions until completion.
- **Data Caching:** Client uses no-cache fetch policy to ensure fresh reads; stale data issues are minimized.

---

## 7. Getting Further Help

- If issues persist, collect browser console logs and relevant steps.
- Contact WhoDB Support or visit the [Community Forums](https://whodb.com/community) with detailed descriptions.
- Refer to the [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) guide for broader help.

---

## 8. Summary

This page has empowered you to identify, diagnose, and resolve problems encountered in WhoDB's UI related to data exploration, editing, and management. By following best practices, reducing load, and making careful input validations, you can maintain a smooth interface experience. For complex issues, leveraging developer tools and support channels ensures continued productivity.

---

## Appendix: Example User Flow to Fix a Non-Responsive Add Row Dialog

1. Open the Data page for your storage unit.
2. Click "Add Row" to open the new row form.
3. Notice the form is unresponsive or won't close.
4. Check if any fields have been modified. If not, press **Escape** key or click outside the form.
5. If the form still remains, refresh the browser.
6. Retry adding data by filling at least one non-default value.
7. Submit and watch for success notification.

---

## Appendix: Troubleshooting Table Updates

- On inline cell edits, if changes are not saved:
  - Confirm network connectivity.
  - Observe error notifications for conflicts.
  - Verify permissions on the database.
  - Refresh the page to reload data and retry.

---

For more information on managing your databases and advanced troubleshooting, explore related pages:
- [Exploring and Managing Data](https://whodb.com/docs/guides/essential-workflows/exploring-and-managing-data)
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues)
- [Security and Authentication Essentials](https://whodb.com/docs/guides/best-practices-and-optimization/security-and-authentication)

---

*This documentation pertains exclusively to UI and data editing issues within WhoDB's data exploration and management interface.*

---


# faq/help-community-support/getting-help-contacting-support.mdx
## How Do I Get Help or Contact Support?

All available help and contact channels, including official support email, documentation links, and where to submit feedback or issues for timely assistance.

# How Do I Get Help or Contact Support?

Welcome to the central hub for all your support and assistance needs with WhoDB. This page guides you through the available channels where you can get official help, report issues, submit feedback, and find key documentation resources to maximize your productivity and resolve any challenges efficiently.

---

## Frequently Asked Questions

### Where can I get official support for WhoDB?
You can reach WhoDB official support by sending an email to **support@whodb.com**. The support team responds promptly to inquiries regarding technical issues, feature requests, and account-related questions.

### Is there a dedicated place for submitting bugs or feature requests?
Yes. For bugs or feature requests, please open an issue on the WhoDB GitHub repository at: [https://github.com/clidey/whodb/issues](https://github.com/clidey/whodb/issues). Make sure to provide detailed information including:
- The problem you encountered
- Steps to reproduce
- Your environment details (WhoDB version, database type, etc.)
- Screenshots or logs if available

This helps the development team triage and address issues swiftly.

### Where can I find comprehensive documentation?
The official documentation is hosted online, organized by topics such as installation, configuration, workflows, AI integrations, and troubleshooting. Access it anytime at: [https://whodb.com/docs](https://whodb.com/docs)

### How can I provide general feedback or feature suggestions?
You can submit feedback directly through the embedded form available within WhoDB's **Contact Us** page, accessible from the main menu. This form allows you to send suggestions, comments, or report non-critical issues conveniently.

### What if I have a question not covered here?
For any other inquiries, questions, or community engagement, consider joining the WhoDB community forums or mailing lists (links available in the documentation homepage). The community and official staff regularly participate to assist users and share best practices.

---

## Help and Support Channels

Email: support@whodb.com
Reach out directly for technical help, licensing questions, or urgent support needs. Expect responses within 24-48 hours.

https://github.com/clidey/whodb/issues
Report bugs, request new features, or track ongoing development discussions. Attach as much detail as possible.

In-app feedback via the "Contact Us" page allows submitting feedback and general questions through an embedded Google Form.
This provides a direct route for suggesting improvements or reporting problems without leaving WhoDB.

https://whodb.com/docs
Your go-to resource for setup instructions, feature guides, workflow tutorials, and troubleshooting knowledge base articles.

---

## Best Practices When Seeking Help

- **Be Specific**: When requesting support, provide clear, concise descriptions of your issue.
- **Include Context**: Specify WhoDB edition (Community or Enterprise), version number, database type, and environment (local, cloud, Docker).
- **Attach Logs or Screenshots**: If applicable, share relevant logs or screenshots to illustrate the problem.
- **Follow Up Promptly**: If support requests ask for additional information, respond as soon as possible to avoid delays.

---

## How to Use the Contact Us Page

The Contact Us page embeds a feedback form with fields for:
- Your name and email address
- The subject of your message
- A detailed description

This form sends messages directly to the WhoDB team, ensuring your feedback is reviewed and routed efficiently.

You can access this page via the main navigation or footer in the WhoDB interface.

---

## Troubleshooting and Self-Help

Before contacting support, consider these resources to help you solve common issues:

- **Troubleshooting Common Issues**: Visit [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues) for solutions on installation, connection problems, UI glitches, and AI chat errors.
- **FAQ and Common Questions**: Check the [FAQ section](https://whodb.com/docs/faq) for answers to frequent questions about WhoDB's usage and features.
- **Community Forums**: Engage with other users through forums or chat groups to share experiences and solutions.

---

## What Happens After You Contact Support

1. **Acknowledgment**: You will receive a confirmation that your query has been received.
2. **Initial Response**: Within 24-48 hours, support evaluates your issue and requests any additional info if needed.
3. **Issue Resolution**: Support or engineering will assist with fixes, workarounds, or guidance.
4. **Follow-Up**: You may be contacted to confirm resolution and provide feedback.

---

## Related Documentation and Next Steps

- [Installation & Setup Guides](/getting-started/setup-requirements/installation-methods)
- [Connecting to Your Database](/guides/essential-workflows/connecting-to-your-database)
- [Exploring and Managing Data](/guides/essential-workflows/exploring-and-managing-data)
- [Troubleshooting Common Issues](/getting-started/troubleshooting/troubleshooting-common-issues)
- [AI Chat and Conversational Queries](/guides/ai-and-natural-language/conversational-queries-and-ai-models)

Use these resources to resolve issues faster and deepen your understanding of WhoDB’s capabilities.

---

For the quickest support turnaround, always include your WhoDB version, your database type and version, and detailed steps to reproduce your issue.

You can also find a "Contact Us" option in the WhoDB application footer for quick access to feedback forms and support links.

---

We’re committed to helping you get the most out of WhoDB. Don't hesitate to reach out through these channels whenever you need assistance.

---


# faq/help-community-support/community-guides-contributing.mdx
## How Can I Contribute or Join the Community?

Details on contributing code, documentation, or feedback to WhoDB. Includes a summary of the contribution process, links to guides, and community best practices.

# How Can I Contribute or Join the Community?

Welcome to the WhoDB community! This page guides you through contributing to WhoDB—whether you want to add new features, improve documentation, provide feedback, or participate in discussions. By contributing, you help shape WhoDB’s future, improve user experience, and ensure WhoDB remains a powerful, user-centered database management tool.

---

## Why Contribute to WhoDB?

WhoDB thrives as an open, collaborative project driven by passionate users and developers. Contributing helps:

- **Enhance features and capabilities** to better fit real-world use cases
- **Improve documentation and onboarding** for new users
- **Identify and fix bugs quickly** through community testing
- **Build a supportive, knowledgeable community** around universal database management

Whether you’re a developer, writer, designer, or just enthusiastic about databases, your contributions can make a real impact.

---

## Ways to Contribute

You can contribute to WhoDB in one or more of the following ways:

### 1. Code Contributions

Implement new features, fix bugs, optimize performance, or develop enhancements. Given WhoDB’s modular architecture, contributions range from frontend UI improvements to backend plugin support.

**Getting started with code contributions:**

- **Fork the repository:** Create your personal copy on GitHub.
- **Set up your local environment:** Follow the [Frontend Development Guide](https://github.com/clidey/whodb/blob/main/frontend/README.md) and the [Build and Run Guide](https://whodb.com/docs/overview/what-is-whodb) for detailed setup.
- **Explore issues:** Look for issues labeled as `good first issue` or browse open tickets to find opportunities.
- **Develop in your branch:** Build your feature or fix.
- **Submit a Pull Request:** Follow contribution guidelines for code style, commit messages, and testing.

**Tips:**
- Keep changes focused and reviewable.
- Write meaningful commit messages.
- Include tests or documentation updates as appropriate.

### 2. Documentation Improvements

WhoDB’s documentation is critical for onboarding and usability.

You can help by:

- Improving clarity and examples in current guides
- Adding new tutorials or walkthroughs
- Fixing typos, formatting, or outdated info

All documentation lives within the repository and can be updated with a simple pull request.

### 3. Reporting Issues and Feedback

Use the [GitHub Issue Tracker](https://github.com/clidey/whodb/issues) to:

- Report bugs with detailed reproduction steps
- Suggest new features or improvements
- Provide feedback on usability, performance, or AI features

Clear, specific reports help maintainers respond faster and enhance WhoDB quality.

### 4. Community Engagement

Join discussions on GitHub or community forums to:

- Share tips and best practices
- Help troubleshoot others’ issues
- Collaborate on feature ideas

Engaged users help foster a thriving and supportive environment.

---

## Contribution Process Overview

Start by forking the WhoDB GitHub repo and cloning your fork locally.

Follow official frontend and backend setup guides, including generating GraphQL types and running locally.

Branch off from main or development branch with descriptive branch names like `feature/ai-query-enhancement`.

Write code or documentation changes, test locally, and ensure compliance with style conventions.

Make atomic commits with clear messages and push your branch to your fork.

Create a PR against the main branch, add a detailed description, and link relevant issues.

Respond to maintainers’ feedback, make adjustments, and verify tests before merge.

---

## Best Practices for Contributors

- **Read the Code of Conduct:** Ensure a friendly and respectful community environment.
- **Stay Updated:** Synchronize your fork regularly with the upstream main branch.
- **Write Tests:** Add or update tests that cover your changes.
- **Follow Coding Standards:** Use the existing code style and conventions.
- **Document Your Changes:** Update related docs or add comments where helpful.

---

## Tools and Resources

- [WhoDB GitHub Repository](https://github.com/clidey/whodb)
- [Frontend Development Guide](https://github.com/clidey/whodb/blob/main/frontend/README.md)
- [Build and Run Guide](https://whodb.com/docs/overview/what-is-whodb)
- [GraphQL Codegen Setup](https://github.com/clidey/whodb/blob/main/frontend/GRAPHQL_SETUP.md)
- [Issue Tracker](https://github.com/clidey/whodb/issues)
- [Contribution Guidelines](https://github.com/clidey/whodb/blob/main/CONTRIBUTING.md)

---

## How the WhoDB Team Handles Contributions

The core maintainers regularly review contributions, prioritizing those aligned with roadmap goals and community demand. Pull requests undergo automated testing and code review. Maintainers provide constructive feedback, and community contributions are integrated after vetting for quality and stability.

Maintainers also welcome community-driven feature proposals and encourage discussion to refine ideas before implementation.

---

## Joining the Community Channels

Stay connected through WhoDB’s online community platforms:

- **GitHub Discussions:** Engage with other contributors and users
- **Official Forums or Chat:** Announcements, help, and general conversations
- **Meetups & Events:** Occasional virtual or in-person gatherings

Community participation accelerates learning, support, and innovation.

---

## Frequently Asked Questions

No. While understanding databases helps, you can contribute to documentation, UI, or reporting without advanced database knowledge. The community is here to support learners.

Absolutely. Documentation, testing, issue reporting, and feedback are vital contributions that don’t require coding.

Simply open a feature request on GitHub with a clear description of the problem and proposed solution. Discussion will help refine it.

Yes, please follow the CONTRIBUTING.md for coding style, commit message conventions, testing, and PR guidelines.

Timing depends on complexity and reviewer availability. Minor fixes may be merged within days; larger features may take longer due to review and testing.

---

## Summary

Contributing to WhoDB is straightforward and rewarding. Whether through code, documentation, feedback, or community engagement, your efforts help improve WhoDB’s capabilities and user experience. Follow the documented process, use the available resources, and engage with the community to make the most of your contribution journey.

---

## Additional Resources

For a deeper dive into the frontend architecture and development, see:
- [WhoDB Frontend Development Guide](https://github.com/clidey/whodb/blob/main/frontend/README.md)
- [GraphQL Code Generation Setup](https://github.com/clidey/whodb/blob/main/frontend/GRAPHQL_SETUP.md)

Explore related documentation to understand how your contributions fit within WhoDB’s overall system:
- [What is WhoDB?](https://whodb.com/docs/overview/intro-value-group/what-is-whodb)
- [Core Concepts and Terminology](https://whodb.com/docs/overview/architecture-concepts-group/core-concepts-and-terminology)
- [System Architecture Overview](https://whodb.com/docs/overview/architecture-concepts-group/system-architecture-overview)

For assistance, refer to:
- [How Do I Get Help or Contact Support?](https://whodb.com/docs/faq/help-community-support/getting-help-contacting-support)
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues)

---

_Take the first step today—improve a doc, fix a bug, or propose a feature. Together, let's make WhoDB the best universal database manager._

---


# faq/help-community-support/where-to-find-full-docs.mdx
## Where Can I Find More Documentation?

Directs users to the official online documentation, describes available resources, and recommends where to look for advanced guides and updates.

# Where Can I Find More Documentation?

Welcome to the gateway for all further learning, resources, and in-depth guidance to master WhoDB. This page directs you to the rich, continuously updated official online documentation and related resources to help you explore advanced topics, troubleshoot complex issues, and contribute to the community.

---

## What Documentation is Available?

The official WhoDB documentation website is your comprehensive repository for everything WhoDB-related. Here, you can find detailed guides, reference materials, FAQs, conceptual explanations, and examples designed to empower you at every step.

### Key Documentation Categories

- **Getting Started Guides**
  - Step-by-step onboarding for installation, configuration, and first launches.
- **User Guides & Workflows**
  - Detailed workflows like connecting databases, exploring and managing data, and visualizing schemas.
- **AI and Conversational Interfaces**
  - How to leverage built-in AI chat features and advanced querying using natural language.
- **Conceptual Overviews**
  - Deep dives into WhoDB's architecture, data models, security, and extensibility patterns.
- **Deployment and Operational Guides**
  - Best practices for deploying in production, scaling, security hardening, and backups.
- **FAQ and Troubleshooting**
  - Solutions to common issues, performance tips, and support resources.
- **Community and Contribution**
  - Guidelines for contributing, joining discussions, and accessing community-built resources.

### Example Topics Covered

- How to extend themes and customize the frontend interface.
- Detailed instructions for generating GraphQL types and managing frontend builds.
- Guidance on using the scratchpad and advanced SQL querying features.
- Troubleshooting chat and AI integration problems.

---

## How to Access the Official Documentation

Access the full online documentation at:

[https://whodb.com/docs](https://whodb.com/docs)

This portal is regularly updated with new guides, best practices, and detailed explanations aligned with the latest WhoDB releases.

### Navigation Tips

- Use the search bar on the site to quickly find answers or topics.
- Browse by categories to explore interconnected workflows and concepts.
- Check the `FAQ` section for quick help with common questions.
- Review the `Getting Started` category for setup and installation insights.

---

## Recommended Documentation to Explore Next

To deepen your understanding or solve specific challenges, consider visiting the following guides:

- [Getting Started with WhoDB](https://whodb.com/docs/getting-started)
- [Connecting to Your Database](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database)
- [Using AI Chat for Querying](https://whodb.com/docs/guides/ai-and-natural-language/conversational-queries-and-ai-models)
- [Working Efficiently with Large Datasets](https://whodb.com/docs/guides/best-practices-and-optimization/working-efficiently-with-large-datasets)
- [Enterprise Edition Features](https://whodb.com/docs/deployment/prod_deployment/edition_selection)
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues)

---

## Staying Current and Getting Support

- **Documentation Updates**: Keep an eye on the official docs where updates and new guides appear alongside software releases.
- **GitHub Repository**: Explore the code, report issues, and follow development progress here:
  
  [https://github.com/clidey/whodb](https://github.com/clidey/whodb)

- **Community & Support**:
  - Join discussions and ask questions on community forums.
  - Use the official support channels for enterprise assistance.
  - Read the [Getting Help and Contacting Support](https://whodb.com/docs/faq/help-community-support/getting-help-contacting-support) guide for detailed support options.

---

## Tips for Effective Documentation Use

- **Start from Your Goal**: Identify what outcome you want (e.g., connecting a specific database, troubleshooting login) and choose guides accordingly.
- **Follow Workflows**: Many topics provide contextual user flows that show a practical sequence of steps.
- **Use Examples**: Sample snippets, commands, and configuration files in the docs help avoid guesswork.
- **Search for Keywords**: The docs are indexed and searchable by common phrases and error messages.

---

## Summary

This page is your launching point to access WhoDB’s full documentation ecosystem. Whether you are just starting, troubleshooting tough problems, or exploring advanced features, the official docs serve as your trusted companion.

Explore, learn, and master WhoDB by visiting the official documentation website and leveraging all the rich, real-world content created for your success.

---

## Related Documentation Links

- [Getting Started Guides](https://whodb.com/docs/getting-started)
- [Connecting to Your Database](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database)
- [Using AI Chat](https://whodb.com/docs/guides/ai-and-natural-language/conversational-queries-and-ai-models)
- [Troubleshooting Common Issues](https://whodb.com/docs/getting-started/troubleshooting/troubleshooting-common-issues)
- [Enterprise Edition Details](https://whodb.com/docs/deployment/prod_deployment/edition_selection)
- [Getting Help and Contact Information](https://whodb.com/docs/faq/help-community-support/getting-help-contacting-support)

---

## Next Steps

After reviewing this page, consider visiting key workflow guides to continue your WhoDB journey:

1. Install and configure WhoDB using the [Getting Started](https://whodb.com/docs/getting-started) section.
2. Connect your databases with detailed guidance in the [Connecting to Your Database](https://whodb.com/docs/guides/essential-workflows/connecting-to-your-database) guide.
3. Explore the power of natural language querying with AI Chat guides.
4. Troubleshoot effectively by accessing targeted support documentation.
5. Engage with the WhoDB community and contribute using resources linked on the official site and GitHub.

---

---